JavaScript is one of the most popular programming languages.

According to GitHub, JavaScript is the top programming language, and it's more than twice as popular as the runner‑up, Python.

Learning the JavaScript language is valuable for any developer. JavaScript is the language of the web supported by all major browsers, but tools exist to take JavaScript far beyond web pages. You can create native smartphone and tablet apps, desktop apps for Windows and Mac, and even server‑side apps using JavaScript.

Introduction to JavaScript

JavaScript started out as a way to add small bits of functionality to a website, but now JavaScript has evolved into much more.

JavaScript is used on the vast majority of websites and is supported by every major browser. The language has evolved to support the creation of business applications on the web. And with web connectivity built in, almost any kind of utility, security, or data application can be created using JavaScript.

Games can be created with JavaScript as well. You may have heard of Unity, a popular game engine for 3D and 2D games. JavaScript is supported as a programming language for this engine.

For large business applications, JavaScript is popular and has been embraced by a scalable language called TypeScript. This language is a superset of JavaScript, so you'll need to understand JavaScript well in order to write large‑scale business applications and other software using TypeScript.

You can also create native applications for smartphones and tablets using JavaScript. A popular technology for this is Apache Cordova.

JavaScript can also be used to create full‑fledged applications for the Mac and Windows desktops. There's no need for a browser at all. A popular technology to accomplish this is Electron.

Writing server‑side code can also be accomplished in JavaScript. You can create web servers, web APIs, and other services using a technology called Node.js.




Installing Development Software

We need is Node.js, specifically, we need the npm package manager, which comes bundled with it. To check use:

npm ‑‑version

If it's not installed, you can visit nodejs.org and download it here:
https://nodejs.org/en/download/


Hello World Project from GitHub

Now that we have all the tools installed, let's create our first project. Traditionally, the first thing you do when you learn a new programming language is to have it print out the words Hello World, and we'll do that with the help of GitHub. Pluralsight has a good starting point for your JavaScript applications, so let's go there. I'm at github.com/pluralsight/web‑dev‑starter. And this is a great starting point for JavaScript application development. You can see the project name here, and what I'll do is I'll click this clone or download button, and we want to clone it. So I'll hit this copy button, and that simply copies the URL that we need. So back at the command prompt, the command we need to execute is get clone and then I'll type Ctrl+V to paste in that URL that we just copied. You can see that it ends in web‑dev‑starter.git. I'll hit Enter, and we cloned the project. It put it in a folder called web‑dev‑starter. So let's cd to that directory. And if I do a dir to get a directory of all the files, you can see the files from the project. To start off Visual Studio Code right from the command prompt here, I can type code and dot for the current directory. So Visual Studio Code starts with our welcome page. I'll shut that down. And you can see the files for the project on the left here. This is called the explorer pane or explorer panel. And you can see the main file index.html right here. I'll click on that and you can see the Hello World text right here. Now, before we run this project, there's something very important we need to do in the command prompt. I'm in the web‑dev‑starter folder and I need to install the npm packages that belong to this project. So I'll type npm install. And after a few seconds, everything will be installed. And one thing to be aware of if you're on a Mac, you may need to run sudo before the command, so the command would be s‑u‑d‑o npm install. That will run the install as the super user, and that'll guarantee that you have the right permissions to install everything properly. But depending upon how your Mac is set up, you may not need sudo. If you do use it, you'll need to enter your password. So going back to Visual Studio Code, what that npm install command did was it looked at package.json, and it looked at this devDependencies item, and it saw that we needed to install the lite server, version 2.5.4, and it actually installed that. If we look in the node_modules folder, you'll find it in here if you scroll down. But all these other packages here are dependencies, but there's no need to go looking through this. As long as you see the node_modules folder here and it's populated, the install should be okay. Now to actually look at this index.html page in a browser, we need to run that lite server that we saw. So what I'm going to do is I'm going to type Ctrl+\`, and that brings up the Windows PowerShell. It will bring up a terminal in a Mac, and I'll just bump up the font a bit. Here so we can see it better, and now we have a terminal right here in our editor. Now you'll notice that I executed the npm install in that separate command prompt window, right here. And for some reason, that's a safer way to do it. If you executed npm install within this terminal, you may or may not run into certain errors. So for safety, always run npm install from a command prompt or terminal outside of Visual Studio Code. But once we're here, we can type npm run start, and that starts up lite server, and it opens up the browser for us. We get Hello World, and you can see that lite server is running on localhost port 3000. Throughout this course, what I'll mostly be doing is having the browser open next to the editor. So I'll make the browser as small as it can go, which is right here. And then I'll take the editor and just make that fit, and I'll reduce the font a little bit. And I can close the explorer by clicking on this button right here. We can always get it back again, it's like a toggle switch. And our server is running, so I'll just X out of this terminal. So there we have it, our Hello World application is working. Now one of the benefits of lite server is that all we need to do is make a change to the source code, so I'll delete World, and as soon as I save this file, the browser will automatically refresh, and we get Hello in the browser. So this is a great way to develop. When you start your session, you just kick off the server and from there on out, you just save your files to have them update in the browser. So Hello World is working, but we want to be working with a website that's a little bit more sophisticated, and in the next clip we'll set that up.
Our Sample Website

Throughout this course, we'll be using a sample website that's part of the downloadable files for this course, and it's all based upon that GitHub project that we just saw. Here's the Pluralsight page for this course, JavaScript: Getting Started, and this is most likely where you're viewing this course from. To get the exercise files, the link is right here. I'll click on it, and we can see the big blue button, Download exercise files. This downloads the ZIP file, and I'll open it right here. Looking at these folders, these correspond to the module numbers in the course. So if we're on module 5, we can go into demos. Now this after folder contains the project after the module is completed, and before is the snapshot before the module starts, so you can pick whichever one you'd like. I'll go into after, and the demo project is in this js‑demo folder. So what you want to do is extract these files into your working folder on your local device. So I'll extract these, and we'll look at these in the command prompt. So I extracted this project into this js‑demo folder. I'll execute dir so we can see what's in the directory. And most importantly, we're going to need this package.json file to show that we're in the right place, and we are. And just like we did with the Hello World application from GitHub, we need to execute npm install. That was successful. And if I do dir again, you'll notice now we have a node_modules folder. So npm install looked at package.json and downloaded all our packages for us into node_modules. Let's go to Visual Studio Code and we'll pick up this project from there. I can just type code . for the current folder. So here's the project, and if we look at index.html, you can see now that there's much more to it. The title of the site is Carved Rock Fitness. It's somewhat of a sporting goods store. And the only two differences between this and the Hello World project are this index.html page, and in the css folder there's a main.css file, which has all the styles for the site. So I'll hit Ctrl+back tick, that will pull up the terminal, and let's run this project. I'll execute npm run start, and lite‑server starts up, and you can see the website here, and it is fully responsive. If we open it up wide, we can see the header and some kind of banner and the contents of the site. But throughout this course, we want to see the code editor as we work with it, so I'll keep it small, and because it is responsive it does rearrange pretty well. We can look through the site and see all the parts lined up properly. Throughout most of this course, we'll be working with this string right here. It's not until the end of the course that we'll start modifying the web page in more detail. But to start with, we need some kind of output, so we'll use the string, Get A Grip, as output, and you'll see how we do that, but there's another way we can show output. If I right‑click and select Inspect, we can see the console. I'll click on the Console link, and in some cases we will be showing output here in the console. Now your console maybe docked to different sides of this browser window. You can click on this icon and you can dock it to the right side, to the bottom, and so on, right here. I like to keep it docked to the bottom. And when the console is showing, you still have full access to the website. Now we're all set up with this project, but it does not use JavaScript yet, and that's one of the first things we'll learn in the next module of this course. So I'll see you there where we'll start writing our first JavaScript code.
JavaScript Beginnings
Introduction

Hi. This is Mark Zamoyta, and this module is titled JavaScript Beginnings. There are several things we need to know before writing lots of JavaScript code. When we start writing, we want to make sure things go smoothly, we're able to fix problems, and we understand the basic rules of JavaScript. We'll start off this module by seeing how we can add JavaScript code to an HTML page. It's important to know the location where we add the code and the syntax of how to add the code. We'll see how we can work with multiple JavaScript files in a single HTML document. It's very common for a web page to have multiple JavaScript files, not just one. Next, we'll take a look at formatting our code, specifically how JavaScript works with whitespace. Whitespace refers to spaces and tabs and new line characters, and those are used mainly to make our code look good and easy to read. Next, we'll take a look at how we can detect and fix errors in our source code. As a new JavaScript coder, there's a lot to learn. So when errors happen, we need to be able to spot them quickly and fix them right away. Next, we'll take a look at case sensitivity in JavaScript. It is important that lowercase letters are different than uppercase letters, and we'll see how that works in JavaScript. Finally, we'll take a look at how we can comment our code. Sometimes code is tricky or complex, and we need to leave notes for whatever developers look at that code in the future. Comments are written in your plane native language, so you don't have to worry about any JavaScript errors within your comments. Let's get started and look at how we can use the script tag in HTML to include our JavaScript code.
Adding JavaScript Code to a Web Page

Our starting point for coding in JavaScript is actually an HTML page. One of the primary uses for JavaScript is to change the markup or change the document that's being shown in a browser. The usual starting page is called index.html. We won't be going into HTML in too much detail. Understanding it is a bit of a prerequisite for this course, but we need to see how we can link up JavaScript code into our index.html page or any HTML page. Here we can see a script tag. We have the starting tag and the ending tag, and between these, we can put any JavaScript code that we'd like. And this code will execute directly in the web page. Let's take a look at how this works. Here we have the index.html file that we set up in the last module. If we look at our list of files, index.html is right here, and I'll just close the Explorer so we have more space to view the code. What I'll do is I'll scroll down to the bottom, and we'll place our script tag directly above the closing body attack. So here's our closing body tag, and above it we'll add script, and we'll place the closing script tag below it. And now we can actually start writing JavaScript code. So I'll enter a simple alert command, and I'll just say, Hello World, and there's our first line of code. Now before I save this and execute it, we need to make sure that our live server is up and running. So I'll type Ctrl\`to bring up our command prompt, and I'll enter the command npm start. So our web server is running. It's on localhost: 3000, and I'll just close out our console, and I'll close out the old browser window. So now, as we save changes in our HTML file or in the JavaScript that we write,, the results will appear immediately in our web browser. So I'll save our code, and the message comes up localhost:3000 says Hello World! So this is working fine. I'll hit OK. So we just wrote our first line of JavaScript code. Now, just to understand this, alert is a function, and we'll be learning about functions later in the course. And Hello World in single quotes here, that's called a string, we'll also be learning about strings. But for now, just know that by executing this command alert, Hello World, we're going to get one of those pop‑ups with the message in it. So I'll just say this again, and there's our pop‑up saying Hello World! And let's add another line of code after Hello World. Let's print out the name of this company we're working with, Carved Rock Fitness. I'll type alert, and in single quotes, I'll say Carved Rock Fitness. I'll save it. And we get our first message, Hello World! I'll click OK, and our second message, Carved Rock Fitness. So just to recap, we can place our JavaScript code between script tags in our HTML file, but this really isn't the best place to put JavaScript code. It's better to have JavaScript code in its own file. That way we have a nice separation. Our markup HTML 5 code will be in the HTML file, and our JavaScript code can be in a .js file. And even though it might be easier at times just to use one single file for both the HTML markup and the JavaScript code, as you can see here, it's a best practice to separate them. So in the next clip, we'll see how we can take our JavaScript code and put it in its own file.
Working with JavaScript Files

We saw how to use the script tag in our HTML file, but it's very uncommon to use that for our JavaScript code. It's much more common to use a JavaScript file, and there are two reasons for this. First off, we want to separate our markup, our HTML code, from our JavaScript code. This will keep things clear in our head, and if multiple people are working on the project, it makes things simpler. And another important reason to use a JavaScript file is that we can use that file in multiple web pages. Usually, a website is many pages, and they can all share the same JavaScript files if needed. Let's see how we set this up. So we'll be working in our index.html file again, and here's how we can load a script from an external file. We use the script tag, and we use the src for source attribute. And in this example, our file is called filename.js. And for most web servers, it's very important to have this ./ at the beginning. That just tells us the directory where the JavaScript file is located. Here the dot represents the directory that the index.html file was located in, so we have a relative path and a file name. And notice that we need the end tag as well /script right here. If you're familiar with XML, you might be used to using a shortcut such as this, where we end the script tag with a slash, but this is wrong. Even though it's valid XML, it is not valid HTML. And even though this syntax will work in most modern browsers, it won't work in some older browsers. So to be safe, just make sure to use a full script tag. As we see here again, end it with /script. Let's go to Visual Studio Code and create a JavaScript file and read it into index.html. I'm in index.html, and here's the script section from our last clip. I'll modify this by eliminating our JavaScript code, and we'll add a src attribute, and I'll call it home.js. And we'll be sure to create home.js in the same folder as index.html. I'll select New File, home.js, and let's just put some code in here to make sure it's working. I'll alert Hello World! Now I want to make sure to save both these files, so I'll save JavaScript, and I'll save index.html. And I'll make sure to refresh here, and we get our message Hello World! So now we can isolate all our JavaScript code to home.js. We simply need to modify this file to make changes to JavaScript, and we can leave index.html alone. I'll add another alert. I'll just say Second Message, and I'll save this, and we get the message Hello World! and Second Message. Now I just want to take a look back at the index.html page because there's something there worth seeing. If we scroll up to the top, and I'll just expand out this page, we can see several script tags here where we're setting the src attribute to JavaScript files. And just to look at the first one, you can see that we're using jQuery, so things like jQuery and Bootstrap and libraries that span the entire project that don't rely on the web page can be placed up here in the head section. But we're not going to be doing that in this course because the JavaScript that we write needs to be able to modify the web page. So it actually wouldn't work if we placed our script tag here. We want to make sure to place our script tag at the very end, after all the HTML is loaded, and that's what we're doing, so that's fine. Now one thing I want to do is, I want to add a second JavaScript file. Normally, when you create a web page, it'll have many JavaScript files. So let's go ahead and create a utility script file. I'll just call it utils.js. I'll see this and I'll go ahead and create that file, utils.js. And utils is just a common abbreviation for utilities. That would be code that you use throughout your web page or your entire website. But I want to create a function here. We're not going to cover functions now, but we just need a way to be able to slightly modify our web page, and we'll be covering that later in the course, so for now I'll just enter some code, and we'll discuss it later. So the only important thing to know for now is that we created something called showMessage, and we want to use that to show a message on the website. In order to do that, first, let's take a look at the web page, and we can see this message here, GET A GRIP. Let's use that temporarily just to show some output from our JavaScript code. We can find that in our HTML markup by just searching for GET A GRIP. I'll hit Ctrl+F to find, and I'll search for GET A GRIP right here. And in order to work with this, we simply need to give it an id called message. So now that function that I just created will be able to modify these characters right here, GET A GRIP. And again, we'll be covering functions and how to manipulate a web page later in this course. But for now, let's just go to home.js, and instead of these alerts, we'll call showMessage, and we'll just type the characters Changes..., to show how we can change a web page. So I'll save this, and we have to save utils. You can tell by the circle right here it needs to be saved. I can go to File, Save All, and I'll refresh the page. And we can see that it says Changes... And just to show that it is working, I'll change it to something else. I'll change it to Title and save it. And as soon as I save it, Browsersync kicks in and we see the title showing up right here. So this'll make things a lot easier to work with than having to click OK on all those pop‑ups that are showing up. Whenever we want to show something as we're learning JavaScript, we just need to write showMessage and pass whatever information we want to show. So we're all set up to learn JavaScript. But before we start diving too far into the language, there are a few basic things we need to know about spacing and formatting and case sensitivity, and we'll cover those next
Formatting Code

Let's take a look at how JavaScript allows us to format our code. I'll show you what I mean by this. So looking at our home.js file, we have a single line of code. But what does JavaScript do about whitespace? Whitespace are things like spaces or tabs or even new lines, so I will hit Enter a few times and I'll change the text here to changed, and I'll save it and we'll see what JavaScript does. So our code still worked fine, even though we have all this whitespace before our actual code. We can also add whitespace between symbols usually. We have showMessage, and I'll add some spaces and tabs in there. I'll save it, and our code still works fine. Even if we broke this apart and put changed on its own line and pushed down the closing parenthesis a bit, I'll save this, and again, that also works fine. Now just because you can do this doesn't mean you should. There's some cases where whitespace can help the developer understand the code better, but in code like this, I'll just hit Ctrl+Z to back up, we generally don't want to start a line with whitespace, and we generally don't want to put whitespace between symbols unless we need to, or unless it really helps clarify the code. Now before parentheses, some developers like to put a space in there, and that's fine as long as you stay consistent with how you code, or you follow the guidelines of the group you're in. But for me, I like leaving that space out and having it run together like this. Later in the course we'll see how indentation and indenting lines of code can really help clarify what the code is doing. And if we had more than one line of code, which is going to be the case usually, I'll just copy this one, and I'll just say Title2. You want your code to line up on the left side, and adding space is possible, but only add empty lines if it helps clarify the code. You want to make sure that if you have to revisit this code yourself, or if another developer needs to look at it, that they can clearly understand what's going on, and sometimes blank lines help with that. So I'll save this and we get our Title2 showing up right here. In the next clip, we'll take a look at errors and how we can tell if there's an error in our code.
Detecting and Fixing Errors

It's very common when you're learning the program to run across errors. As a coder, you need to be perfect. If JavaScript doesn't know what you're attempting to accomplish, it will throw an error, and let's see how we can detect these errors and fix them. Here is our code from the last clip and let's create an error. We have showMessage Title2 right here, and I'm just going to chop this word in half. You can't do that in JavaScript, so there will be an error. I'll save this, and looking at the page, we can see that our title shows right here, but it doesn't say Title2, it just shows title. So this first line of code ran perfectly, but the second line of code, which we cut in half, didn't run at all and there is an error that we can't see. The way to detect this is to use the Browser tools, and I'm using Chrome, but pretty much any browser has similar tools. I'll right‑click and go to Inspect, it pulls up Developer tools, and this might look a little bit complex, but let's simplify it. First of all, we'll click on Console and this is the console where Javascript will show all our errors, and we can see here that the error is Uncaught ReferenceError showMes is not defined. So anything red with this red X right here is an error, and if we look closely at this home.js:3, that means it's in the home.js file, which is the file we're working with and line three. So that helps us pinpoint exactly where the problem is. To fix it, I'll just go back and patch it back together. I'll type Ctrl+S to save it, and we see it's working now. Title2 is showing, and our console is empty, so I'll create another error just so we can see it. I'll enter some random symbols and that'll cause an error. I'll save it and we can see the error right here, Uncaught, SyntaxError Unexpected token, and it's the caret, so it just doesn't know what the caret symbol is. And to clean it up, I'll just remove that, hit Save, Ctrl+S, and everything's good again. Now, sometimes it's useful to use the console for debugging purposes on your own. Let me go ahead and remove the second showMessage, we don't need that, and I can type console.log, and again, this is an object with a function call, which we'll be covering later in the course, but for now, just know that you can use console.log in the parentheses to write out any message you want. I'll hit Save, and you can see that any message shows up in our console. It's not an error, it's not red, but this could be very useful as you're programming. You may need to look at certain information, and it might be hard to show it on the web page itself, but you can use the console. For the most part in this course, we're going to be modifying the web page so we won't be writing out to the console, unless we need to. So it's a good idea throughout this course and as you are experimenting and playing around with code, to keep the console open. If something doesn't work the way you expect it to, take a look for an error in the console. In the next clip, we'll take a look at case sensitivity.
Case Sensitivity

Case sensitivity in JavaScript refers to whether or not the case of names is important or not. For example, is a lowercase a the same as an uppercase A? In some languages it is, but in Javascript it's not, and this is the source of a lot of bugs. Let's see how JavaScript deals with this. Here's our code from the last clip, and we know that showMessage will change the title right here. But what if we typed showMessage with a capital S? I'll save this, and our browser paused it, so I'll hit the Continue button, and I'll go to the console, and we can see that we do have an error message, Uncaught ReferenceError: ShowMessage (with a capital S) is not defined. And it tells us that it's in home.js line 1, and we can also see that, it's right, the code didn't work. It still says, Get a Grip. It doesn't say Title. So, again, changing that back to a lowercase s, I'll save it and everything works fine. And you may have noticed this capital M for Message in the middle of showMessage, and that's very common in JavaScript. If you're using a symbol that's made up of multiple words, generally, the first word is lowercase, show, and all of the other words are capitalized as in Message. If we make that a lowercase m and save it, we once again get the error. I'll resume it and show the console and showmessage, all lowercase, is not defined. It's an error. So I'll undo this and save it just to make sure we're good. And it's always important to understand that JavaScript is case sensitive. You can't mix up lowercase and uppercase letters at all. Everything has to be precise. In the next clip, we'll take a look at adding comments to our code.
Commenting Code

When we're coding, some of our source code may become tricky or complex. Or maybe there's just something about it that other developers won't understand. So we need to be able to comment our code. We need to be able to write normal phrases in English or whatever our speaking languages so that developers in the future will be able to understand what's going on. And you also want to leave comments for yourself. Very often, you'll write some code and you won't visit it again for weeks, months, or years. So you want to remember what your code is doing. Let's see how we can comment our code. Here we see a single line comment. It begins with two forward slashes. And because of the whitespace rules that we saw earlier, this can appear anywhere. It could be at the end of another line of code. It can be in its own line. It could be indented. Just know that as soon as JavaScript sees a //, everything for the rest of that line is a comment, and you can write anything you'd like there. It won't be an error. If you want more than a one‑line comment, there are special symbols to create multi‑line comments. At the beginning, you enter /*, and at the end, the symbol is */. But anything between these two symbols is treated as a comment. It won't generate an error, and you can write anything you'd like. Let's see this in action. Here's our code from the last clip, and normally you wouldn't give a comment to this line because it's pretty obvious what it does. But if you did have a more complex line and you wanted to add a comment, you enter two forward slashes and whatever you'd like to write. And I'll save this, and we can see that we get no errors in our console. For multi‑line comments, we can enter /* and */. They don't have to be on separate lines. They can be on the same line. Just whatever is between these two symbols is a comment. It won't generate an error. So you can detail complex logic or some algorithm or write up whatever you'd like. A very common use for multi‑line comments is your source code license. You'll see license information usually within comments at the top of a source code file, and most organizations do have a policy on adding copyright information. That all goes into comments. So I'll save this just to make sure it still works, and our console is clear. There are no errors. Let's wrap this module up with summary.
Summary

We started off this module by seeing how we can include our JavaScript within HTML files. We saw how we could use the script and script tag, and we could place any JavaScript code between these tags. That's not very common. It's more common to use a script tag with the source attributes set to a JavaScript file name. That way we can reuse that file in multiple web pages, and it also keeps a good separation of concerns. Our HTML content stays in an HTML file, and our JavaScript code stays in its own file. We saw how we could format code using whitespace, and we could freely use whitespace. We could add it to the beginning or end of lines or between symbols. But as a best practice, we want to line things up on the left side margin, and we'll see more of that throughout this course, as we start writing more code. We saw how to detect errors in the browsers console. You usually can press F12 to pull up the developer tools or right‑click and select inspect. And you want to look at the console, that's where any error messages will show up in the browser. And we took a look at case sensitivity. JavaScript is case sensitive. You always need to be careful that you're using lowercase or uppercase characters properly. And finally, we looked at commenting our code. Any kind of complexity or anything tricky or anything that could be confusing should be commented in your code. We can add single line comments by using a forward slash twice, slash slash, or we could have multiple line comments by specifying forward slash star and any characters, including new line characters, up until a closing star slash. This comment is on one line, but usually the slash star on the star slash are on separate lines with a lot of information in between. It could be a software license, a copyright notice, an explanation of a complex algorithm, or anything. So those are the very basics of writing JavaScript code. In the next module, we'll take a look at variables. Variables are symbols that you use all the time in JavaScript, and we'll go into them in detail.
Variables and Constants
Introduction

This module is titled Variables and Constants. My name is Mark Zamoyta. Single pieces of information in JavaScript get stored in variables and constants, so these are very important and are used throughout most of our code. In this module, we'll go over these in detail. We'll start off by defining what a variable is and how it works. We'll see how to declare variables so we can use them in our code. We want to give our variables descriptive names, and there are certain rules we need to follow when naming our variables. And there are certain errors that are very common when using variables. We'll see how to detect these and correct them. And the reason why a variable is called a variable is because the value changes, or varies, over time. We'll see how this takes place in JavaScript, and then we'll look at constants, which are cousins to variables. They seem similar, but they can only have one value that never changes. And finally, we'll look at the var keyword. It's not a best practice to use the var keyword anymore in JavaScript since there are better keywords that we'll be learning about to declare variables and constants. But you'll still run into this in legacy code on Stack Overflow and blog entries, so it's important to know how var works. So let's start off by looking at what a variable really is.
What Is a Variable?

Any application that we write is going to be based on data. If we're selling products, we need data on the product name, the price, and all the data that belongs to an invoice or a purchase order. If you're writing an app that works within a car, you might need access to data such as the speed of the vehicle, the engine size, or just anything about that vehicle. Likewise with a game, you might need data such as the high score or the images used for a player's animation. And in JavaScript and most other programming languages, we use variables to hold this information. Data is stored in the computer memory. Let's take a look at an example here. Let's say we have a sales ticket, and the total amount of that sales ticket is $149.99. That needs to be stored somewhere in the computer's memory. And typically, a memory address is a long, complicated number. It would be very difficult if we had to use this long number to reference that value. So instead we use a variable. In this case, we can use a variable called total. So in this case were using an English word to represent the number in the computer, and you can use words and characters from your own native language. It's up to us to come up with the variable names. Likewise, if we had a product that we need to store, such as hiking boots, that would be stored in computer memory. And again, it would have a memory address, which would be very difficult to work with. So instead, we come up with a variable called product. And one more example, let's say we had a value called true, and we have no idea what that refers to. We know it has a memory location, but if we give it a good variable name, we'll know exactly what true means. Here the variable name is discounted. So if the value of discounted is true, we know there's some kind of discount going on for a product. If the value is false, there would not be a discount. So in this example, we have three variables, total, product, and discounted. And it's up to us to come up with the variable names. There's a special terminology we use in programming when you create a variable. It's called declaring the variable. And in the next clip, we'll see how we declare variables in JavaScript.
Declaring Variables

We need to let JavaScript know what variables we're going to be working with, and the terminology we use for that is declaring variables. Let's see how we do that. When we declare a variable, we use a keyword, let. A keyword is a special symbol that JavaScript knows about. It performs some type of action. In this case, let allows us to declare a variable, and after the keyword let, we have the variable name that we want to use. And there are certain rules for creating variable names, and we'll cover those shortly, but for now, just know that you can use any word for your native language. After the new variable name, in this case total, we have an equal sign, followed by, in this case, the number 149.99. What this equal sign does is it takes the value and assigns it to the variable, total. So you would say the variable total now has the value 149.99, and it's a best practice to always end the line of code with a semicolon, so we do that here. Let's see another example. We use the keyword let, and we're creating a new variable name called product, and we're assigning product Hiking Boots. Now you'll notice that Hiking Boots are in single quotation marks. This is called a string. Our computers and devices have no idea what Hiking Boots are, so by putting them in quotes, we can just treat that text as literal text. We can put any words we'd like between quotes. And you'll notice that computers do understand numbers, so we don't use quotes when we're working with numbers, as in 149 and 99 cents. So again for this line, we're creating a new variable, product, and assigning it the value Hiking Boots. In this third example, we're using let to create a variable named discounted, and we're using the equal sign to assign the value true to discounted. Now you'll notice true is not in quotes. The values true and false are called Boolean values, and they're used so often that JavaScript knows about them, we don't need quotes around true or false. So we're creating these three variables. Total will be set to 149.99, product will be set to Hiking Boots, and discounted will be set to true. Looking at our diagram again, we have our variables showing on the left, and JavaScript knows all about these now. JavaScript keeps track of the memory locations and can pull up their values. In the next clip, we'll pull up Visual Studio, and we'll start creating our own variables.
Using let to Declare Variables

Let's go into Visual Studio, and we'll use the let keyword to declare our first variables. Here's our project from the last module. I'll go into Visual Studio Code and hit Ctrl+backtick, and let's make sure our web server is running. I'll type npm start. And there we have it in the browser. So to create our first variable, let me close down the explorer so we have some room, and we used the let keyword, and let's create a variable called welcome. And we want to assign a value to welcome. Let's assign it the string Welcome. And again, we're using text, so we need to put it in quotes. This is called a string, and we'll learn all about strings in the next module. But for now, just know that we can use single quotes or double quotes as you see here in the title when we're working with strings. Now to show a message, let's say we wanted to show the message that's held in the variable welcome. We can just enter the variable name. So here in line 2, we're creating our variable welcome and assigning it the string Welcome with a capital W, and then we call showMessage with that variable name. I'll save this, and let's see what happens. We get our Welcome message in the web page. If we change the welcome to Hello World, I'll save it, and now that shows up in the web page. So simply by changing this string that we're assigning to welcome, we can have our program behave differently. This line of code stays the same. What's important is the value that's stored inside the variable. And let's change this variable. Instead of welcome, we'll say price, and we'll enter a number for the price, 49.99, and we'll show the message price. I'll save it, and we get the value 49.99 showing. Usually your programs will have many variables. Let's say we have a price, and we also have a variable called name for like a product name. And let's say we also had a variable called discounted, and that'll be true or false whether the item is discounted. I'll just say false for now. And we can go ahead and use these three variables, price, name, and discounted throughout our code. I'll just show the message discounted. I'll save it, and we get false, which is the correct value. There's a shorthand that you're usually going to see when we're declaring multiple variables like this. We can actually leave out the second and third let and put commas between the different variables and their assignments. So we'll say let price = 49.99, name = Hiking Boots, and discounted = false. That's our last variable, so we'll put a semicolon on the end. And this works just as well. I'll save it, and we get false for discounted if we want to show the message name. I'll save it, and we get Hiking Boots. So it's not required to use commas when you're declaring multiple variables, but it's very common, and it is a best practice. Usually, you'll see the variable names lined up like this so that it's easier to read. Remember, you can freely use whitespace between symbols and before and after variable names. So declaring variables is easy, but there are some errors that can come up. And usually those errors have to do with the names that you pick for variables. So in the next clip, we'll take a look at the rules for naming variables.
Naming Variables

Let's take a look at the names that we can use for variables. We can pretty much use any word as long as it's not a keyword. such as let. Let is used to declare variables. So if we try to create a variable named let, that would be very confusing, and JavaScript will give us an error. But let's take a look at the rules. So for valid variable names, a variable needs to start with one of these characters, underscore, dollar side, or a letter, and by letter, we mean lowercase a to z or uppercase A to Z or any unit code letter. So that covers most languages. So after we have our first character in the variable name, it can be followed by a zero or more of these characters, underscores, dollar signs, letters, or numbers. So the big difference here is that you cannot start a variable name with a number. Any numbers have to be in position 2 or beyond. And the reason for that is that if you started a variable name with a number, the JavaScript engine would be confused. It wouldn't know if you're trying to create a number or a variable name. Let's see some examples. The letter a is a valid variable because it starts with a letter, and that's the only character. But the problem with this isn't technical with JavaScript, but it's a problem with your source code and the ability to understand your source code. If you use a variable a, people won't have an idea what you're really talking about. But if you use a variable name such as account, that's much more descriptive, and it's a much better variable name than a. We could also create a variable called account_99. That's fine. Just as long as it doesn't begin with a number, we can use numbers. And in this case, we have a variable called accountNumber. You'll notice that the word account is lowercase, but the word number is uppercase. This is called camel notation because there seems to be a bump in the middle of the word like a camel. And it's very common to use camel case when we're working with JavaScript variables. AccountNumber is a great variable name. It completely describes what we're working with. But to make it easier to read, we use this camel notation. You'll also see variables that begin with an underscore. That's valid, so _accountNumber. Usually the underscore denotes that this variable is going to be private in some way, and you'll learn more about that in a more advanced course on JavaScript objects. But it is a valid variable name to start it with an underscore. Likewise, you can start a variable name with a dollar sign. Generally, dollar signs are used for automatically generated code, which is an advanced subject. But for the most part, dollar signs are discouraged in variable names. And you could even have a variable name such as _123 And that's very non‑descriptive, so it's probably not a good choice for a name. You'll also see variables that look like this. They have two underscores at the beginning, at the end, and some word in the middle. And you'll run into these, but these are usually reserved for nonstandard features. So while all these variable names are valid, the best ones are account, accountNumber, and just any name that really describes the data that is being held by that variable. If there's a problem with a variable name, JavaScript will usually let you know. And we'll take a look at that in the next clip where we'll look at errors with variables.
Common Errors Using Variables

Let's look at some of the common errors that we might run into when using variables. All of these errors can be avoided by understanding the rules and also by following best practices. Here's our code from the last time we were in Visual Studio Code, and let's just work with an illegal variable name. Now we know variables cannot begin with a number. So let's try to create a variable called 99times, and we'll set that equal to 99, and we'll showMessage 99times. Now you can already tell in the editor that we're going to have an error. Thes red squiggly lines show us that there's some problem with the source code, but I'll go ahead and save it and we'll see what happens anyway. I'll save it. I'll pull up the inspector by right‑clicking and choosing Inspect. We'll go to the console, and you can see the error that we get, Uncaught SyntaxError: Invalid or unexpected token. By token, they mean a symbol. In this case, the symbol is 99times. So variable names cannot begin with a number. We can simply fix this by renaming it. Let's call it times 99, and we'll change it in the showMessage call as well. I'll save it, and 99 shows up in our browser, and the error goes away. Again, it's fair if we used an underscore. That's a valid way to start a variable name. I'll save this, and that shows the same result. But we can't have spaces in variable names. If I put a space here, again we'll get the squiggly lines, and we're sure to get an error. I'll save it, and we get a SyntaxError: Unexpected number. So variable names cannot have spaces. Likewise, variable names cannot be keywords. The main keyword we've looked at so far is let. So let's try to create a variable called let and see what happens. I'll save it, and we get an UncaughtSyntax error. Let is disallowed as a lexically bound name. Now that sounds like a complex message, but basically what it's saying is that let is used by JavaScript as a keyword, and we can't use it for a variable name. One other problem we sometimes have with variables, I'll create one called price here, is not initializing the variable. So it is valid to create a line like this, let price without assigning it a value. Let's see what happens. I'll save this. And when we look at the message we get, you can see there is no message. It doesn't show anything. And let's also write this to the console. Earlier, we saw how we can write console.log, and I'll enter the variable name here, price. I'll save this, and if we look in the console, we get the word undefined. So an error isn't being generated. But most likely, this is an error in our code. We have to set price to something. So this is more of a best practice. Whenever you declare a variable, also set its value. I'll save this and everything should work fine. We're good. So those were some of the common errors you run into. Make sure to leave your console open so you can see these errors as they pop up. Now I haven't really explained why we use the word variable to describe variables, and the reason why is because they change over time. The value of a variable can vary. It can change. And we'll take a look at that in the next clip.
Changing Variable Values

Let's take a look at changing variable values. A variable changes over time. If you're talking about the speed of a car, it's going to change often. If you're talking about a score in a game, that's going to change often as well. So let's see how we accomplish this in JavaScript code. So let's go ahead and work with price. We're sitting price to 99.99. I'll save it, and we can see that that works fine. But over time, price might change, and we can simply set price to a new value by writing a statement. We'll enter the variable name equals 49.99. So this line of code is how we can assign a new value to a variable. We use the equal sign, and we take the new value 49.99 and place it into price, the variable. So when I save this, even though we initially set price to 99.99, we reset it to 49.99, and that's what shows up in the browser. Sometimes you might not know the value of price at the start of your code. In that case, it's fine to leave out any assignment. Or you could set price equal to 0 or some other value. But let's just leave it out for now. You just need to make sure that between the place where we declare price and down here on line 6, where we use price, we need to set that variable between those two places, and we're doing that. So if I set this to 59.99 and save it, everything works fine. And of course, there might be some code in here to like somehow calculate the price or grab it off the internet or do some kind of processing. And there might be more code here and maybe even the value of price changes again. Let's make it 29.99. So the value can change multiple times while the code is running. I'll save this, and you'll see that we get the final value that price was set to, 29.99. So that wraps up the fundamentals of variables. Now there's a cousin to a variable called a constant, and a constant does not change. We'll take a look at that in the next clip.
Constants

We just saw how variables can change all the time. But sometimes we want a variable to only be set once and not change it all. In that case, we use a constant. The big benefit of a constant is that it gives a clue to developers, especially developers looking at your code in the future, that's something is not supposed to change. Let's take a look at this in Visual Studio Code. Here's our code from earlier. We were not setting price at all at the beginning, then we set it to 59.99, and then we set it to 29.99. Let's say we wanted to only set the value of price once. Instead of let, you would use the keyword c‑o‑n‑s‑t for a constant. And when you declare a constant like this, constant price, again a constant has t he same variable rules as variables, we'll set a constant price equal to let's just say $40. And I'll comment out this other code for now where we're changing price. So we're taking the value 40 and assigning it to the constant price. Then we're showing a message with the price in it. I'll say this, and our 40 shows up, but this is a constant. So if a developer tried to change it as I'll do right here, I'll uncomment this line, and we should get an error. We have a constant price, but we're changing its value. So I'll save this, Ctrl+S, and I'll go to the console. And you'll notice that this gets paused in the debugger, so I'll just hit this blue button to resume. And we get our error, Uncaught TypeError: Assignment to constant variable at home.js line number 6. So you can see that this does generate an error. If you're curious about what a type error is, type refers to the type of information we're dealing with, and we'll see all about that in the next module of this course. But for now, just know that we're assigning a value to a constant twice, which is illegal. Likewise, I'll take out all this code here now. And what if we don't set any value to the constant? We'll just say const price. I'll save this, and we get a different error message. Uncaught SyntaxError: Missing initializer in const declaration. So when we declare a constant, we need to set it to a value. I'll save this, and everything works fine. So you have a choice to make. When you need a variable, you need to determine whether or not that variable is ever going to change. If it's not going to change, use a constant, and you declare that as you see here with the c‑o‑n‑s‑t keyword. But if the variable is going to change, you need to declare it with let. If you're in doubt, you can always declare things as a constant and then change it back to let later if needed. And that is a best practice. If a variable is not going to change, it should be declared as a constant as a best practice. Now these keywords let and const are relatively new to the JavaScript language. We used to declare variables with a keyword called var, and var has some problems. And it's a best practice to use let and const instead of var. But we'll take a look at that in the next clip.
The var Keyword

We saw how we should be using the let and const keywords to declare variables and constants. However, those are relatively new keywords, and there's still a lot of code out there that uses the var keyword to declare a variable. If you look on Stack Overflow or logs on the internet, as well as some older code, you'll run across this var keyword often. So let's take a look at it. So the old way to declare variables is with var, v‑a‑r. So we're setting price to the value 20 by using the var keyword, and then we'll showMessage price. Actually, let's change this to 25. I'll save it, and we can see it update in the browser. So it appears that this works similarly to let. But let's see one of the main differences between var and let. The correct way to declare a variable is with let. And if we try to show the message price before we declare the variable, I'll save this, I'll go to the console and resume the script, and we get Uncaught ReferenceError: Cannot access price before initialization, and that makes sense. Our code executes from top to bottom. So when we showMessage price, JavaScript has no idea what price is. It can't predict the future, and that's a good error message that helps us. But if we use the var keyword instead of price, I'll save this, and we'll take a look at it, and you can see that we do not get an error. The price isn't showing above the 20% off as it usually does. But looking in the console, there is no error. And this is one of the big problems with using var as a keyword. You don't get errors that you expect. Not only that, but if we try to log out price, I'll enter console.log price, I'll save this. And when we look in the console, we get a message, undefined, and that's kind of confusing. Price shouldn't really exist until it gets declared. So as a best practice, always used the let keyword. That way if there's a problem with your code, it'll show up as an error. I'll go to the console and resume, and we get the error that we expect. Of course, the way to fix the error is to use the variable price after we set it. I'll save it and everything works fine. So that wraps up this module. In the next clip, we'll summarize what we covered.
Summary

We started off this module by defining what a variable is. Instead of using complex memory locations, we can use symbols which are words in our native language. This makes programming much easier. We saw how we could declare new variables by using the let keyword. And we saw that there are some rules for naming variables, specifically, they must begin with an underscore, a dollar sign or a letter, that could be the typical uppercase and lowercase English letters, A to Z, or any Unicode letter. And then that first symbol is followed by zero or more underscores, dollar signs, letters or numbers. Just remember, a variable name cannot begin with the number. Next, we looked at some of the common errors that occur when we're using variables. We saw how they appear in the console and how to fix them. Next we saw how variables change over time as our code executes. But there are some symbols that we don't want to change over time, and these are called constants. They're declared with c‑o‑n‑s‑t, const keyword instead of let. And finally, we looked at the var keyword. We saw how there are some problems associated with this, and we shouldn't really use it. We should use let or const to declare variables and constants. You'll still see var used in source code, whether it's on Stack Overflow, a blog, or somewhere else on the internet, because most of JavaScript's life, var was the only way to declare variables. But now we have let and const, and it's the best practice to use them. So that wraps up our introduction to variables and constants. The next thing we need to learn about is types. Every variable or constant has a type associated with it. It can be a number, a string, a Boolean value, as we've seen, Boolean values, again, are true and false, and we'll learn all about JavaScript types in the next module.
Types and Operators
Introduction

Hi, my name is Mark Zamoyta, and welcome to this module, types and operators. We've learned all about variables, and each variable actually has a type, and we've seen a bit of this. We've seen number types, and string types. In this module, we'll be looking at more of these types, and we'll also be looking at operators. Operators are symbols that add functionality. I'm sure you're familiar with the addition operator, where we can add numbers together, or the minus sign for subtraction. And we'll be looking at how to do all this kind of arithmetic with operators in JavaScript. Let's see what will be covering exactly. We'll start off by looking at numbers and all the operators associated with those. Next, we'll look at strings there several different ways to use strings. Strings are basically text, and they're created by using quotes. Whether it's single quotes, double quotes or back ticks. We'll see how to work with these. And it's very common to have to convert between these types. Sometimes we'll have a number, and we want to treat it as a string. Or sometimes we'll have a string, which could be something entered by a user or something downloaded off the internet, and we'll want to convert that into numbers. So we'll see how to do this. Next, we'll take a look at Booleans. A Boolean type has a value of true or false, and we'll see how to work with these. Next, there are two types that are very common in JavaScript, they are null and undefined. We'll see how to work with these values and what the main difference is. Finally, we'll wrap up this module by looking at objects and symbols. We have a whole module coming up that's all about objects, But an object is a valid data type in JavaScript, so we'll briefly have an introduction to objects. And symbols are more advanced, but we'll discuss those later in the course. So let's get started and look at how we can work with numbers and operators on numbers in JavaScript.
Numbers

One of the most common types of data you'll work with in JavaScript is numbers. Let's go straight to Visual Studio Code and start working with them. I'm in home.js, and let's create a simple number variable. And we've seen this before, and it's very simple. We simply enter the number. We don't need quotes. Let's just make it 20.99. And I'll show this price, I'll save it, and we see 20.99 showing up in the browser. There's a special operator called typeof. An operator is a symbol that operates or changes some value. So when I say typeof price, that's going to tell us the actual data type of price, which is a number. Let's save this and see what we get. We get the string number, so typeof is a very valuable operator. If we put 20.99 in quotes, now price should be a string. I'll save it, and the word string shows up. So we'll be covering strings in a future clip, but for now, let's just focus on numbers, so I'll get rid of the quotes. So once we have a number stored in a variable, we can perform normal mathematic operations on it. One way we can do this, I'll set price = price + 1. And what this line of code does is, it looks up price, and it adds 1 to it and it stores the result back into the price variable. And we don't want to show the message typeof price; we just want to show the message price now. I'll save this, and you can see that we get 21.99. So the plus symbol does simple addition. Likewise, we could do subtraction. I'll enter the minus symbol and save it. We get 19.99. Again, we take price, which is 20.99 and subtract 1 from it and store that result back in price. Let's set the price to 12. And another operator is the star operator, which is for multiplication. So if we say price = price, *, or times 3, I'll save it, and we get 36; 12 times 3 is 36. There's also a division operator, which is a forward slash. The normal division sign doesn't show up on most keyboards, so that's why we use the forward slash for division. I'll save this, and we get 4; 12 divided by 3 is 4. And there's also a special operator to get the remainder. It's the percent symbol. This is sometimes called the modulus operator, but mainly what it does is get a remainder, so price % 5. I'll save it. We get 2, and that's just the remainder of 12 divided by 5. Now these operators all have shortcuts. It's very common to have lines like this. Price = price, operator, and a value. So let's go back to addition again, and we can say price += 5, and that'll give us the same result as saying price = price + 5. It takes price, adds 5 to it, and stores it back in the price variable. I'll save this, and you can see we get 17. Likewise, we have a ‑= symbol. That'll subtract 5 from price and store it back in price. We get 7. And multiplication, price *= 5. That'll multiply price by 5. We get 60. And likewise, you can do /= equals and %=. I'll do price /= 5. We get 2.4, so that's 12 divided by 5 is 2.4. And %=, I'll save it, and we get 2 as the remainder of price divided by 5. So you have to remember that the equals sign is more of an assignment operator. It assigns a new value to whatever's on the left side of it. In this case, it's the variable price. And of course, we can work with multiple variables. Let's add another one. We'll call it taxRate, and we'll set that to 0.07. And we don't need to store that in a variable. We can just go ahead and show that directly. Let's showMessage(price * taxRate). I'll save it, and you can see that we get a very long decimal number, but mainly we're interested in the 0.84, so that would be the amount of tax to pay. Let's go back to working just with price again. And there's another special operator, which is the increment operator. The symbol is ++, 2 addition signs, and what this does is, it adds 1 to the number. So I'll save this, and you can see it shows the number 13. One of the tricky things about this, though, is that the operator can go after the variable, and this is a common bug in JavaScript. Let me just save this and let's see what we get. Price is still set to 12 when we call showMessage. When we put the increment operator after the variable, it waits until that line of code is executed and then it increments the variable. So if we do a console.log(price), let's take a look at what price really is by the time this code finishes executing. I'll go to the console, and I'll save the code. And we can see that showMessage price is 12, but it logs out 13. So it's very important to keep track of where you put your increment operator, whether it's before the variable name or after it. This is the source of many bugs. Likewise, there's a decrement operator ‑‑, which subtracts 1 from a variable. I'll save it. So we still get 12 in the website, but our console now logs out 11. So price is decremented by 1. If we wanted to decrement price first, we would just put the ‑‑ symbol in front of price. I'll save it, and now we get 11, both in the website and the console. So those are simple examples of mathematical operations using numbers. However, there are some things that can go wrong, and we'll take a look at those in the next clip.
Operator Precedence

There are certain things you need to be very careful of when working with numbers. If you're not aware of these, bugs can creep into your code. One important feature to know about is operator precedence. Let's see what this is about. So I'll clean up this code a bit from the last clip, and we're simply showing a price of 12. I'll save it, and that's what we get. Let's set price to something different. Let's set it to 3 + 2 * 2. What do you think's going to show? Well, 3 + 2 is 5 * 2 is 10. I'll save it, but we don't get 10 we get 7, and the reason why has to do with the precedence of operators. If you remember from math class, multiplication and division always come before addition and subtraction. So this multiplication right here will come first; 2 * 2 is 4, and then the addition will occur; 3 + 4 is 7, and that's our result. So always be careful when looking at code or writing your code to know which operations take place first. I'm at Google and I searched for mdn operator precedence. MDN is the Mozilla Developer Network, and that's a great source of information on anything related to JavaScript. We'll be using it a lot in this course and one of the key charts at the site is the operator precedence chart. That's what tells us that multiplication and division come before addition and subtraction, and there are a lot of their operators we'll be working with in this course so let's take a look at this chart. Here's the web page and I'll scroll down a bit, and here's the table. I'll scroll down until we find something that we're familiar with. So here we have multiplication, division, and remainder. That's the percent symbol we looked at. Sometimes it's referred to as a modulus operator, and that's at level 15, and we see addition and subtraction right here at level 14. So the higher an operation is on this chart, the higher the precedence. So this shows you that multiplication. division, and the remainder operation all take place before addition and subtraction. Not only that, but these are evaluated from left to right. Going back to the code, the way we can get around this is by using parentheses. If we want to bypass those rules. We use parentheses and anything in parentheses will execute first, I'll save this, and now we have 3 + 2 is 5 * 2 is 10, and that's our result. And we can even see these parentheses in the table we just looked at. I'll scroll up and precedence 21 is grouping, and it shows the parentheses right here. So grouping with parentheses takes precedence over everything else in JavaScript. In the next clip we'll take a look at another common source of bugs concerning numbers in JavaScript.
Number Precision

JavaScript works with floating point numbers, so we can have large numbers with many decimal places, but they're not always precise. This could lead to some problems in JavaScript. Let's look. So what I'll do is I'll set price to 1.1 plus 1.3. I'll save it, and we can see the number here 2.4 with lots of zeros. But let's shrink this down so that we can see the whole thing. I'll pull up index.html, and I'll search for get a grip. And instead of an H1 tag, let's change it to an H3 tag so that it's a little bit smaller and we can see the whole thing. I'll save it. And we can see the number here, it's 2.4, a bunch of zeros with a 4 on the very end. So this is a little bit inaccurate. We know that 1.1 plus 1.3 should be exactly 2.4. And it's always important to keep this in mind because later on in the course, we're going to be comparing numbers, and this number that we see here is not equal to 2.4. It's a tiny bit more, so I'm mentioning it here now, but we'll see this later in the course when we start comparing numbers and variables. In the next clip, we'll take a look at negative numbers.
Negative Numbers

Of course, we can work with negative numbers in JavaScript as well. Let's take a look at how we do this. So we're setting a variable amount to 20 and showing it, and to make a negative number, we simply add a minus sign in front of the number. I'll save this, and we get ‑20, but it gets a little tricky when we subtract negative numbers. But if we wanted to say 20 minus ‑2, well, we get the red squiggly line under the 2 because we're actually using the decrement operator minus minus. You need to have a space in there, so I'll save this. And we get the correct answer, it's 22. However, this code looks very confusing. It's not really clear that we're working with the number ‑2. The expression looks more like a typo. So to be very clear that we're working with a negative number in the middle of an expression like this, we usually put it in parentheses, and that just makes the intention of the coder very clear, that we're working with the number 20 minus ‑2. And by saving it, of course, we'll get the same answer, 22. And the decrement operator will also give us negative numbers. Let's say we set the amount to 0 and we want to show message minus minus amount. I'll save it, and we get ‑1. So negative values work much like they do in math class. You just want to make sure to use parentheses to make your intention clear when working with negative numbers. So that's all we're going to do with numbers for now. And the next clip, we'll take a look at strings. Strings are made up of text.
Strings

We've already worked with strings a bit in this course. Strings are texts such as Hello World, or any kind of name, or title, or something that a user might type in to a field. Let's work with these in JavaScript. So we have a variable message, and let's set it to a string value. I'll use single quotes, and we'll see shortly how we can use different types of quotes, but let's just say Hello World. I'll save this, and we get Hello World in the browser. We could also use double quotes, and that'll work as well. I'll save it, and we get the same result. And you'll notice that the quotes don't show up when we print it on the web page, but what if we wanted the quotes to show up? We use a special character called an escape character, it's the backslash. So specify backslash double quote, and that'll put a literal double quote in the string, and I'll put one at the end as well. I'll go backslash double quote, and I'll hit Ctrl+S to save it, and we get Hello World with World in quotes now. And of course you could do this the same with single quotes if you're working with single quotes. And there are actually a lot of different characters that we can escape using this backslash. Let's go to the Mozilla Developer Network and see how we can work with this. This is the page were at earlier, Operator precedence. We'll search for uppercase string, and I'll click this one right here, and I'll just search for the word escape. And we're looking at this section, Escape notation. And here we have all the different characters that we can create by using this escape sequence. We saw this one, the backslash double quote, that puts the literal double quote in the string. We could also do it with a single quote. Another common one you see is \n for a new line character, and you can also do a \t for a tab. But feel free to look at this table in case there's some special kind of code you need to enter into a string. And remember, it's listed under the string object at MDN. And there's one other special way to create strings. We can make more room here, and we can create a string with the backtick character. It's not an apostrophe, it's the opposite, and it's usually located to the left of the 1 on the keyboard. But here I have two backticks, and I can put a normal string in here, I'll just say Hello, and that shows up fine. But the special thing about the backticks is that we can do something called interpolation. We can print out a variable within the string. So let's create a new variable, let name = Andrea. And now that we have this variable name, we can embed it within message. The way we do that is we specified $, and then opening and closing curly braces, and we put the variable name inside, the variable name is name. So that looks like strange syntax, but it works great. I'll save this, and we get Hello Andrea. Another benefit of using the backtick characters for strings is that we can add new lines within the string. I'll hit Enter a few times, and there might be occasions where you need these new line characters in a string. I'll save this, and it shows fine with no errors. The thing to remember though is that in a web page when we're working with text, it removes all the white space, such as new line characters, tabs, and spaces, and replaces all of it with a single space. So instead of showing message, let's also console log it, console.log message. And I'll open up the console, I'll right‑click, and Inspect, click on Console, and I'll save this to execute it. And here you can see that in fact our message variable does have new line characters in it. And again, all this white space gets converted into a single space when you're working with things such as header tags or paragraph tags in HTML. It's very common in JavaScript to manipulate and work with strings, so we'll go into the details of that in the next clip.
Manipulating Strings

We saw how we could use operators to manipulate numbers. The operators were symbols such as plus, minus, the multiplication symbol, which is a star, or the division symbol, and others, and we could do some of the same things with strings. Mainly we use the plus operator to add strings together. That's called concatenation. So here we have a variable message and it's being set to Hello. Let's modify this. So we'll set message equal to message plus space World. I'll save it, and you can see now that the browser shows Hello World. So the plus symbol simply takes one string, in this case Hello, and adds space World to it, another string. And we don't have the other mathematical operators here, but we do have a very rich set of methods that we can use. We'll be covering methods later in the course, but you can think of a method as an action we can take on a string. So I'll modify this, and I'll say message = message. And you'll notice that when I type the dot, all these items show up, and I'm going to pick the item toLowercase, and this will convert the string to lowercase, as the name says. But we have to enter parentheses, and we'll cover that later too in the course is well. So what this is going to do is it's going to take message and convert it to lowercase and save it back in message, the variable. I'll save this and it prints out hello, lowercase. Likewise, there's a toUppercase method that we can call. I'll save it, and again, this is taking message Hello and converting it all to uppercase and storing it back in the variable message, and the result is an all upper case HELLO. And there really are a lot of ways we can manipulate strings. Looking at this list of methods again, a very common thing to do is to create a substring, which is a smaller slice of the string. So I'll click on substring right here, and notice that when I enter the opening parentheses it tells me a little bit of detail about how to work with substrings, but for now just know that the first number we type is the location where we want to start to grab a substring. So I'll enter 1, and I'll save it, and you can see that it shows ello, it dropped off the H. Now to understand this better, one place we can go is to MDN, as we've seen earlier. I'm at the string reference, and we've seen a few things on this page already, but if we scroll down on the left side, you can see a section called Methods, and these are all the different methods or actions that we can perform on a string. And we'll take a look at this more when we're working with objects later in the course, but if you wanted to look around now, that's fine. You can find out what all these methods do. And in addition to methods, we also have properties, and a property is sort of like a variable, it holds a single value on an object, and an extremely popular property to use on a string is the length. So I'm setting message equal to message.length, which is the length, the number of characters in the string. I'll save it, and you can see that we get 5. It's important to also know that 5 is a number. Let's just show this by showing typeof, typeof message, and we get number. But if we don't do any kind of assignment here, I'll just comment this out with the double forward slash and save it, you can see typeof message is string. So what if we had message is equal to the string 123? Now 123 is a number. I'll clear out this line just to make it more clear. What do you think it's going to show now? We're showing typeof message, but message is a string with a number inside it. I'll save it, and it's still a string. If we left the quotes out, it would be a number. And this is very important to know, like what if we tried to show the message + 2? Well, if message were a number, the answer would obviously be 125, but I'll save this and let's see what we get. We get 1232. So whenever we have a string such as the message variable and we use the plus operator, it works on strings. That means that the 2 will also be converted into a string. So when we add a 2, we're essentially adding a string 2 to the end of 123, and that's why we get this value here. Obviously if we took off the quotes so that message is a literal number 123, I'll save it, and then we get 125. So it's very important to know that when we are working with strings, it doesn't do any kind of automatic number conversion. And if we use the plus symbol, it converts everything to a string. I'll save this, and again we get 1232. So we'll be looking at strings in more detail in the module on objects, because strings are one of the most common objects that you'll use.
Converting Strings and Numbers

There are times when we have a string in JavaScript, and we want to convert that string into a number. Likewise, sometimes we have a number, and we want to convert that into a string. Let's see how we do this in JavaScript. So we have a variable amount set to the number 123, but what if we wanted to use amount as a string rather than a number? I'll say amount = amount.toString, and opening and closing parentheses. We'll learn more about this .operator when we learn about objects, but for now, just know that you can take a variable that's a number, such as amount, and call .toString on it, and that'll convert it into a string. To show that, I'll show the message typeof amount. I'll save it, and we get the string. Usually, JavaScript will take a number and automatically convert it into a string when needed, but it's a little bit trickier when we have a string and we want to convert that into a number. Let's see how we do that. Let's say we have the string with the value 123.12, we can convert this to a number by specifying number, which is an object, we'll learn about that later in the course, but we can say number.parseFloat, and the string goes in parentheses. So whatever string we put here will be parsed, and JavaScript will be looking for a number out of this string, and it'll store that number an amount. I'll save this, and you can see we get 123.12, but more importantly, if we do typeof amount, I'll save it and we get number. So the conversion did happen. You just want to make sure that we don't have any non‑numerical values before the number. I'll just put the letter A here, and we'll see what happens. I'll remove the typeof, and I'll save it, and we get a strange symbol called NaN. This stands for not a number, and that just means that we weren't able to parse a number out of this because of the character A. Now if we move the character A and put it on the end, I'll save it, and it prints 123.12. So when we're parsing a string, you just need to make sure that the beginning of the string is a number. As soon as it runs into a character that isn't part of a number, it stops parsing and does not throw an error. So this could be useful. So to convert a string to a number, we usually call Number.parseFloat, passing it the string. To convert a number to a string, a lot of times that happens automatically, but if you need to do it yourself, you specify the variable name.toString, with the opening and closing parentheses. So that covers strings and numbers. We'll take a look at Boolean values in the next clip.
Boolean Variables

Variables that are a Boolean type have either the value, true or false. Those are the only two values. Sometimes you think of true as yes or some number and you think of false as no or 0 as a number. Let's take a look at these in Visual Studio code. So I'll create a new Boolean variable, we'll call it saved, and we'll set it the false. Maybe this variable keeps track of whether or not the user saved their information or not, but any kind of true/false, yes/no value is Boolean. So I'll showMessage typeof saved. I'll save it and we get Boolean, and the other value is true. I'll save this, and we also see that it's a Boolean value. If we look at the actual value of it, I'll remove the typeof operator, I'll save it, and we get true. One common operation that we perform on Boolean variables is to flip it. If it's true, we want it to be false, or if it's false, we want it to be true. The way we do this is we can say saved = !saved. So the exclamation point we see here means not, so if saved is true, it'll become not true, but false. Likewise, if it's false, it'll become not false, but true. So I'll save this and you can see we get the value false. Saved starts off as true, but then we set saved equal to not saved and that's how we get the false value. And this is a very simple type, but it's used in many places. We'll see it later in the course when we do more programming. The next types we'll take a look at are the null and undefined types.
null and undefined

Null and undefined are two more types in JavaScript. These are also very simple. Null has one value, null, and undefined has one value, undefined. Let's see how we work with these in JavaScript. Here we're declaring the variable saved, but we're not initializing it. It has no value. And we saw earlier in the course that it will have a value of undefined. When we call showMessage, nothing shows up in the website, but let's console that log this value out. I'll save it and I'll open up the console, and you can see that we do get undefined, even though nothing showing in the browser, and that's the definition of undefined, it means that we have not initialized a variable or some other value. Now it may be that saved does get initialized, say to something like the value 10, but then later in our code, after we run some processing or some algorithm, we might want to wipe out the value that's stored and saved. We can say saved equals null. So I'll save this and we'll see what we get. So when we set a value to null, still nothing shows in the browser, and in the console we get the value null rather than undefined. So the difference is that JavaScript will set values to undefined when they're not initialized. But a programmer will set a variable to null when they want to wipe out that value. But that isn't enforced by JavaScript. That's just the best practice. We could very easily say here that saved is equal to undefined. I'll save this, and we're back to getting undefined in the console. But it's agreed among many developers that when we want to wipe out the value of a variable, we use null instead of undefined. That way we can always differentiate between what JavaScript is doing with undefined and what developers are doing with null. In the next clip, we'll take a look at the last two types, which are objects and symbols.
Objects and Symbols

The last two types will look at our objects and symbols. Objects are a very important part of JavaScript, and we'll be covering them in detail later in the course. But we'll just take a quick look now just to find out what they are. And symbols is a very advanced type. We won't take a look at that until later in the course when we're discussing objects. So for now, let's just take a look at what an object is. Let's way we have a variable called person, and that person has a first name and a last name. Normally, you would use two variables, one for first name and one for last name. But with an object, you can store all that information together, and you start together within curly braces. So here I have open curly braces and closing curly braces. And inside of this we can specify what are called properties, which are similar to variables. Let's say firstName, and I'll just say John for the value, and lastName, Adams. So person is now an object. And to prove that, let's enter typeof person, and we'll see what we get when I save it. We get object. We can call showMessage like we were before. So now it'll show in the website. We have object. If we wanted to see what the first name is of this person, we can say person.firstName. So the dot operator takes an object and pulls up one of the properties off the name. In this case, we're looking at the first name. I'll save it, and we get John. Another very useful feature of objects is that we can have something called methods where a property like first name holds a single value, a method can actually run its own block of code, and we'll get to that in time. But for now, just know that an object is another valid data type in JavaScript. And the final data type is symbols. And a symbol can be used as a property in an object, such as first name, but it's hidden. There times where you might want to hide information about an object, and you use symbols for that. But we'll take a look at that later in the course when we cover objects. Let's wrap up this module with the summary.
Summary

We started off this module by looking at numbers. Numbers are declared easily with no quotes and nothing special, and we can use the main mathematical operators with numbers. plus, minus, the star for multiplication, and the forward slash for division. We also saw how the percent symbol can be used as a remainder operator. Next, we looked at strings. Strings are text, and we define those with three different styles of quotes, the double quotes, single quotes, or backticks. And we have our choice, but the backticks allow us to enter whitespace and new line characters while also letting us do interpolation. We saw how to put variable values directly within a string. Next, we saw how to convert between data types, specifically numbers and strings. If we had a numeric variable, we can specify .toString with parentheses in order to convert it into a string. Likewise, if we had a string, such as 123 here, we can call Number with a capital N .parseFloat, passing it whatever string we'd like to parse. This will result in a number 123. You just need to be careful that if the string doesn't have valid number characters in it, you might get the result NaN, which stands for not a number. And we'll see later in the course how we can check for this. Next, we looked at Boolean values with the boolean type. And these are either true or false. And there's one operator that we use with booleans. It's the not operator, the exclamation point. And this just flips the boolean. If the boolean's true, then the not symbol turns it false and vice versa. Next, we looked that null and undefined. We saw how undefined is assigned by JavaScript when we don't initialize a value. So if as a programmer we ever wanted to wipe out the value of a variable, we would use null instead. So developers use null to show that a value has been wiped out, and JavaScript uses undefined to show that a value was never assigned in the first place. And that's a best practice. Always use null and never use undefined. Finally, we looked at objects and symbols. We saw how objects are created by curly braces, and we're going to be covering these in detail along with symbols later in the course. So now you know all about variables and the type of variables that we work with in JavaScript. In the next course module, we'll take a look at program flow. Normally, our programs have been flowing top to bottom, like as we write code, the code was executed sequentially from top to bottom. But sometimes we want to jump around and loop, and things don't always happen sequentially. We'll find out more about that in the next module.
Program Flow
Introduction

Hi, this is Mark Zamoyta with Pluralsight. This module is titled Program Flow. We've seen how our JavaScript programs so far flow from top to bottom, but sometimes we don't always want that. Sometimes we want to include extra code or exclude certain code or even loop over the same code continuously, and this all refers to the flow of our code. Let's take a look at what we'll cover in this module. We'll start off by looking at if else statements. This allows us to set up certain conditions which will allow certain code to execute. If a condition is met, we'll execute some code, else, we'll execute other code. Next we'll look at Truthy and Falsy expressions. When we're working with conditionals, the conditionals generally evaluate to true or false. But there are certain values of certain variables that take on a true nature or a false nature, and that's where we get the terms Truthy and Falsy. We'll look into this, and we'll make sure we understand how to work with conditionals properly. We've seen the equal sign as an assignment operator, we assign a value to a variable using the equal sign, but there are two other symbols that are important to know, the triple equal sign and the double equal sign, so we'll take a look at these. And there's a special ternary operator in JavaScript. This deals with a condition and two different statements that could execute based upon the condition. We'll see the syntax for this. And next we'll look at block scope. When we're working with blocks of code, we're allowed to declare variables within that block, and when the block completes, the variables disappear. We'll see how this works. And finally, we'll look at looping through code. We can create for loops, while loops, and do while loops, and we'll look at examples of each and the syntax for each. So let's get started working with conditional code with the if statement.
Conditionals Using if()

Very often in JavaScript, we need to conditionally execute some code. If a condition is true, you want to execute a code block, but if the condition is false, we don't want to execute it. Let's see how this works in JavaScript, We used the if keyword in an if statement. A statement is simply giving a command to JavaScript, and the way this works is we specify the keyword if and then in parentheses, we put the condition. In this case, we're checking if 5 is equal to 5. That's what the three equals signs mean. We saw how a single equals sign let us assign of value to a variable, but we're not doing that here; we're comparing. So we use three equals signs. So if 5 is equal to 5, we execute this code block. A code block is code that exists between opening and closing parentheses. So in this case, because 5 is equal to 5, we'll log out the word, Yes. The condition is true. In this next If statement, the condition is false. If 5 is greater than 10, execute this code. The word no is never going to show in the console. The code will not execute. We can see how we can use a greater‑than sign. We could also use a lesser‑than sign. And in this third example, if 5 is greater than or equal to 5, we write out Yes, and that's true; 5 is greater than or equal to 5. Likewise, we could check for less‑than and equal‑to 5. In these examples, we're working with literal numbers, but most of the time you're going to be working with variables or a variable and a number. Let's see some more examples. Here we're creating a variable state and we're setting it to FL for Florida, and we're creating another variable called taxPercent, which we're setting to 0. Then we have our conditional, if statement. If state is equal to Florida, FL, we want to set taxPercent to 7, and the condition is true. TaxPercent will be set to 7, and when we log out taxPercent, we get 7. So we're comparing a variable to a strength. And again notice we're using the triple equals sign. It's a very common bug to use a single equals sign or a double equals sign, so make sure that in our conditionals we're using three equals signs. And in this example, they made a small change. We're starting off by setting taxPercent to 7, but now we're checking for an inequality not equal to, and we do that with the exclamation point, which means not, and two following equals signs. So if the state is not equal to Florida, we set the taxPercent to 0, but the state is equal to Florida so that code never executes. When we log out taxPercent, we get 7, but the key takeaway is that the not double equals sign checks for inequality. Let's go to Visual Studio Code and write our first if statements. So I have a simple if statement and the code block, that's the code between the parentheses, will show the message, true. So inside of the if statement, I'll simply put the word true. So if true, show the message, true, I'll save it and true shows up. Likewise, we can specify false here. I'll save it, and the original HTML markup shows GET A GRIP. This code is not executing. We can put some literal numbers in here as well. If 1 equals 1, we'll show true. I'll save it and we get true. If 1 is equal to 2, I'll save it, and true does not show up. I'll create a variable, let price = 20, and then we can compare price to a value. If price is greater than 15, we'll show the message discounted. I'll save it, and we get discounted, but if we say if price is less than 15, I'll save it, and discounted does not show. So the symbols we can work with are greater‑than, less‑than, or we can put a greater‑than or equal‑to symbol or a less‑than or equal‑to symbol, but probably the most common ones are identically equal, which are the three equals signs, or not identically equal, which is exclamation point equal equal. In this case, if price is not equal to 15, we'll show discounted. I'll save it, and we get discounted showing up. So these are the very fundamentals of if statements. You're going to be using if and other conditionals all the time. So it's very important to understand what is true and what is false. This can get tricky in JavaScript so in the next clip we'll take a look at this.
Truthy and Falsy

So we've seen our first conditionals with the if statement, and between the parentheses after if, there needs to be an expression that evaluates to either true or false, and in JavaScript, we describe the quality of this as either being truthy or falsy. So let's look at a few examples and a few of the quirks in JavaScript, and we'll start off with falsy, because truthy is the opposite of falsy. Obviously, the Boolean value false is false, and the number 0 is false, but only the number 0. When it comes to strings, a string is false if it's empty. So if we have two quotes right next to each other, whether it's double quotes or single quotes or single backticks, so as long as there are no characters between the quotes, it's false. And we saw the value null; that evaluates to false, and undefined also evaluates to false. And we also saw the special symbol, not a number, NaN; that evaluates to false as well. So if all of these are false, what's true? As a developer, the easiest way to remember what's true is simply to remember what's false and it's everything else. So everything not falsy is truthy. So obviously the Boolean value true is truthy; any number beside 0 is truthy. So 0.5 is truthy, and this is where things get a little bit tricky, but if you had a 0 showing as a string, here it's in double quotes, that's actually truthy, but the number 0 by itself without quotes is falsy. So when we write our conditions, we need to keep this in mind. Let's go back to Visual Studio Code and look at some of the trickier examples. Here's our code from the last clip, and I'll clean this up for a second. I'll take out the variable and let's just put a quoted 0 in here, and I'll show the message, true. I'll save this and we get the message, true. You would think 0 would be false, but it's not, as long as it's a string. So let me take out the quotes and just have the number 0 there and I'll save it, and true does not show. So it's very important to keep that in mind. And one other important thing to keep in mind is what we saw earlier. We saw that 1.1 plus 1.3 is actually not equal to 2.4. Remember that JavaScript uses inaccurate floating point numbers. So if I save this, we get true. So this is a case where JavaScript and the floating point arithmetic really lets us down. This could throw off our calculations, especially if we're using greater‑than or less‑than. The way to fix this is to always round off your numbers. So to round off 1.1 plus 1.3, one thing I can do is I could put it in parentheses, and by putting in parentheses, I can now treat it as an object. I can put the dot symbol and type toFixed. So this will create a fixed number with two decimal places, because I entered the number 2 here, but the problem with toFixed is that it returns a string. We need to convert all of this from a string to a number, and the easiest way to do this is by adding a plus sign before the parentheses. You can think of the plus sign as similar to the negative sign. Negative would make the number negative, but the plus sign just leaves it as it is, but it does have the benefit of converting a string to a number. So when I save this now, it does not show true, which is correct, because I'm checking for not equal to. If we wanted to check for equality, I'll enter the triple equal symbol, and I'll save it, and things are good. So the key takeaway here is that when you're working with floating point numbers, you always need to convert the floating point number to a fixed amount of decimal places if you're going to compare it to a literal such as 2.4. If you don't do this, your calculations could be off. And also remember that the plus sign is a simple way to convert a string returned by toFixed back into a number. And another thing about code blocks is we've only been working with one line of code, but we can put as many lines of code as we'd like, between the opening and closing parentheses. I can create a variable, let message equal hello, and I can use that variable here. And we could have as many lines of code here as we'd like, and we can also put if statements within other if statements; that's very common. I'll save this, and we get hello.
if ... else

We've seen the if statement, but there's a special clause that we can add to the end of an if statement where we can specify a code block that'll execute if the condition is not true. We use the else keyword. Let's see some examples. Looking at this if statement, if state is identically equal to FL for Florida, we execute this code block. We can also specify an else clause, else execute this code block. So if state is not equal to Florida, this code block will execute. When we log out taxPercent, we get 7 because state is equal to Florida. Let's see another example. Here's our if statement and our else clause, but we're immediately adding another if statement to the else clause, and that's fine. So if state is identically equal to Florida, we execute this code block, else if state is equal to New York, we execute this code block. And this is a very popular construct in JavaScript to have an if statement and one or more else/if statements following that. Let's go to Visual Studio Code and look at this live. So here we have an if statement, if true will show the message true, and let's add an else clause to it. Else and we'll specify a block of code with the opening and closing parentheses will show the message false. I'll save this, and we get true. Likewise, if our expression in the if statement evaluated to false, I'll save it, and false shows up in the browser. So in this case are else clause executed, and we showMessage false. Normally, this would be used with some kind of variable. Let's let price equal 20. If price is greater than 10, we'll show the message true. And just to see this working, I'll save it, and we do get true. But let's add another if statement after our else keyword. Else if price is less than 5, let's just show a message less than 5, and we'll set price equal to 4 to test this. I'll save it, and we get less than 5. So this condition here evaluates to false. So else is checked, and if price is less than 5 which it is, we execute this code block here, and we get the message less than 5. One other thing I'd like to show you is that these braces aren't required. Sometimes you'll see code without them. I'll take these out, and this is a lega syntax. After the condition, you can either have a block of code as we've been using, or you can have a single statement as we see here. And I'll save this just to show it works. We get less than 5 still showing up. But it is a best practice to always use the curly braces. It avoids confusion, and it makes it very obvious that the code belongs together as a block. If at a later time we wanted to add more code, the curly braces will already be there. So I'll put those back in. Another common thing we usually see is multiple else keywords. This is legal as well. We can put as many elses or elseifs as we'd like. Let's check for less than 4, and we'll set the price equal to 1. And let's just say greater than 5 here. So if price is greater than 10, we'll show true. If price is greater than 5, we'll show greater than 5. And if price is less than 4, we'll show less than 4. I'll save it, and we get less than 4. So, just remember, it is a best practice to always use curly braces, even if a code block only has one line of code.
Comparing === and ==

When we test for equality, we've been using three equal signs, but there's another symbol which uses just two equal signs. Let's see the difference between these two symbols and why using three equal signs is a best practice. We have an if statement that's comparing the number 1 with the string "1", and we're using the triple equal sign. I'll save this, and we get false, so a number 1 is not equal to a string "1" when we use the triple equal signs. However, if we use two equal signs, I'll save this, and we get true. So when we use two equal signs, what happens is that JavaScript will attempt to convert types. It will convert the number 1 into a string "1", so the comparison is true, and this could be very confusing at times. When you compare numbers or variables, you want to make sure you're comparing the same type, and that's why we use three equal signs. If the types are different, it'll evaluate to false. Again, I'll save this, and we get false. Sometimes the triple equal sign is read as strictly equal to or identically equal to, and that's because the types need to be the same. Likewise, there's a not equal to symbol, so the number one is not equal to the string one. I'll save this, and we get true, that's correct. But if we just use the !=, again, this is similar to the double equal sign. JavaScript will convert the number 1 into a string "1". I'll save this, and we get false, which could be confusing. So it's a best practice to always use for inequalities, exclamation point with two equal signs, or for equalities you would just use the three equal signs, as we see here. In the next clip, we'll take a look at a shortcut for creating if else statements.
The Ternary Operator

There's a special operator in JavaScript called the ternary operator. It's called ternary because it works with three different values, and it's a shortcut for working with if‑else statements. Now, it does look a little bit cryptic. There are some symbols that you need to know. First of all, it starts out with a condition, just like with an if statement but no if keyword. Following the condition, we have a question mark, and if the condition is true, the true statement will execute. That's followed by a colon and a false statement. If the condition is false, the false statement executes. So to see this in action, we're checking for a price greater than 10. We have our question mark, and if price is greater than 10, let's assume it's set to 20 and it is, then we'll use the value expensive. Else, which is symbolized by the colon here, we'll use the value cheap. So at the end of this line, the variable message will either hold expensive or cheap, one of those strings. And if price is set to 20, it'll show the message expensive. If price is less than or equal to 10, it'll show the message cheap. Let's look at this in our editor. So we're setting price to 20, and we have our condition, price is greater than 10. That'll be true, so our true statement should execute, showMessage('yes'). If price were less than or equal to 10, we would showMessage('no'). I'll save this, and we get yes as expected. Let's change the condition to less than 10. I'll save it, and now it shows message no. One thing I want to point out is that these parentheses are not required. I'll just remove them before price and after 10, and we still have a condition here, price is less than 10. And just to show we don't have an error, I'll open up the console, and I'll save the code. And you see, we get the value no with no error. So it's fine to leave out the parentheses, but I like to keep them in just because it makes it clear that it is a conditional, and where that conditional begins and ends. Here our true statement and our false statement each execute a function, but many times we just see a simple value here. I'll just change this to yes as a string, and I'll change the false statement to no as a string. But we would need to assign this to some variable to make use of it. So I'll say, let message =, and depending upon the condition, it'll evaluate to yes or no, and I'll use message here. I'll save it, and we get no. So you'll see the true statement and the false statement either be values or function calls, but each is only one single statement. And again, this is called the ternary operator because we have three statements, the condition, the true statement, and the false statement.
Block Scope Using let

When we started working with if statements, we started working with blocks of code. A block of code exists between the open and closing parentheses. And we can actually declare variables within a block. And if we declare that variable using let or const for constants, that variable will only be available in that block. And this is very important to understand because variables might seem to disappear otherwise. Let's take a look. So we have a simple if statement. If true will show the message true. Let's declare a variable within the code block. We'll let value equal yes, and then we'll showMessage value. I'll save this, and we get yes as expected. But the question is, can we access this variable that we declared in the block? Can we access it outside the block? I'll console.log value. I'll save it. And you can see that we got an error because it paused. So I'll go to the console, and I'll resume the debugger, and we could see the error is uncaught ReferenceError: value is not defined. So we declared value here in a code block, but we cannot access it outside of that code block, and that's a good thing. That way we can encapsulate some code and not have it leak outside the block. Now this behaves very differently if we use the old keyword var. Let me change let to var, which is not a best practice. And I'll save this, and we'll see what happens. So in this case, it console.log value as yes. So are variable value leaked outside of the code block. And that's very confusing, especially if you come from another language, such as Java or C#. When you have a code block, any variables declared inside it should stay only within that block. And that's why it's a best practice to always use let. Or if you have a constant, use const. Let me change this to a constant because it's not changing. I'll save of it, and we get the error that we expect. We'll go to the console and resume it, and value is not defined, which is correct. We're trying to access value outside of a code block where it was declared, so we should get this error.
Looping with for()

We've seen several ways to conditionally execute code that will either execute the code or skip it altogether. But sometimes we need to loop over code. We need to execute the same code over and over and over. One way to do this is with a for statement. Let's take a look at this. The keyword for lets us create a loop, and this might look pretty cryptic, but let's break it apart. We use the for keyword, and then we have a few different things in opening and closing parentheses here. The first thing we have is a statement. Here we're declaring a new variable i, and we're setting it to 0, and this is the first thing that executes in a loop is this statement here. Next, we have a condition. We're testing to see if i is less than 3. And if this condition is true, we'll execute this loop. You can see the body of the loop here between opening and closing parentheses. And this final part here is a statement that'll execute after the loop completes. So if you remember, the ++ operator is called the increment operator, and it adds 1 to i. So when this code executes, i starts out a 0, and 0 is less than 3, so we'll log out i, which is 0. And the loop has ended, so this statement executes, i++. Now i is 1, and 1 is less than 3, so we log out 1. Then we'll incriminate i again so that i is 2, and 2 is less than 3, so we'll log out i, which is 2. We'll increment i because we're at the end of the loop again. And now i is equal to 3, and 3 is not less than 3. So our loop is done. Our code will continue executing below the body. But this for loop is complete once this condition returns false. So the result of this loop are the values 0, 1, and 2 being logged out. The loop executes three times. So let's look at this loop here. We use the for keyword, and we'll declare i to be equal to 0. And as long as i is less than 5, we'll log out i. And after the code body completes, i will be incriminated. So let's see what this shows in the console. I'll save it, and we get the values 0, 1, 2, 3, and 4. So that worked as expected. We'll be using loops later on in the course when we start to modify the web page, the DOM. But for now, let's just start with these simple examples. One common bug is the condition. Sometimes you'll see something like less than 5 or less than or equal to 5. And, of course, these produced different results. I'll save this, and you can see that now the numbers go from 0, let me scroll up here. The values go from 0 to 5. So you always want to be careful what you're doing, whether you want less than 5 or less than or equal to 5. Now there's one thing that can go horribly wrong in a loop, and that would be if the loop never completes. What if instead of i++, we said i‑‑ by accident? That'll decrement i, and the condition will always be true. I will always be less than 5. Let's save this and see what happens. So you can see the values showing up in the browser. They're getting negative very quickly. We're up to ‑20,000 or more, and it's jumping quickly. You'll also notice that the web page stopped showing, So we're in what's called an infinite loop. This is going to continue and we're stuck. Let's try to stop it by hitting the X button in the browser. So that seemed to stop the web page from loading. But our values are still showing up in the console, and this is a big problem. Right now the browser is hung up. There's no way to stop it. I can try to refresh, but nothing happens. The JavaScript is still executing in the background, and our values are still going up and up in the console. And unfortunately, the only way to kill this is by exiting out of the browser. So I'll do that, and I'll restart. So I restarted the browser, and I'm trying to go back to the web server. And even though I shut down the browser and restarted it, there's still a problem on the web server. Let's exit the page because waiting is doing no good, and we get an error. I'll try to refresh. And again, you can see that the web server is still hung up. So I'll go to Visual Studio Code, and they'll hit Ctrl+backtick. That'll bring up the server. And I'll shut it down with a Ctrl+C. Terminate batch job, I'll hit Y for Yes. I'll stop the browser. Now before I start the server, I'm going to fix the code. We're going to say i++ instead of i‑‑. You can see how much trouble this endless loop caused. We had to shut down the browser, that didn't work. We had to shut down the server. But let's fix the code and then restart the server. So the code's fixed and I'll save it and I'll execute npm start. And I'll start up the browser again, and everything's good. So you can see the dangers of working with loops. You have to make sure that the loop comes to an end. Otherwise, you'll get stuck like that. You may need to reboot your web server or you may need to restart your browser. So this is one kind of loop that's called a for loop, but there's another popular kind of loop called a while loop. We'll see that next.
Looping with while()

We just saw how to loop with a for loop, but there's another kind of loop called a while loop. Let's take a look at this one. We'll declare a new variable count and we'll set it to one. And then we have our while loop, so we use the while keyword and we specify a condition, just like we do with the for loop or an if statement. While count is less than 5, we'll execute this code block. So we'll log out count and then we'll increment count, and incrementing count is vital. We don't want to get into another situation where we have an endless loop. We saw the trouble that that can cause. So count starts off at 1 and we log out 1, 2, 3, and 4. But by the time count gets incremented to 5, 5 is not less than 5, so the loop completes and code execution continues after the body of the while loop. Let's see this in Visual Studio Code. Now here I'm using the variable i, and you saw this earlier, but i is a traditional variable name to use in loops. It stands for index, or it could also stand for iterator, but you'll often see single variable names such as i, j or x, y, and z used in loops. So here we're setting i to 4, and while i is greater than 0, we'll log out i, and we're counting backwards in this example, so we'll decrement i. I will go from 4 down to 0. I'll save this and we'll see what we get in the console. Looking in the console, we have the values 4, 3, 2, 1. And again, it's very important to look at how the loop begins and ends. We're setting i to 4, so that's the starting point. But by the time i becomes 1 and we decrement it, i will be 0 and 0 is not greater than 0. So the loop ends there. Zero never gets a chance to be logged out. So this is quite a bit simpler than a for loop. You just have the condition after the while keyword, but you absolutely need to make sure that the loop will come to completion. Otherwise, things could get hung up again. And there's one other loop I'd like to show you in the next clip, it's a do while loop.
Looping with do ... while()

The final loop we'll look at is a do while loop. You use a do while loop when you're guaranteed that the body of the code will run at least once. Let's take a look at this. We're creating a new variable account and setting it to 1, and then we're using the keyword do. That's the beginning of our do while loop. So we have do followed directly by the code body. Those are the commands between the opening and closing parentheses. And then we have the key word while and our condition. So this code block is guaranteed to execute at least one time, so it'll print out 1 increment count, and then while count is less than 5, it'll continue to execute the code block. So this code block will execute 4 times, showing the values 1, 2, 3, and 4. So this is similar to the while loop. The while loop tests the condition at the beginning, but here with a do while, the while is testing the condition after the code block executes. So here's a live sample. We're setting i equal to 4, i is the new variable, and our code block is guaranteed to execute once. And while i is greater than 0, the code block will continue to execute. So, again, you need to be very certain that at some point in the future this loop will end, and it will because we're decrementing i. I'll save this and we'll see what we get. We get the values 4, 3, 2, 1 showing up. Now what if we started off by setting i to ‑4? So i will be ‑4, we'll log out ‑4 here, and then we'll decrement i to ‑5. Let's see what shows up in the console. We get ‑4. So, again, the code block is guaranteed to execute once. That's how we get our ‑4. And this while condition is never met, i is always negative, so the code block executes once, and then we're done. Code will execute from line seven on after this. So those were the key loops that we have in JavaScript. We've seen how to use for loops, while loops, and do while loops. Let's wrap up this module with summary.
Summary

We started off this module by looking at if‑else statements. Based upon a condition which evaluates to true or false, we can execute certain code. And in the else clause we can execute code if the condition is false. We looked at truthy and falsy expressions, and we saw how certain variable values evaluate to true and other ones that evaluate the false. So "0" as a string is true, and every number is true except for the number 0, without the quotes. And we also saw how values such as null and undefined are false. Next, we took a look at comparing the === to the ==, and we learned to always use the === for identically equal to and the !== as identically not equal to as a best practice. These make sure that you're comparing numbers or objects or anything of the same type. By using the == or !=, JavaScript might try to convert types, which isn't always intuitive. Next, we looked at ternary operator. That's where we have a condition, and then the question mark symbol, and based upon the condition, if it's true, there's a true statement, colon, and if it's false, there's a false statement. And this is a concise way of writing an if‑else statement. You can do it all simply on one line. Next, we looked at block scope. We saw how variables that are declared with let or const are block scoped. The variables only exist in that block, and once the block completes, they disappear. And this is one reason why we declare our variables with let or const instead of var. Finally, we took a look at several different types of loops in JavaScript, the for loop, the while loop, and the do while loop. And we need to be very certain that our loops will complete. The browser can get hung up if they don't. And in certain circumstances where our browser is strictly tied to our development web server, even the web server could get hung up. So whenever you write a loop, just be sure that the loop finishes execution at some point. And all of these things we looked at in this module refer to program flow, whether we include or exclude blocks of code or whether we loop over code. And in the next module we'll take a look at functions. A function is a block of code that we can give a name to and call it over and over. And most of the code that you write in JavaScript will exist within a function, so I'll see you in the next module.
Functions
Introduction

Hi. Welcome to this module titled Functions. My name is Mark Zamoyta. A function is a block of code that's named. You can use that name, or you can use a variable that points to the function to execute that block of code. This is a very important part of JavaScript, and most of the code that you write will be part of a function. If you're not writing code inside a function, then you're writing it inside the global scope, which is pretty limited, most of the code that you write, you'd want that to be reusable within functions. Let's see what we'll cover in this module. We'll start off by looking at function basics. We'll see how to declare them and how to call a function and the basic syntax for defining them. Next we'll look at function expressions. It's common to take a function and store it in a variable, so a function doesn't necessarily need a name. But we at least need a variable pointing to the function. That's what function expressions are all about. We'll see how to pass information into a function, and that way the code block of the function can work with our data, and we can see how to get values out of the function. All functions return some value, and we'll see how that works. Next we'll look at function scope. The code block of a function is very similar to the code block of an if statement or a for loop in that you can define variables that belong only to that function. Once the function finishes executing, the variables no longer exist. And there are a few other tricky things about scope that we'll learn about. Lastly, we'll use functions to modify our web page. We've been using one all along called ShowMessage. But we'll look at this in more detail and we'll create at least one new function to modify the page. So let's get started and learn the basics of functions.
Function Basics

One way to look at functions is that a function is a block of code with a name. And because it has a name, you can call it over and over. Most of the JavaScript code that you write will be within functions. Let's see how we create thes. Here's an example function. We use the function key word, and then we give the function a name. Here the name is showMessage. We follow that by opening and closing parentheses, and that's the evidence that we're working with a function here. We'll see in a future clip what goes in these parentheses. But for now, just know we have the name of the function, parentheses, followed by a block of code. We have opening and closing curly braces. And whatever's between these curly braces is referred to as the body of the function. This is the code that executes when we execute the function. And here's an example of some code. Between the curly braces, we call console.log and we simply log out in a function the string. And we could have any code here. We could have if statements, loops. We can call other functions, and we could even call ourselves as a function. But let's keep things simple for now. Once we have a function defined in this manner, let's see how we call it. So we're defining our function on top called showMessage, and then here is where we actually call the function. We execute it. We simply enter the name, followed by the opening and closing parentheses. That will execute the function. And you can see that we're calling showMessage twice. So the message will be shown twice in the console. And that's the main purpose of functions. If we have code that we want to execute multiple times, we generally put it in a function. Let's get this working in Visual Studio Code, and let's create our first function. I'll enter the function keyword, followed by a name. I'll call it logMessage. And I'll create the function body with the opening and closing curly braces, and I'll simply log out a message. So this defines the function. However, we're not executing it yet. When code executes here from top to bottom, the function will exist, but this code block will never execute. To get it to execute, we call the function, logMessage and opening and closing parentheses and we end the line with a semicolon. So before I save this and execute it, let's open up the console. I'll save the code, and it shows Here is a message. Now if we wanted to execute this again, we could simply call it again. And I'll save it, and the message shows twice. So those are the very basics of using functions. We use the function keyword, give the function a name, and enter the code we want in a code block. To call the function, we simply put the name, followed by parentheses. There's another way to declare a function that's called using a function expression, and we'll see that in the next clip.
Function Expressions

There's another popular way to declare a function and immediately start in a variable. These are called function expressions. Let's see what they look like. So we already saw a function declaration right here. We use the function keyword, followed by the function name, and that's called a function declaration or a function statement. But it's also very common to create what's called a function expression, which is right here. We create a function with the function keyword. We have a parentheses and our code block, but all of this gets assigned to a variable using the let statement. So here fn is our new variable name, which stands for function. And to call this function, we simply use the variable with the opening and closing parentheses. And these are two common ways to define functions, a function declaration or a function expression. Here's our code from the last clip unless you changed this into a function expression. I'll say let my function = function, and the name of this function is optional. We don't need it, so I'll just take it out for now. And the way we would execute this function is through the variable name, myFunction. I'll save it, and we get our message showing. Now it is a best practice to give this function a name. It's not required, and often in code you don't see it. But if you give this function and name, debugging could be easier in the future. I'll just call it loggingFunction. And if there did happen to be an error in the future, it would show up in the stack trace. So with this name, I'll also save it, and we get the same message. Just remember that we can't use this function name. Let me just copy it, and let's try to call it directly. I'll save it, and we get an error. I'll resume that the debugger and go to the console. And you can see that it says loggingFunction is that defined. So this function named here is only for debugging purposes. If we wanted to call the function, we use the variable name myFunction. I'll save it, and we get our message. So whether or not you use function expressions as we see here or the other style, which is a function declaration, it has other names too. So sometimes it's called a function statement, and sometimes it's called a function definition. But no matter which style you choose, it's up to you if you want to use variables or if you want to directly call function names. So we've seen how to declare functions and use them. But many times, we need to pass information into a function, and that's what the parentheses are for. We'll learn about those in the next clip.
Passing Information to Functions

It's very useful to be able to pass information into a function; that way the function could work with whatever data you send it. Let's see some examples. So we're declaring a function, showMessage, but this time, between the opening and closing parentheses, we have what's called a function parameter, message, and you can think of message now as a variable. Whatever information we pass to this function will be stored in message. And of course, we use message like a variable, we console.log the value of message. So that's our function declaration, but let's call the function now. We call showMessage, and in the parentheses we pass it the string, First Message, and we'll call it again with another message, Second Message. So this way we can pass any information to showMessage, and it will be logged out to the console. And here's another example. If we look at showMessages, you can see that we have two parameters now, message and anotherMessage. It's important that they're separated by commas. So we can pass multiple types and values of information to a function just by listing several parameters separated by commas. This code just logs out message and anotherMessage. To call showMessages, we pass it the first argument. An argument is the actual value that we send to a function. So First Message is the argument and it gets stored in the parameter message, and we use a comma, and we pass another argument, Second Message, which gets stored in another message within the function. And we can have as many parameters and arguments as we'd like; just make sure that they're separated by commas. Let's take a look at this in Visual Studio Code. So here we have our function expression from earlier and let's add a parameter, message, and instead of logging out this string right here, we'll log out that new variable message, which is actually parameter, but it acts very much like a variable. Now when we call myFunction, we need to pass it an argument and I'll just pass it Hello for now, I'll save it, and we get Hello showing up in the console. Now we could have as many parameters as we'd like. Let's add one called firstName, and just to make room, I'll remove the optional function name here. So we'll log out message, and we'll log out firstName. Now of course, we'd need to pass an argument for that parameter, firstName, and I'll say, John. I'll save it and we get Hello, John. Now what happens if we accidentally or on purpose leave out this second argument here? So we're calling the function, but we're passing it one argument, Hello, but it's expecting two different arguments here, one in message and one in firstName. I'll save it and we get Hello and undefined as firstName. So if you don't supply values for all of the parameters, they'll be set to undefined. Likewise, if we didn't pass any arguments here to the function, we just left the opening and closing parentheses. I'll save it and we get undefined twice, and this is the source of many bugs. You always want to make sure that you're passing a function the correct values and the correct number of values. If you don't, the parameter values will be set to undefined. So that's how we send information into a function, but we can also get information out of the function, and we'll see that in the next clip.
Function Return Values

We saw how that when we create a function, we can specify parameters, and those are symbols to represent information coming into the function. We can also get information out of the function by using the return keyword. A function may or may not return a value. Let's see an example. We're declaring a function called getSecretCode, and there's one parameter, value. We create a new variable, code, and we set it to value * 42. And then we have our return statement that will return the value of code. And that's how we get information out of a function. And looking below, we can see the call to get secret code, and we're passing it the number 2. So just to follow this line by line, this will execute our function. Code will become 2 * 42, which is 84. and then we'll return 84. So this function call, you can think of it as getting replaced by the value 84. So when we call console.log, it'll show 84. And the key thing to remember is that the function, including the name and the parentheses, you can think of that as getting replaced by the return value. So you can use functions and mathematical expressions or anywhere that you would use a value, including as an argument as we see here. 84 is getting sent as an argument to console.log to print out. Let's see this in Visual Studio Code. Here's our code from the slide. I changed the console.log so that will show the message. I'll save it, and we get 84. That's what we expected. So getSecretCode, passing it a 2, value became 2, code became 2 * 42, which is 84, and then we returned code, the variable. So this is equivalent to calling showMessage, passing at 84. Let's see what happens if we forget to put a return statement. So I just comment this out for now, and in addition to showing the message, I'll console.log it. So I'll just log out another call to getSecretCode, passing it 2. I'll save it, and we'll take a look in the console. And we get undefined. So if a function does not have a return statement, it implicitly returns undefined So here we see an example where we're returning a variable, code. We could also return one of the parameters, value. Or we could return an expression itself. We could leave out the let statement and just return value * 42. I'll save it, and we get the same thing, 84. And it's really up to your coding style how you'd like to do this. I'll just reverse this. And to me, this looks a bit cleaner because we're creating a variable code, and we can follow this more easily. Likewise, this command here might look a little confusing. So one thing we could do is we could create a variable. We'l, let secretCode equal the call to getSecretCode, passing it 2. And then when we showMessage, we can just show secretCode. And this is equivalent to what we had. It just looks a little bit cleaner because we separated it out into two lines of code, and we're using a very clear variable name, secretCode. So it really depends upon your coding style. I would prefer this over putting the function call right here within showMessage, but it's up to you. The next thing we need to look at is function scope, and we'll look at that in the next clip.
Function Scope

Functions have their own scope. That means that the parameters and local variables to that function only exist within that function and sub functions. Once the function completes execution, any parameters and local variables disappear. Let's see an example. We have a function similar to what we saw before, it's called getSecretCode, and it's using a local variable. We're declaring code within this functions code block, and we're returning code, so we can go ahead and call this function just to make sure it executes. But what happens when we tried to log out code? Remember, code was declared within the function. We end up getting a reference error, code is undefined. So our code right here has no idea what happened in that function. Once the function completed execution, the variable code here no longer existed. So that's why Javascript doesn't even know that code existed. We call that being out of scope, so functions do have their own scope, and that's a good thing. That way we can encapsulate code and make sure it doesn't leak out into the surrounding code. Let's see some more examples. So here's our code from the last clip, we're declaring code right here within the function. Let's show message code and see what happens. I'll save it, and we get an error. It's paused in the debugger, so I'll resume. I'll go to the console, and we get the error that we thought we'd get, code is not defined. So functions have their own scope. Now what happens if we declare a variable outside the function before the function is defined? Let's let key = 42, and then within the function we'll execute value times key, and let's show message secretCode. So we want to see if key, which has declared outside the function, is accessible inside the function, right here. I'll save it. And it is. We get the value 84. So functions have access to the entire outer scope as long as there's a variable or something else defined outside the function, as we see with key right here, any newly declared functions can use it. But of course, this doesn't work the other way. When we have a local variable in the function called code, once this function finishes execution, code no longer exists. And you'll very often see nested functions. That's a function within another function. Let's create one here. We'll create a function expression, let keyGenerator equal a function, and for simplicity let's create a variable. We'll let key equal, this time let's say 12, and let's log that out. We'll say in keyGenerator, the function, and the value of key. And we'll go ahead and return key. Here instead of key, we'll call the function keyGenerator, and we don't pass it any arguments. But before we exit, let's console that log in getSecretCode and we'll show key. Let's see what we get. I'll save it and we get in keyGenerator 12. And that makes sense, because in our function here, we specifically set key equal to 12 and we returned it. However, in getSecretCode, it returns 42. So when we use the variable key right here, you have to remember that this function finished executing. So key no longer exists. This key refers to the outer key, which was defined outside of the function before it. And we get the 42 right here. So you always need to be aware of function scope. We're using the same variable name here as well as here. So you have to keep track, as a developer, of which variable is active. And if we use the same variable name within a function, that will override any variable outside of it with the exact same name. So the important takeaway here is that when a function finishes executing, all of its local variables, such as key right here, will disappear. And if something's declared in the global scope right here, it will always stick around because that's the outermost scope. And having functions nested within functions is very common in JavaScript. You should really work around with this and make lots of examples, because when you're looking at other people's code and other projects, you're sure to see functions nested in functions and nested in other functions. In the next clip, we'll take a look at the function we already created earlier in the course called showMessage, and we'll create some more functions that could be useful when changing a web page.
Using Functions to Modify Web Pages

Early on in this course, we actually created a function called showMessage, and that's what enabled us to write out a message directly to the web page. Let's take a look at that function. Let's start off by going to index.html, and I'll scroll down to right before the body tag. And this is where we added two scripts. Mostly we've been working in home.js, but you might have forgotten that we also added a utils.js. Let's look at that. I'll make some room, and I'll expand out the window because it's a long line, and we can see a function here. We're declaring a function using the function keyword, and it's called showMessage. And this is what we've been continually calling throughout this course is this function. Within the parentheses, we have one parameter, message. Now we still haven't learned a lot about objects in detail. We'll be learning about that in the next course module. But for now, just know that document is an object that refers to the whole web page, and we specify dot on the object, and we call a special kind of function on that object. Normally, you call a function that's attached to an object the method. But those terms are interchangeable. You can think of getElementById as a function, and we're passing it message. Then we access the textContent of that object, and we set it to message, our parameter. So whatever message we pass to showMessage becomes the textContent of the element with ID of message. And let's just look at our web page again. I'll go to index.html, and I'll search for get a grip right here. And you'll remember that we added the ID message so that we could access this h1 tag within JavaScript. Another thing we might want to change is this value here, 20% OFF. So let's give our h2 tag here another ID. Let's call it percent‑off. So remember the ID is percent‑off, and that's how we can access this element. So I'll save the HTML file, go back to utils.js, and let's create a new function to change the percent. We'll call the function changePercentOff, and we'll pass it the percentage. Now to change that line, we do it in a similar way as we've done in showMessage, document.getElementById, and remember the ID was percent‑off. And we want to access the textContent, and we want to set it to our parameter, percentage. But we want to set it to more than just that. We also want to add a percent sign and the word off, and I'll show you why we do that. If we look at index.html, you can see that the actual string is the percentage 20 and the percent symbol and off. So I'll just make sure we end this line with the semicolon, and I'll save it. But we're not executing this yet. Let's go ahead and we'll go back to home.js, and we'll execute this function, changePercentOff, changePercentOff, and let's pass it 30. I'll collapse the editor, and I'll save it. And now we get 30% off. If we change it to 32, I'll save it, we got 32% off. So now we're using a function to change our web page, and this could be very useful. There might be several places that we'd like to change on a web page, and we could do it all within one function. Remember these functions, they currently have just one line in the function body. But you could places many lines of code in here as you'd like. So we're just starting off changing our web page, but we have all the tools to work with that now. The last final piece of the puzzle is to learn a little bit more about objects, and then we can go ahead and start making big changes to our web pages. But as far as functions go, we know everything we need to know. Let's wrap up this module with the summary.
Summary

In this module, we learned all about functions. We saw had to declare a function, using the function keyword and then naming the function. We have parentheses for optional parameters and a body of code between curly braces. Another way we could declare a function is as a function expression. We use the function keyword and an optional name, here we don't have one, the parentheses and the curly braces for the code block. Ad we assign all of that to a variable so that we can reuse it and call it as needed. We saw how to pass information into a function. Basically, when we declare the function, we specify parameters. Here we have three parameters A, B and C. So when we call myFunction, we would pass these three values to be used within the function. Functions also return values. We use the return keyword and whatever value we'd like to return. It can be a variable, a parameter, any expression, a function call. But whatever we return, it's just a single value. We also looked at function scope. We saw how functions have their own variables, called local variables, that disappear once the function finishes execution. We also saw how functions can reach outside of themselves to the outer scope and retrieve variables there. And if you run into any kind of naming conflict, a function will always pick a variable in the local scope or closest to the local scope. Finally, we saw how to modify web pages by using functions. We've been using the showMessage function all along. It wasn't until now that we were able to explain it in more detail, but we saw how functions can be useful in modifying web pages. So that wraps up functions. The next big feature that we need to learn in order to truly modify web pages is the subject of objects. After all, a web page is one big object. And by learning about objects, we can learn to show or hide parts of the web page, respond to button clicks with events, and manipulate the page however we'd like. So in the next course module, we'll learn all about objects and the document object, which holds the web page. I'll see you there.
Objects and the DOM
Introduction

Hi, my name is Mark Zamoyta, and welcome to this module, Objects and the DOM. We've already took a quick look at objects, and we saw how an object can contain multiple properties or multiple values that are related, and what DOM stands for is Document Object Model. When we want to modify the web page in JavaScript, the key object we work with is called Document, and the DOM, or the Document Object Model, refers to that document object, along with all of its supporting objects and other features. So in this module we'll take a closer look at objects and programming web pages through the DOM. We'll start off by taking a closer look at object properties and object methods. Properties are similar to variables attached to the object, and methods are similar to functions attached to an object, and we'll be taking a closer look. Next we'll take a look at passing objects to functions. This doesn't always behave as expected, so we want to make sure we understand the difference between passing an object and passing something that's a value, such as a string. Next we'll look at some standard built‑in objects. We'll go to the Mozilla Developer Network and see how we can find out about these objects, and look at their documentation, and use them in some code. Next we'll look at the document object, which is part of the Document Object Model, the DOM, and we'll see how we can use that to modify web pages. We'll see how to style DOM elements. Normally you would use a CSS file, but you could also do this through JavaScript. And we'll take a look at how we can handle button clicks or any other event that occurs on a website. And finally, we'll see how we can show and hide DOM elements. We'll be working with CSS classes for this. So let's get started and take a look at object properties.
Object Properties

Objects usually have several properties. If you think of a real world object such as a car, some of its properties might be the number of doors, the engine size, would type of fuel it takes, and so on. So you can think of an object as a group of values or properties. Here's how we create an object in JavaScript. We use the curly braces. You need the opening and closing curly braces. And we don't have any properties listed here, but you can see that this empty object is being assigned to a new variable called person. Let's see how we add properties. So between the curly braces, we enter a property name, a colon, and a value. So person has a property name and we're setting its value to John. And for multiple properties, we need to separate those by commas. We have a property age that we're setting to the number 32. Notice there's no quotes, so we know it's a number, comma, and a new property, partTime, which were setting to false, a boolean value. So, as you can see, these properties can have any data type. You can even have objects inside other objects. If you want. That's very common. But once we have an object, let's see how we access these properties. Here's our object we just created, and we're logging out person dot, this is called a dot syntax. You specify the object and a dot and a property name. So person.name will be John, person.age will be 32, and person.partTime will be false. Let's go to Visual Studio Code and see this in action. Here's our person object, we're using the same values from the slides, and we'll show message person.name. So the person object.property name, which should be John. I'll save it, and we get John. Likewise, if we specified age, I'll save it, and we get 32. But you need to be careful that you access actual properties. What if we tried to access a property that doesn't exist, such as country? I'll save it. And we didn't an error because the debugger didn't kick in. But it looks like we have an undefined value. So when you're working with objects, you need to be very sure that you're working with the exact property names that do exist. Objects can be changed easily. Let's say we wanted to change the age to 33. We're working with our person variable, so we can say person.age and we could just assign a new value to it. So we'll assign 33. We'll show message person.age just to make sure it works, and we get 33. So here we're using the dot syntax on an object to access a property. But there's another way. We can use square brackets. The property name needs to be a string. So we have our square bracket and then age as a string, and we end off the square bracket. And I'll just set this to 44, just to make sure it changes. I'll save it. And we can see that that works fine. So we can use the dot notation, as we see here, or we can use the square bracket notation, as we see here. Earlier in this course, I mentioned the special data type called a symbol, and that's more of an advanced data type, but just to briefly describe it again, let's create a symbol here before our object, I'll call it my symbol. And this is how we create a new symbol with this syntax. And a symbol can be used inside of an object to hide information. So I'll use the square bracket notation here and enter my symbol. I'm not using quotes because it's a variable name. And we can set some kind of custom information that only we can get access to. And this is an advanced scenario. This would be used in cases where, say, you're working with an HR system that wanted to hide salary information, or you're working with some kind of plugin architecture where each plugin had its own secret information specific to that plugin. So I won't go into too much detail on that here. But basically with this symbol attached, we can pass around person as an object. But the only code that would be able to access this property here would be code which had access to my symbol. So that's the basics on properties. In the next clip we'll take a look at methods. Methods are simply functions that get attached to objects, and we'll learn about those in the next clip.
Object Methods

We've seen how an object can be composed of data. Those are the object's properties. But we can also attach functions directly to objects, and those functions are called methods. Let's see how we do this. Here's our simple person object, and let's add a method to it. We'll add a new property, and we'll call it show info for show information about this person. But instead of setting it to some value, we'll set it to a function. And we won't take any parameters here. But we can go ahead and make the function body and add whatever source code we'd like. So within here, let's showMessage, and we can say in showInfo. And, of course, we could add as many lines of code as we'd like here. So instead of calling showMessage, I'll just call person.showInfo. When this executes, it'll call this function and show the message. I'll save it, and we get in showInfo. So this is working great. But one thing that's very common in these methods is accessing the data within the object. So instead of showing this static string here, let's show name. But the problem is that this function is unaware of what name is. Let's save it and see what we get. We get some kind of confusing bootstrap code because name probably belongs in the bootstrap namespace. So what we do to access information within an object is we use the this keyword, and this refers to the current object. So we're working with this person object, so this.name refers to John right here. I'll save this, and we get John as we expect. Now it's very easy to forget to put the this keyword on properties. So as soon as you start getting undefined values that are actually defined or things aren't working the way they should be, just make sure that you put this. property name to work with the current object. And we could say something like this.name + the string is + this.age to get the age value. John is 32. And, of course, because this is a function, you could have a return value and we could also have parameters. Let's put a parameter realAge, and we'll pass it 34. And I'll just log out the realAge rather than the object's age. I'll save it, and it says John is 34 now. So we would call showInfo a method because it's part of an object. But some developers might still refer to it as a function. And that's fine too because within JavaScript, it really is a function. One thing we can do here is we can showMessage typeof person.showInfo. And I'll save it, and you can see that person.showInfo is a function. But because it's attached to an object, it's traditionally called a method. In the next clip we'll take a look at passing objects to functions. There are a few tricky things about that.
Passing Objects to Functions

There's a very big difference between passing an object to a function and passing a built‑in type such as a string, a number, or a Boolean value to a function. This is the source of a lot of problems and a lot of bugs. So let's take a look at what I'm talking about. Let's look at this example code right here. We're setting message, a new variable, equal to Hello. We're creating a function called changeMessage, which takes the message and just changes that message too Hi! It doesn't return anything. All it does is it changes message too Hi! And then we execute changeMessage, and we'll pass it the message. Hello. And then we'll showMessage message. So what do you think is going to show? Is it going to be Hello, or is it going to be Hi? I'll save it and we'll find out. We get Hello. So when we call changeMessage, passing it message right here, it actually took the value of Hello and stored it in the parameter, message. And then this line in the function only changed the parameter. It didn't change our original variable message. So by the time we call showMessage, we're still working with our original message variable. So we're passing this argument message by its value. The new value gets stored in the parameter, and changes to that parameter have no effect on later code. Now I'm showing this here because it's very different than the way objects work. Let me paste an example of code using an object. Let's look at this example here. We have our simple person object with a name, age, and partTime value, and we're creating a function called incrementAge. We're passing it person, so you want to add e to the age. So we call person.age++. That's the increment operator that will increment age by 1. So at this point in the code, age should be 33, and then we leave the function, and we'll showMessage(person.age). Do you think we'll get 32 or 33? I'll save it, and we get 33. So this is very different than the string example we just saw. Because we're passing an object to increment age, when we access properties or methods on that object, we are able to change them. We can't change the person object itself as an object, but we can access all of its properties, sub‑properties, and methods. And this is called passing by reference. When we call incrementAge here, passing it person, it's as if we're passing a pointer to that person. And we do get access to all of the real properties and methods. Even if we change the name here to something like simply p for a person, the fact that the parameter named changed has no difference. I'll save it, and we still get 33. So just be aware that when we pass objects, we are able to modify their properties and methods. But when we pass some data by value such as a string or a number or a Boolean value, any changes made to those will be lost. So it's really worth making a lot of examples when you're playing around with this. Practice sending values to functions and practice sending objects to functions. And make sure you see how they work because they're very different. Again when you pass an object, that function has free access to change all of its properties and methods. In the next clip, we'll take a look at some of the popular built‑in objects in JavaScript.
Standard Built-in Objects

Now that we know the basics of objects, it would be a good time to take a look at JavaScript standard built‑in objects. We've already been using these, but let's take a look in more detail. I'm at the Mozilla Developer Network, MDN, and I searched for standard built‑in objects. These are great objects that we have access to in JavaScript that really make our lives easier. Let's take a look at some of them. I'll scroll down, and if we look on the left side, you can see this Built‑in objects section. I'm not going to go through all of these, but just to mention a arrays quickly, we're going to be covering arrays in the next course module. But an array is basically a group of objects or a group of values. For example, we saw a person object, but what if you have a whole team of people? You might have 20 people, and you would store those in an array. But we'll be looking at that shortly. Looking down this list a bit, we can see the date object. Let's look at that. It's extremely common to be working with dates, and you can read all about them here. If we scroll down, we can see that there are lots of methods attached to dates. You'll notice this prototype property here, and that would be explained in a more advanced course on JavaScript objects. But just know that whenever we have a date object, we can access anything on the prototype. So the important parts are here. These are the methods that we can use on any date. For example, if you wanted to get the number of minutes out of a date, you could use this method. Or to get just the time section of the date variable, you could call this. But looking at this syntax here, this is how we get the current date. And we can store that in a variable and work with these methods. And I'll scroll down a bit more, and we have a method toDateString. That will convert a date into a string. Let's just quickly take a look at how to work with dates. I'll create a new date variable, and I'll just call it now, and we say new Date with the opening and closing parentheses. And to turn that into a string, we can say now.toDateString with the opening and closing parentheses. So I'll save this, and the date comes up, Thursday, December 19th, 2019. But the key thing I wanted to point out is this is how we get the current date and store it in a variable. Going back to the website, we can now use that variable and call all of these methods. There are a lot of them. So to move on to the next built‑in object I wanted to show you, I'll scroll down from date, and we see math right here. I'll go there, and I'll scroll down, and we can look at some properties on math. There's a property called pi. If you wanted to get access to the value of pi, you would just specify this exact string Math.PI. But there are many, many methods. The first one is for an absolute value, and you can see that we have access to a whole lot of methods. One useful method is Math.random. This would be useful in creating random numbers for games or graphics or something like that. And we have extremely popular formulas, such as square root. And to round a number, we could use Math.round And notice that these aren't attached to that prototype property we saw. They're directly on Math. So just going to the top of the list, let's just use Math.abs for absolute value. I'll remove the date code we were working with. And let's just showMessage Math.abs for absolute value, and we'll put it in a ‑42. I'll save it, and we get 42. If you're not familiar with absolute value, it just removes the negative sign. Likewise for Math.random. I'll save it, and we get a decimal number. So go ahead and read all of the documentation on whatever method you'd be interested in for your formulas and for your code. I'll go back. And if we scroll down a bit more, we can see string. We've already seen a property and a bunch of methods on string, but let's take a look at the documentation now. Here's the property we looked at. We saw that when we had a string variable, we could call the length property to get the number of characters in the string. But then we have all these methods. Just be aware that we have some of these thumbs down symbols over here, which means that these methods are deprecated. We shouldn't really be using them because they might disappear in the future. But something like charAt for characterAt is extremely useful. This gives us the character at a specific index within the string. Let's take a look at that. So let's create a string Hello, and we'll log out s.charAt for a characterAt, and we'll say index 0. You can see that we're getting help from Visual Studio Code here. It's telling us what argument it's expecting. It's a position, a number. So I'll put 0, and I'll save it. And we get the H, which is position 0 in hello. Remember, positioning starts at 0, not 1. So if we wanted to get the e in hello, that would be charAt 1. I'll save it, and we get the e. And there are dozens of these methods that we can use with strings. So be sure to read through this documentation and mind that we have these deprecated methods that you can ignore. But string methods are something that developers use pretty much every day. So it's good to be aware of all these. And finally, the last object I wanted to show you after string was the number object right here. We've worked with numbers a little bit. And if we look at the properties, we've seen one called not a number, NaN. So we could compare a number variable to NaN by using this property right here number.NaN. Likewise, there are values for positive infinity and negative infinity and the min value for a number and the max value for a number. Those could come in useful in certain calculations, but the methods are used very commonly. We can test if a number is not a number by using this method right here, and we've already seen how we can call parseFloat to take a string and parse a float number out of it. Likewise, we saw toFixed where we have the number rounded to a fixed number of decimal places. But numbers are used very often, and reading through these and understanding these methods and properties is very useful. So that's all I wanted to show you for now. This is an introductory course. But many of the other Pluralsight courses will go through a lot of these built‑in objects. Again, you go to the MDN, Mozilla Developer Network, and you can search for standard built‑in objects.
The Document Object Model (DOM)

The most popular use of JavaScript has been as a scripting language behind web pages, but we can also use JavaScript now with technologies such as Node.js to run JavaScript on the server, and with technologies such as Cordova, we can run JavaScript apps on mobile devices and tablets. But this clip and the next few clips, are going to focus mainly on browser programming. One of the biggest objects we're going to work with as far as user interface goes, is the web page itself, and that web page is built up of objects. This is commonly referred to as the Document Object Model or the DOM. You would say that you would program the DOM, and that refers to modifying the web page and getting events from a user using the web page, events such as a user typing and information or clicking a button, but all of this is controlled by the DOM, and we've actually already been using this to a very small degree. So let's take a look at our code again. I'll open up the Explorer and we'll go to utils.js, and if we look at our showMessage function, we've used this throughout the whole course, and it actually uses the DOM. Document here represents the web page as a document, and that's the JavaScript object, and this object has a method. You can see the dot and the method name getElementById. So this method returns another DOM object, which has a property called textContent, and that's the text that we see on the web page. So we can finally explain how this function works. We have an object and a method, which returns another object, which has a property called textContent, and we set that to the parameter message. And our other function works exactly the same way. We use document as the web page that has a method, which returns an object, which has a property, textContent. So document is the built‑in object that refers to the web page. I'm back at MDN, and I searched for a document object model, and there really is a lot of documentation on this. If we scroll down, we can see what are called DOM interfaces, which are what relate to objects that we can work with in JavaScript, but this is really beyond the scope of this course. So for this clip and the next few clips, I'm just going to point out a few key features that we commonly use when working with the DOM, and one is this object here, element, and element is basically a tag in the markup. Let's go to the code and see that. Looking at index.html, I'll search for get a grip. Here it is. And we can see this h1 tag right here. That's called an element. And we can access this element by its id, message. Likewise, this h2 tag here, we could access that by its id, percent‑off, but what we want in JavaScript is the object that represents this element. And we saw how we can get that. I'll go back to utils.js, and the way to get an element is by calling this method on document. We call GetElementById, passing it the id, message. And once we have that element object, we can access the text content property to set the text. So this shows us how to access the web page with document, and one of the more common methods is this GetElementById method. Another thing we could do is style this element, and we'll take a look at that in the next clip.
Styling DOM Elements

Normally we would style a web page using a CSS file or some pre‑processor technology such as Less or Sass, but occasionally we want control in JavaScript, where we can style the elements ourselves with code. I'm here at MDN again, and I searched for HTML element. In our code when we called get element by id, this is what we got in return, an object of type HTML element, and this is a very big object. If we take a look here, there are very many properties, and if we keep scrolling down, we'll get to a property called style, and that's the property that lets us overwrite CSS values. I'll click on it, and you can read here about working with this style property. And we'll just work with this simple style here. Let's say we have an element dot style property dot CSS property, and we're setting it to the value blue. So it's very simple to set a style. We just need to know the CSS property, in this case color, but we could use any property. So let me grab the element. I'll create a constant. We'll call it header document.getElementById, and we know that the get a grip string has an id of message. And now that we have our header, I can access the style property, and let's set the color to red. I'll save it, and it turns red. Likewise, we can turn it any color. I'll make it blue, or of course, we can set a hex value. Now it's white. And the only really tricky thing about this is that CSS properties sometimes have a dash in the name and we can't do that. Let's say we wanted to work with the font weight. Normally the CSS property would be font‑weight, but that doesn't work in JavaScript, because we're not allowed to have a dash in any kind of name. So instead we use CamelCase. We say font as usual, lowercase, and then Weight, which starts with an uppercase letter, and you can see here that Visual Studio Code is helping us out. Font weight is what we want, and we'll just set this to thin. I'll put a value of 100, and you can see we have a thin weight, or I can just bump it up to 800. I'll save it and it becomes bold. So we can easily override any CSS settings in JavaScript. You get the element and you access the style property, and you access the CSS property in CamelCase, and if you're working with the units, such as a percent or pixels, make sure you specify that as well in the value. In the next clip, we'll take a look at how we can detect when a user interacts with the web page through a button.
Detecting Button Clicks

In JavaScript, there are often times when we want to know if a user interacts with a web page, and a simple interaction simply has to do with clicking a button. Let's see how we can detect this in JavaScript and execute some code when it happens. If we look at the website, I'll scroll down a bit until we see a button. Here's the button See Review, and when I click on it, it seems to just refresh in place. So let's find this button in our markup. I'll go to index.html. I'll search for See Review, and we have See Review right here. I'll open up the editor, and we can see that this is an anchor tag, not a button, but we can still process click events on it; that's fine. It has a class of button for Bootstrap, and that's what makes it look like a button. The first thing we need to do is get rid of this href. That's what's making it update in place. When we click it, it just refreshes the page. So I'll remove that, and we'll handle the click in JavaScript instead of with the href attribute. So we need to give this anchor tag an id, and we'll just call it See Review, and I'll see this. And let's go to our home.javascript file and get this element. We'll get it by calling getElementById and we'll pass it see‑review. So we'll just call it button, and we want to getElementById see‑review. Now, once we have this button or anchor tag or whatever element it is, we call a method called addEventListener, and we pass it two different arguments. The first one is the event that we want to listen for. Web pages have hundreds of events, but we're interested in click. We want to know when this button or link is clicked. And the second argument is a function, and this is similar to a function expression. It's actually called an anonymous function where we won't give it a name, but we will specify the opening and closing parentheses and the curly braces for the function body. And in this function body, I'll simply log out, click. So again, what this code does is it watches button or a click event, and when that click happens, this function executes. It'll log out and click to the console. So I'll save this, and I'll open up the console, and here's our button; I'll click it, and click appears in the console. If I click it multiple times, you can see the number to the left of the text increasing. So we're intercepting our button click, and we can execute any code we'd like. We can call functions. We can call methods on DOM objects, and modify this page however we'd like. So probably since this button is called See Review, one thing we could do is we can pop up a review underneath it as part of the web page, and we'll look at how we can do that in the next clip.
Showing and Hiding DOM Elements

Let's take a look at how we can use our button click to show and hide DOM elements. It'll act as a toggle button. This is a very common operation when you're working with JavaScript and HTML. So here's our button that says, See Review and what we'll do is we'll add a panel just below it that is the actual review that we want to see. So I added some simple markup for this. Let me search for see review so we can find the button, and it's right here. Let me expand this. And I added this markup right here. It's a simple div with an id of review, and that's how we'll access this. We'll call get element by id, passing it review. And for classes, it has a bootstrap container, and also a bootstrap class d‑none, that stands for display none, so it won't be visible at first. It'll be hidden. And it simply has a review title and some review text. And our main purpose is to toggle this div on and off by clicking the button, and the button is right here with the id of see‑review, the same button we worked with in the last clip. So the key thing to remember is that it has an id of review right here. I'll go to home.js. Here's our code from the last clip where we're taking button and we're going to be listening for the click event and executing this function on a click event. The first thing we want to do is we want to grab that review div. I'll call it review and we'll call document.getElementById, and review is the name. So just to start off, what will do is we know that that element is hidden. So let's show it, review dot, and we want to access the classes for this element, and that's found in a property called classList, and on classList we have other properties and methods, and what we want to do is we want to remove that d‑none class. So I'll put dot remove, and the class we want to remove is d‑none. So now when we click this button, it'll remove the d‑none class, and we should be able to see that review. Let's take a look at it. I'll save the code and I'll click the See Review button, and our review div does show up right here, so we successfully removed the d‑none class. But let's turn this into a toggle switch. If we click it again, we want to remove it. In order to do that, we need a conditional. We need an if statement. If review.classList dot, and we can call contains, this is a method that lets us know if a certain class exists on the element. So if it contains d‑none, that will return true, else if it doesn't contain d‑ none, we'll execute this block. So I'll move this code to the right place now, and in our else block, I'll paste it, but we don't want to call remove, we want to call add. We want to add it back. So just to walk through this again, if our element contains the class d‑none, we want to remove it, else we want to add it back. I'll save it and let's see if the toggle works. We have See Review, I'll click it, and a review shows up. I'll click it again, and it hides. So the one last thing I want to do is just change the text of the button so that when we click it, it should now say Close Review so that the panel closes. And we can simply add some more code into these blocks here. So when we're showing the review, we still have access to button because it's in an outer scope. So I'll say button dot, and we want to access the text, so that would be the text content property equals, and let's say, CLOSE REVIEW. And in the else clause, we want it to be the same thing, button.textContent, and we want to set that to SEE REVIEW. I'll save it and we'll check out our toggle switch. We see the review and the text is updated in the button to Close Review. I'll hit it again, and it's back to See Review, and the review disappeared, So everything's working fine. The subject of DOM programming is a very big one, but this is definitely enough to get you started. You can use MDN to find out all about the DOM objects and events like we've been handling the click event, but there are lots of other events that you can work with, and you can check out Pluralsight for other courses on the DOM as well. And that wraps up our discussion on objects. So next we'll close out this module with summary.
Summary

We started this course module by looking at object properties and methods. We saw that there were two way to access properties. Object using the dot notation, object.propertyName, or we could use the square bracket notation. We specify the object without the dot and instead use square brackets. But the property name must be a string. Next, we took a look at passing objects to functions. We saw how functions can change an object's properties and methods. An object is passed by reference, so its members can change. And that's very different than passing a Boolean value or a number or a string, where if that value changes, it does not change in the calling function. Next, we looked at some standard built‑in objects. We went to the Mozilla Developer Network and we took a look at date, math, string, number, and we saw the whole list of available built‑in objects. And because of the large number of these objects and their properties and methods, you want to be sure to visit the Mozilla Developer Network to find out more information or to use that as a lookup reference. Next, we looked at the document object model, the DOM. We saw how JavaScript has a built‑in object, document, that we can use to find elements and modify web pages in a variety of ways. Next we looked at styling DOM elements. Once we have an element, we access the style property dot, and then the CSS property. And you just have to remember that the CSS property cannot contain dashes as they do in CSS files. So we have to use camel case as we see here. Anything after a dash would be capitalized, and the dash removed. And we simply set that property to its value. We saw how to detect button clicks. Once we have the element, we call addEventListener and we pass it the event we want to listen for, in this case it was a click, but it could be any DOM event, and we pass it a function. The function gets called when the event occurs. Finally, we looked at how we can show and hide DOM elements, and we did this by using classes. Once we have the element, we can access a property called classList, which manages all of the classes on that element, and we can call the add method to add a class name. Likewise, we can call the remove method, specifying which class name we would like to remove from that element, and we also looked at the contains method. This returns a Boolean value, whether or not the class name exists on the element. So that wraps up everything we're going to cover on objects. In the next course module, we're going to be working with arrays. An array can handle multiple objects or multiple values, so we'll see how to work with them. And we'll see how to modify a web page based upon an array. I'll see you in the next module.
Arrays
Introduction

Hi. My name is Mark Zamoyta, and this module is titled Arrays. Arrays are used to hold multiple objects or multiple values, and they're extremely popular in JavaScript. If you have a shopping cart application, you probably want more than one item in your shopping cart. In that case, you would use arrays. If you have an automobile application and your cars have more than one wheel, you might want to store the wheels in an array. So we'll learn all about how to use them in this module. We'll start off by looking at the JavaScript syntax to create and initialize the arrays. Next, we'll look at how we can access array items. The items in an array are referred to as elements. That's the technical term. We'll see how to manipulate arrays. There are many methods that we can call on arrays, and some of those specific methods are slice and splice. We'll go into those in detail. And we'll take a look at how we can search for items in an array and loop through the elements of an array. Finally, we'll take a quick look at working with the rays in the DOM. We want to be able to manipulate web pages based on data stored in an array. So let's get started and see the syntax to create and initialize arrays.
Creating and Initializing Arrays

Arrays are objects that can hold multiple values or objects. So we want to be able to create these arrays and initialize them with some kind of values to start with. To create an array, we simply use square brackets as we see here. We're creating a new variable called values, and because of the square brackets, values will be an array, but it'll be empty. It has no values inside of it. So let's see how we can initialize it at the same time we create it. In this example, you can see that we have three values 1, 2, and 3 inside the square brackets. So now we're creating and initializing the array to these three values. Each item inside an array is called an element. So you would say values has three elements. And this is the simplest, most common way of creating arrays. But you could also create it with some code. Let's see the next example. So here we're using the Array object with a capital A, and we're calling a method on that called of. So we're creating an array of three values 1, 2, and three. And we're assigning it to the new variable values. I prefer to use the square brackets, but feel free to use this method call as well. Let's go to Visual Studio Code and see this in action. So I'll create an array, and we start off by declaring a variable. I'll create a constant called values. And using the square bracket notation we just saw, let's add the values A, B and C. Notice here that we're using strings. You could have any data type inside of an array. In the slides, we saw numbers, and here we see strings, and you can even mix and match different data types. But it's a best practice to always use the same data type within an array. It makes things much simpler. So we're creating our array. And now let's log out values. I'll save it. And when we look in the console, we can see the array. This 3 in parentheses means that the array has three elements, and we see the square brackets showing the elements inside of the array. But this is just a shorthand notation. If you wanted to look into it more deeply, we can click on the triangle to open up this line. And here we can see that the first element, a, has an index of 0. So always remember that when we're talking about elements in an array, we start counting with 0. Element b is at index 1. And element c is that index 2, and the length is 3. Now an array is actually an object. Let's log out typeof values. I'll save it, and we get object. So an array is not a built‑in data type. If you wanted to find out if a variable was an array, there's a method we can use. The method is on the Array object with a capital A, and the method is isArray. And I'll pass it values I'll save it. And looking in the console, we get true. So values is an array, and that function might come in useful. Let's quickly take a look at MDN and see how we can find a lot more methods that are attached to the Array object. I'm at the Mozilla Developer Network, and I searched for array. We can scroll down, and here we see the properties. By far the most common property is length where we get the number of elements in the array. But then we have a wide range of methods. You see the method we just used right here, Array.isArray. And we also use this one, Array.of. That's what let us create and initialize an array at the same time. But once we have a variable that holds an array, we can access all these methods, and we'll be taking a look at several of these throughout this course. But you may want to check out this documentation in detail because there's really a lot to arrays. They have a lot more features and methods than we can cover in this course. Again, it's at the Mozilla Developer Network and search for array. In the next clip, we'll take a look at how we can access the elements of an array.
Accessing Array Items

Let's see how we can access array items. And again, array items are generally referred to you as elements, but we might want to pull out an element to look at it, or we might want to change an element. Let's see the syntax for this. So we're creating an array called values, and it has three elements, the strings a, b, and c. Now to access the first element, a, we use square brackets on values and the index of 0. Always remember that arrays are 0‑based when it comes to indexing. So values bracket 0 is equal to a. And values 1 would be b, and values 2 would be c. Now if we specify an index that's outside of the range of the array, we'll get undefined. So values 3 is undefined. Let's look at this in code. So, like in the slide, let's access one of these elements. I'll say values square brackets and 0. I'll save it, and we get a in the console. That's that index 0. And c would not be index three. You got to remember that we start counting at 0. So the c is actually at index 2. To verify that, we'll look at values 2, and it's c. And, of course, if we go out of range and look at some index that we know we don't have, I'll save it, and we get undefined in the console. Another thing we could do is we can use this bracket notation on the array in order to change one of the elements. So I'll go back to looking at value 0. We know that's a. But let's change it. Let's set values index 0. We'll set that equal to, say, aaa. I'll save it, and we get aaa. So we can easily change any value in the array using this bracket notation. In the the next clip, we'll take a look at how we can very easily add elements to the beginning or end of the array and also take elements off the beginning or end of the array.
Manipulating Arrays

In this clip and the next few clips, we'll take a look at different ways to manipulate arrays. Generally, these are done with methods on the array. Let's take a look at the first method. Push is a method on an array that adds items to the end of the array. So in this code, we're creating values as a three‑element array, and then we're executing values.push, and we're passing it the element that we want to add to the end of the array, the letter d. When we log out values, we get a, b, c, and d. This is an extremely common method. It's probably one of the most common methods I use on arrays. The next method is pop, which takes the last element off of an array. It's also extremely common to use this one. So we create our values array, and then we execute values.pop. That'll take the last element, in this case c, off of the array, and store it in the variable last. When we log out last, we get c. So we saw push and pop, which work on the end of the array. Push puts an element on the end, and pop takes an element off the then, but we can also work with the beginning of the array. We can you shift. Shift moves the entire array. You can think of shift as shifting the entire array to the left one element, and it takes the first element off the array. So here we're calling values.shift, and we're assigning the result of that to first. The result will be the first element of the array, the letter a. And that's what we get when we log it out, but after this executes, the array will only contain two values, b and c. And the opposite of shift is unshift. Here we're starting with an array with values b and c, and we call values.unshift, passing it a. So this adds the letter a to the beginning of the array. When we log out values, we get a, b, and c. So let's work with these four functions in code. Let's start by looking at the push function. I'll execute values.push, and to add an element to the end of the array, we just specified the element, and I'll log out values. Now we get the values a, b, c and d.. But push can take more than just one argument. Let's also pass it e and f. I'll save it, and you can see that for each argument we send to the function push, each one gets placed on the array, so you can push one or more values. And let's look at the pop method. And pop will take the value off the end of the array, so let's assign that to a variable. I'll create a variable called last, and after I log out values, I'll specify a comma, and we'll see the last value. I'll save it. So our values are a and b, and the variable last is set to c. It popped off the last value. Next, let's take a look at shift. And instead of last, this will take off the first element of the array, so let's just rename this variable, and we'll log out first as well. I'll save it. So after we call shift, the new array is set to b and c, and are variable first is set to a. So shift works on the beginning element of the array. Likewise, we have unshift, and we don't need to assign that to anything because that'll add a value on to the array. Let's unshift the string hello, and we'll just log out values. I'll save it. And our new array is set to hello, a, b, c. And similar to push, we could add more arguments here, we'll say, hello, world. I'll save it. And both of those elements are now in the array, hello, world, and then a, b, c. So that covers working with the front and the end of the array, but sometimes we want to work with items in the middle of the array to insert or delete somewhere inside the array. We'll take a look at that in the next clip.
slice() and splice()

There are two more methods that are extremely common when you're working with arrays. Slice and splice. Slice creates a brand new array that's based upon some slice of an original array, and splice is used to insert or delete elements somewhere within the array, not just the beginning or end, as we saw in the prior clip. Let's see some examples. So first we'll look at slice. We're setting values to a new array of a, b, and c. Then we execute values.slice and we have two arguments. The first argument is where we want to start to take our slice, which is element 1. And remember, element 1 is b. It's not a, a is element 0. And then 2 gives us the ending element that we want to look at, which is, 2, in which case that would be c. So this line actually creates a new array, and that new array is stored in the variable newValues. When we log out newValues, we get our slice, which is only item b. The item at index 2, the end position is not included in the results, and it's important to remember that even though we took a slice, it left the original array the same. It essentially made a copy of that slice of the array without altering the original. Next, we'll look at splice, and we'll specifically look at splice for deleting. So we have our values array set up to a, b and c, and we execute values.splice with two arguments. The first argument is the index of the element we want to delete, and the second argument is the number of items we want to delete. So index 1 is the b, and let's just delete that b by specifying one item. When we log out values, we get a and c. The b is gone. And splice can also be used for inserting. So we're working with the same array here, values, but we're executing values.splice, 1 refers to the index where we want to start inserting or deleting, which would be the b or right before the b, between the and the b. That would be the new index 1 if we inserted something, and then 0 specifies the number of items we want to delete. In this case it's 0. We don't want to delete anything here. We just want to insert the next argument, which is foo. When we log out values, we get a. foo, b, and c. So again, the three arguments to splice, the first one is a 1, and that's our starting index location. The second one is the amount of items we wanted to delete. Here we don't want it delete anything. And then the third and on up arguments are all values that get inserted into the array. So let's take a look at slice and splice in Visual Studio Code. So we have values set up as an array of a, b, c, d and e. Let's take a slice of the middle three letters. I'll execute values.slice and we want to start at index 1, that will be the b. And the second argument is the index of the end of our array, where we want to take the slice. But notice this note here in the help in Visual Studio Code. This is exclusive of the element at the index end. So if we wanted to grab b, c, and d, we would have to pass the index of e, and e will be excluded. That index is 4. And this will return a new array. So let's create a new variable. I'll call it newValues. And we'll log out newValues. I'll save it, and we get b, c and d. Another thing that we can do with slice is not pass it any arguments. I'll take those out, and because we're not passing anything, it'll make a copy of the array. I'll save it and we get the array a, b, c, d, and e. And just to prove that the original array does not get altered, let's take a slice out of this one, out of values, and then instead of logging newValues, let's log out the original array. I'll save it. And you can see that the original array did not change. We still have all five elements. Now let's take a look at splice. These have very similar names, but we just add a P after the S, splice. So the first argument is the starting index. Let's say we want to delete the letter c out of this array. That's index 2, so I'll specify a 2. And then the second argument, as we can see here in the help, is the deleteCount. How many items do we want to delete? Let's just delete one, we'll delete the c. And this will alter the original array, so I won't look at the return value, I'll just alter values and then log values out. I'll save it. And now we can see that the c is missing. We deleted it. If we change, the second argument to 2, we'll delete 2 elements. So now we deleted c and d, but we still have e. Now remember, splice can delete, but it can also insert. We still use this delete count argument. Let's just set it to zero. So now index 2 refers to c, but we're not going to delete it. We're just going to insert a new value. Let's just insert hello. I'll save it. And our new array is a, b, hello, c, d. So we inserted hello. Now, if we wanted to delete that c value, we can specify a delete count of 1. So we're starting at the second index and we're going to delete one element and then add hello. I'll save it and we get a, b, hello, d, and e. Notice that c has been deleted. So that's all we're going to cover for modifying arrays. You can learn a lot more at the MDN web page if you search for array. In the next clip, we'll take a look at searching and looping through arrays.
Array Searching and Looping

Many times we'll want to search through an array and find the index of some element. And sometimes this involves looping. Some of the array methods will loop for you, but then sometimes you want to get control over looping. You might want to perform some action on each element in an array. Or maybe you have a complex search, like you might need to dig into an object and do some kind of calculation to see if an element matches what you're looking for. So let's look at some of the methods that can accomplish these things. IndexOf is a method that lets us get the index of a certain value in an array. We're setting up a values array, and we're executing values.indexOf, passing it the string c, and that will return an index of 2 because that's where c's at. But what if we search for something that doesn't exist in the array? Here we're searching for values.indexOf d, which doesn't exist. We'll get a ‑1. Remember, we don't get undefined. Negative one shows us that we did the search and nothing came up. There's a filter method that's another way of searching through an array and creating a new array on values that fits some kind of criteria you're looking for. This is a little bit more complex, we'll see why. So we start off with our values and we want to execute values.filter. We want to go through this entire array item by item, and create a new array based upon whether or not the item matches some criteria. So for this filter method, we actually pass it a function. And the function has a parameter, item, which will be set one by one to each element of the array. So the first time this function is called, item will be a, and then the second time it will be called the item will be b, and so on. And the function returns either true or false. We're checking if item is greater than b, alphabetically. So filter will create a new array. And if we return true, the element stored in item will be added to the array. So when we log out set, which is our new variable, we only get c, because the only item that's greater than b is c. So the real powerful and interesting thing here is that we're passing a function to a method, and for each element in the array, the function will get called, having items set to that element. There's another similar method called find, that'll look through each element of the array and find the first item that matches some criteria. So for this example, we have values and array set to a and then a triple b, and then a c. Those are the three elements. Then we execute values.find. And again, the argument to find is a function. So for each element in values, this function will be called once. The first time it's called item will be a, the second time it's called the item will be the Triple b. Then the third time it's called the item will be c. And we're trying to find an item that matches some criteria. So we want to return true or false. If the item.length is greater than 1, we'll return true. And then that value would be stored in the found variable. When we log out found, the only item whose length is greater than 1 is the bbb item. So that's what we ge. And, again, when you're working in JavaScript, it's very common to be passing functions around like this. There are a lot of methods that take functions as arguments. So this function will be called until it returns true, in which case we found our item. And there's one other similar method that we can take a look at on arrays, for each. For each lets us execute a function on each element of an array. So we have our values array set up, and then we execute values.forEach again, passing in a function. So for each element in the array, this function is called once. The first time item will be set for a, the second time it'll be set to b, and so on. And we're simply logging out each item. So it'll log out a, b, and c. Let's take a look at these in Visual Studio Code. So looking at the indexOf method, we're executing values.indexOf a. I'll save this, and we get 0. That's that index 0. And if we look at index of c, we get 2. If we search for something that doesn't exist in the array, I'll say v, I'll save it and we get ‑1. And that's important because undefined could be a value inside the array. But a ‑1 tells us that there's an index of ‑1, which is impossible. So it was not found. And I'll paste in the code from the slide for filter. So we have our values array, and we want to execute values.filter. So this function will execute one time for each array element. And to prove that it does that, we can just log out item. If the item is greater than b, that will return true, and that item will become part of the new array that filter creates and that'll get stored in set. Let's say this. So we can see that our function that we're sending the filter did get called three times for each element in the values array, and the new array that created has the value c. Let's add some more values just to make sure that our filter is working properly. I'll add d and z. I'll save it. And we can see that the new array that gets created has the value c, d, and z, because all of those match the criteria of the item being greater than b. It's doing an alphabetical check. And I'll paste in the code from the next slide. That's the find function. I'll make some space, so we have our values array, then we're calling values.find. And we want to find an item that has a length that's greater than 1. As soon as we find that it will be stored in the found variable and we'll log that out. I'll save this. And we find the value bbb, because that's the only item that has a length greater than 1. What if we change c to a bunch of c's? I'll save it, and we still get back just bbb, because as soon as we find an item that matches the criteria, we're done. It never gets to the third element. And finally, let's look at the for each method call. I'll paste in that code. So we have our values array and we execute values.forEach and, again, this function gets called for each element in the array. We'll simply log out each item. I'll save it. And we get the values a, b and c. So there are different ways to execute this. We can use this for each method, or we could use a for or a while loop, as we learned earlier in the course. But this for each method is a newer edition, and its preferred when you're guaranteed that each item in the array needs to be passed to the function. So that's all we're going to cover as far as methods go. If we quickly look at some of the methods we didn't cover here on the Mozilla Developer network, we can see there really are a lot of features to arrays. We cover things such as index of, for each, find, but you should really check through all of these methods just to know what arrays are capable of. In the next clip, we'll take a look at modifying a web page based upon an array.
Arrays in the DOM

When we're working with the DOM, it's very common to use arrays and array‑like objects. Let's take a look at a common use of arrays. So here's our code from the last clip, and I'll just erase all of this. And before we start writing code, let's look at the HTML file, index.html. Our web page is actually made up of containers and these are bootstrap containers. You can see here that this div has a class of container, and as we scroll down, we see another class of container and another class of container. So we have all these containers that make up the web page. So let's try to grab all those and store them in an array. So we can access the document object, and before we saw that we could use the function getElementById, right here. That's the method call that will retrieve only one element based upon its Id attribute. But we want to call this one, getElementsByClassName, and this will return all of the elements that have a certain class name that we pass. And we want it to look for the containers, which have a class of container. Now, strictly speaking, this returns something that's not officially an array, but it acts very much like one. We can use the square brackets to index the various containers, and it has the dot length property to get the length of the array. But let's just go ahead and assign these containers that we get back to a variable. We'll call the variable containers, and I'll just put this on the next line to make sure we can see the whole thing. Let's log out containers and see what we have. I'll save it and I'll open up the console. And we get something called an HTML collection, but that's very similar to an array. The 8 means it has 8 elements, there are 8 containers. I'll open this up, and you can see the elements here. Here's our original container, and it looks like there's something else here for index 1, and this crf‑cigar‑banner, crf stands for carved rock fitness, the demo site we're working with, and let me click on that and we can see the banner highlighted, right here. It's these pictures of the boots and the text below it. So let's take this crf‑cigar‑banner, and we'll find out what index it is in the array. And let's try to hide it. I'll go back to the console. We can see that the crf‑cigar‑banner has an index of 2. So containers is essentially an array, even though it's telling us it's an HTML collection. We can say containers element 2. And let's access the classes, classList.add, and we can use the same bootstrap class we saw earlier, d‑none, which stands for display, we want to hide it. So containers is an array. We're going to access element 2, which is this cigar banner, the picture of the boots and the text under it. And we're going to add the class d‑none, which will set the display attribute to none. I'll save this, and let's take a look at the website and make sure that image is gone, and it is. Before it was right under get a grip, and now it's completely off the page. If we wanted to hide the next container after that, I think it's this trail review one, I'll save it. So we're hiding containers index 3, and the boots are there, and the trail review is still there. So actually, let's just take a look at our console. And what we hid was this crf‑story item, and that was all the pictures that came after this trail review. So those are missing now. And for the fun of it, let's just remove container 0, see what that is. I'll save it. And that was our heading. We no longer have our logo and menu on the top. But the point is that we're accessing all of these elements because they're stored in this container's array. That's all we're going to be covering on arrays. So let's wrap up this module with the summary.
Summary

We began this module by looking at how we can create an initialize arrays. We create an array variable, and we use square brackets to specify the elements of an array. We assign that to the variable. Another way we can create and initialize an array is with the Array.of method. Each argument becomes an element in the array. Next, we looked at accessing the array items or the array elements, and we use square brackets for that. We specify the array, square brackets, and the index of the item we want. Remember that the indexes are zero based. The first element is index zero. Next, we looked at manipulating arrays using various methods. We looked at push and pop. Push adds elements to the end of the array, and pop takes the last element off the array. We looked at shift and unshift, which work at the beginning of the array. Shift will take off the first element of the array, and unshift will add elements to the beginning of the array. Next, we looked at slice and splice, two very popular methods on arrays. Slice is used to create a new array from an existing array. It makes a copy of a slice within the array. And splice has two purposes that can delete elements, you specify the index and the number of elements you'd like to delete. You can also use the same method to insert items. You specify the index we'd like to insert, and if you don't want to delete anything, you just set deleteCount to zero, but if you wanted to delete something, you specify a number of the number of items you'd like to delete. And then at the end, you add one or more new items that you'd like to insert into the middle of the array at the index. And we looked at array searching and looping. We saw how to use indexOf and find to find elements within the array, we saw had to use the filter method, which creates a brand new array of items that are filtered from an original array, and we saw how to use forEach method. This will call a function on every element in the array. Finally, we took a look at arrays in the DOM. We called document.getElementsByClassName, and we got an array of all the elements that had a certain class in our web page. We could use this to manipulate the DOM. So that's all we have for arrays. Be sure to visit the Mozilla Developer Network and search for array to learn more about array's many methods.
Scope and Hoisting
Introduction

In this final module of the course, we'll take a look at scope and the concept of hoisting. These are concepts that can throw you off if you're not fully aware of them. So we'll take a close look and see some of the problems that could come up. We'll start off by looking at the global scope and how to work with it properly. Next, we'll take a look at function scope, and we'll see how functions look at their surrounding functions when they're looking up variable names. And we'll see some examples of functions within functions and eventually looking to the global scope to find a variable. We'll take a look at the var keyword and the concept of hoisting. We saw var earlier in the course, and we saw that it was better to be working with the const keyword for constants and the let keyword for variables that can change. But we need to look at this in a little bit more detail and see how the concept of hoisting works with variables and functions. JavaScript is backwards compatible with its very early versions. And in very early versions of javascript, you didn't have to declare variables, and this can throw you off. But there is a fix, and the fix has to do with strict mode. So we'll see how to put our code into strict mode and solve any undeclared variable problems. Let's get started and look in more detail at global scope.
Global Scope

Let's take a look at global scope. Mainly, there are two scopes in JavaScript. You have global scope and function scope, and scope refers to the area in which you can access a variable. Variables get declared in a scope. I'm here in home.js. And when we start coding directly in this JavaScript file, we're in the global scope. If we create a variable here, this new variable product ID can be accessed anywhere in our application. And just to show that, let me create a function. We'll call it showProductId, and we'll simply log out the productId. So this productId here is not declared in the function. It's declared in the global scope. And we need to call this function, and I'll save it, and we get the productId 12345. So even though productId is not declared in the function, it looks outward to the global scope to find the productId. And, of course, if there was never a productId in the global scope, I'll comment this out, and I'll save it, you can see that we get an error, productId is not defined. Global scope is more than what you see here. It's actually the sum total of all your JavaScript files. If we look at index.html, you'll remember that we have two JavaScript files, utils.js and home.js. So the global scope actually refers to utils.js, which is right here. We can see that in this global scope we're defining two functions and also in home.js. This is a continuation of the global scope. Your application may have dozens or more JavaScript files, all of which combine to give you one global scope. One concept you may have heard about is called polluting the global scope. And that's bad. That occurs when you have too many variables being declared globally in the global scope. For example, we have productId and I'll add a few more. And if all of your JavaScript files are doing this, declaring variables all over the place in the global scope, things can get very confusing. Bugs can start showing up. So generally what JavaScript developers do is they create only one variable in the global scope, and we can make it a constant, and we'll call it app for application. And that'll be an object, and any variables that we have will become properties of that object. We have to make sure we use colons instead of equal signs, and we don't need the final semicolon. But now we have a single object in the global scope. And whenever a developer needs some kind of information in the global scope, they can just use this application object. So if we save this now, it's not going to work because there's no productId. So we have to make sure that we access app.productId. I'll save it, and now it's working. Of course, you may have many functions in the global scope, but it's a good idea only to have one application object to hold any data you need globally. In the next clip, we'll take a look at function scope.
Function Scope

Now let's take a look at function scope. We've seen this earlier in the course, but let's take a closer look. We have our function showProductId, and we're calling the function on line 6. When we declare a variable within a function, it has function scope. So we'll let productId = 12345. And let's log out productId. I'll save this, and we get what we expected, 1234, but this productId variable is in function scope. We cannot access it outside of the function. We'll log it out here, and I'll comment this line out within the function. I'll save it and we can see that productId is not defined. So productId has function scope, and it's not only the case with variables; parameters are similar to variables. Let's add the productId here. And we'll pass in a productId, and we'll make sure to move the log underneath the function call. I'll save it, and we get our error, productId is not defined. So whether it's a parameter name or a local variable, it has function scope. I'll undo this and let's create a function within this function, and I'll just call it fix. And let's create a variable here with the same name, let productId = 45678, and we'll log that out. We'll say in fix, and we'll show the productId, and we'll keep our console.log here in our showProductId function, in showProductId. And we know that this is not needed anymore, and we can take out our final log statement. So we're going to call showProductId and we'll declare this fix function, and let's make sure we call that. So fix has a variable called productId, and the outer function, showProductId has a variable called productId. Let's see what we get. I'll save it, and the first output we get comes from the fix function where productId is 45678, but you can see that when that function finishes execution, the local variable is gone, and we're back to using the productId in the outer function. So this productId went out of scope as soon as fix completed execution, and this productId came back into scope after fix completed execution. So you need to be aware of the scope of variables. If we took this productId out, now we're accessing productId within the fix function. I'll save it and you can see we don't get an error. What happens is the function looks to its outer function and looks for the variable there. That's why we show the value 12345 and then show it again. And if productId didn't exist at all within this function, we'll make it global. I'll save this and it still works. So our function fix does not have productId in its local scope. It looks to the outer scope, and it doesn't find a productId there either. Finally, it looks to the global scope, and it finds the productId. So if you run into a situation where variables don't seem to be set correctly, look for duplicate variable names and look at the various scopes that your functions are called from, and remember that parameters work a lot like local variables. They disappear when the function finishes execution. In the next clip, we'll take a look at the var keyword again and the concept of hoisting.
var and Hoisting

Let's look at the var keyword and the concept of hoisting. We saw var earlier in this course, and we learned that it's much better to be using let or const to declare variables and/or constants. And one of the reasons for that has to do with hoisting. Let's see what that is. So we'll use var to declare a variable. And let's try to access that before it's declared. We'll log it out. I'll save it, and we get undefined. And to make things more confusing, let's set productId to a value. I'll save it. So we're working with productId. It's set to 456, but we haven't declared it yet. And that's what hoisting refers to. Hoisting means that the identifier, or productId right here, will be set to undefined when this JavaScript file is executed. But that's not what we want at all. You want to be working with let or const. So I'll change this to let, save it, and we get the error that we expected, cannot access productId before initialization. So this concept of using a variable before it's declared is not a good idea at all, and we should be using let and const, but this does not apply to functions. I'll create a function, and we'll call it showProductId, and I'll just log out a value. And what happens if we try to execute this function before it's declared? We'll call showProductId, and I'll save it, and we get the value 123. So in effect, this showProductId function is hoisted. We can actually call the function before we define it, and that's because it's a function declaration and it gets hoisted to the top. And the actual mechanism behind hoisting has to do with the fact that the JavaScript file gets executed after two passes. So in the first pass, the JavaScript engine will know there's a function called showProductId. But in the second pass, it'll actually execute things from the top down. So that's why the call to showProductId is successful even though the function has not been declared yet. So hoisting is fine for functions like this. But for variables and constants, make sure to use let and const and avoid var. That way any hoisting problems can be avoided. In the next clip, we'll take a closer look at undeclared variables and strict mode.
Undeclared Variables and Strict Mode

In early versions of JavaScript, you could start using variables without declaring them, and that's really a bad idea. After a few releases, JavaScript created a fix for that. Let's take a look at Visual Studio Code. So let's just create a variable, but we won't use any var, let, or const keyword, and we'll log it out. I'll save this, and we get 1234, and this is a big problem, especially in larger projects. You always want to declare your variables. In fact, what's happening here is productId is being declared on an object called window. If we log out window.productId, I'll save this, and you can see we get the same value. If you look at the history of JavaScript, window referred mainly to the window of the browser, where your application is running, but many global variables got placed in window, and with subsequent releases of JavaScript, developers wanted to avoid that, they didn't want window to become a dumping ground for all kinds of variables. So a new feature was added to the language, where you can specify a string called use strict, and just by putting this string above your other code, it puts the JavaScript file into what's called strict mode, and this forces you to declare your variables. Let me just fix up this log, I'll remove the window portion of it, then I'll save it. And now we get the error that we want, productId is not defined. So one thing you might want to do in all your JavaScript files is to begin it with this use strict string. Of course, we can get rid of the error by properly adding a let or const keyword. I'll save it. And now we get the answer we expected. Here we see use strict used in the global space, but you can also use it for individual functions as well. This is a beginner course in JavaScript, but as you learn more advanced features, such as modules and classes, you'll find out that use strict is already implied, you don't need to specify it, but if you're writing code like we've covered in this course, it's a good idea to always use this string, use strict, so the compiler knows that you're in strict mode.
Summary

We started off this module by looking at global scope. We saw how any function in any of our code can access items in the global scope. We also saw how it's a good idea not to pollute the global scope and keep any variables or values that we need in a single object. Usually you'll see an object like that called app for application. Next we looked at function scope, and we saw how names get resolved. Let's say we're looking for a variable name, if it doesn't exist in that function, it looks in the next surrounding function, and then in that function's surrounding function, and so on, up until you reach the global scope. If it doesn't find the variable name anywhere, it's an error. Next, we looked at var and hoisting. We know we want to use the let and const keywords instead of var, but when it comes to function declarations, those are fine, they get hoisted, but there's no problem with that. Finally, we took a look at undeclared variables and how we can make sure that our variables must be declared by using strict mode. We put a magic string at the beginning of our code, and it could be in single quotes or double quotes, and it simply says use strict. By doing this, we can make sure that errors show up if we have undeclared variables, which is good. And that wraps up this course, JavaScript: Getting Started. You now know all the basic features of JavaScript and can start writing valuable applications. To really become proficient at this, you should take each feature and make lots of sample applications. So good luck creating your applications in JavaScript.
