An object is a region of storage that has a type and a value. When you declare a variable, you create an object. A variable is simply an object that has a name.

"Lifetime" is the period during execution of a program in which a variable or function exists. The storage duration of the identifier determines its lifetime.



### Allocation, Deallocation, and Lifetime
Every object requires storage. You reserve storage for objects in a process called allocation. When you’re done with an object, you release the object’s storage in a process called deallocation.

An object’s storage duration begins when the object is allocated and ends when the object is deallocated. The lifetime of an object is a runtime property that is bound by the object’s storage duration. An object’s lifetime begins once its constructor completes, and it ends just before a destructor is invoked.

In summary, each object passes through the following stages:
1. The object’s storage duration begins, storage is allocated.
2. The object’s constructor is called and it is initialized.
3. The object’s lifetime begins.
4. You can use the object in your program.
5. The object’s lifetime ends.
6. The object’s destructor is called.
7. The object’s storage duration ends, and storage is deallocated.

The above about creation (allocation and initialization) and destruction are guarantees. That is, objects must be created no later than the point of definition, and destroyed no earlier than the end of the storage duration.




### Storage Durations

All objects in a program have one of the following storage durations:

Automatic:
  The storage for the object is allocated at the beginning of the enclosing code block and deallocated at the end. All local objects have this storage duration, except those declared static, extern or thread_local.

Static:
  The storage for the object is allocated when the program begins and deallocated when the program ends. Only one instance of the object exists. All objects declared at namespace scope (including global namespace) have this storage duration, plus those declared with static or extern.
  
Thread: (since C++11)
  The storage for the object is allocated when the thread begins and deallocated when the thread ends. Each thread has its own instance of the object. Only objects declared thread_local have this storage duration. thread_local can appear together with static or extern to adjust linkage. See Non-local variables and Static local variables for details on initialization of objects with this storage duration.

Dynamic:
  The storage for the object is allocated and deallocated per request by using dynamic memory allocation functions. Dynamic objects are also called allocated objects for this reason. Dynamic storage duration provides manual control over when am object’s life begins and ends. The primary way to allocate and deallocate a dynamic object is with the new and delete expressions respectively.      







## Example

Consider the following program. Four different Tracer objects have
different storage durations. By looking at the order of the program’s Tracer
output, you can verify what you’ve learned about storage durations.

Example
  #include <cstdio>
  struct Tracer
  {
    Tracer(const char* nameu) : name{ name }
    {
      printf("%s constructed.\n", name);
    }

    ~Tracer()
    {
      printf("%s destructed.\n", name);
    }
    private:
      const char* const name;
  };

  static Tracer t1{ "Static variable" };
  thread_local Tracer t2{ "Thread-local variable" };

  int main() {
    printf("A\n");
    Tracer t3{ "Automatic variable" };
    printf("B\n");
    const auto* t4 = new Tracer{ "Dynamic variable" };
    printf("C\n");
  }

Output:
Static variable constructed.
Thread-local variable constructed.
A
Automatic variable constructed.
B
Dynamic variable constructed.
C
Automatic variable destructed.
Thread-local variable destructed.
Static variable destructed.

A Tracer with static duration, thread local duration, automatic duration, and dynamic duration. Between each line in main, it prints the character A, B, or C for reference.

Before the first line of main, the static and thread local variables
t1 and t2 have been initialized. Both variables have printed their initialization messages before A. As an automatic variable, the scope of t3 is bounded by the enclosing function main.
Accordingly, t3 is constructed where it is initialized just after A.
After B, you see the message corresponding to the initialization of t4.
Notice that there’s no corresponding message generated by the dynamic
destructor of Tracer. The reason is that you’ve (intentionally) leaked the
object pointed to by t4. Because there’s no command to delete t4, the
destructor is never called. Just before main returns, C prints. Because t3 is an automatic variable
whose scope is main, it’s destroyed at this point because main is returning.
Finally, the static and thread-local variables t1 and t2 are destroyed just
before program exit, yielding the final two messages
