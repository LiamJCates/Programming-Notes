Altering Copy and Move Operations



## private
To avoid assignment, you declare a private assignment operator.
Thus, the solution is the following:
class MyClass
{
private:
MyClass(const MyClass&); // private copy constructor
MyClass& operator= (const MyClass&); // private copy assignment operator
// … other attributes
};
There is no need for implementation of the private copy constructor or assignment operator. Just declaring them as private is adequate and sufficient toward fulfilling your goal of ensuring non-copyable objects of class MyClass





## =default
Often, the compiler will generate default implementations for copy construction and copy assignment. The default implementation is to invoke
copy construction or copy assignment on each of a class’s members.
Any time a class manages a resource, you must be extremely careful
with default copy semantics; they’re likely to be wrong.

Best practice dictates that you explicitly declare that default copy assignment and copy construction are acceptable for such classes using the default keyword.

Except for the ‘‘ordinary constructor,’’ these special member functions will be generated by the compiler as needed. If you want to be explicit about generating default implementations, you can:
class Y {
public:
  Y(Sometype);
  Y(const Y&) = default; // I really do want the default copy constructor
  Y(Y&&) = default; // and the default move constructor
  // ...
};

If you are explicit about some defaults, other default definitions will not be generated. When a class has a pointer member, it is usually a good idea to be explicit about copy and move operations. The reason is that a pointer may point to something that the class needs to delete, in which case the default memberwise copy would be wrong. Alternatively, it might point to something that the class must not delete. In either case, a reader of the code would like to know.



## =delete
Some classes simply cannot or should not be copied — for example, if
your class manages a file or if it represents a mutual exclusion lock for concurrent programming.

To complement =default, we have =delete to indicate that an operation is not to be generated. You can suppress the compiler from generating a copy constructor and a copy assignment operator using the =delete keyword.

 A base class in a class hierarchy is the classical example where we don’t want to allow a memberwise copy.

For example:
class Shape {
public:
  Shape(const Shape&) =delete; // no copy operations
  Shape& operator=(const Shape&) =delete;
  // ...
};
void copy(Shape& s1, const Shape& s2)
{
  s1 = s2; // error : Shape copy is deleted
}

A =delete makes an attempted use of the deleted function a compile-time error; =delete can be used to suppress any function, not just essential member functions.


It is highly recommend that you explicitly define the copy assignment operator and copy constructor for any class that owns a resource (like a printer, a
network connection, or a file). If custom behavior is not needed, use either
default or delete. This will save you from a lot of nasty and difficult-to-debug errors.
