Constructors, destructors, and copy and move operations for a type are not logically separate.
We must define them as a matched set or suffer logical or performance problems. If a class X has a66 Essential Operations Chapter 5
destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is
likely to need the full complement of functions:
class X {
public:
X(Sometype); // ‘‘ordinar y constructor’’: create an object
X(); // default constructor
X(const X&); // copy constr uctor
X(X&&); // move constructor
X& operator=(const X&); // copy assignment: clean up target and copy
X& operator=(X&&); // move assignment: clean up target and move
˜X(); // destr uctor: clean up
// ...
};
There are five situations in which an object can be copied or moved:
• As the source of an assignment
• As an object initializer
• As a function argument
• As a function return value
• As an exception
An assignment uses a copy or move assignment operator. In principle, the other cases use a copy or
move constructor. Howev er, a copy or move constructor invocation is often optimized away by
constructing the object used to initialize right in the target object. For example:
X make(Sometype);
X x = make(value);
Here, a compiler will typically construct the X from make() directly in x; thus eliminating (‘‘eliding’’) a copy.
In addition to the initialization of named objects and of objects on the free store, constructors
are used to initialize temporary objects and to implement explicit type conversion.
Except for the ‘‘ordinary constructor,’’ these special member functions will be generated by the
compiler as needed. If you want to be explicit about generating default implementations, you can:
class Y {
public:
Y(Sometype);
Y(const Y&) = default; // I really do want the default copy constr uctor
Y(Y&&) = default; // and the default move constr uctor
// ...
};
If you are explicit about some defaults, other default definitions will not be generated.
When a class has a pointer member, it is usually a good idea to be explicit about copy and move
operations. The reason is that a pointer may point to something that the class needs to delete, in
which case the default memberwise copy would be wrong. Alternatively, it might point to something that the class must not delete. In either case, a reader of the code would like to know. For an
example, see §5.2.1.Section 5.1.1 Essential Operations 67
A good rule of thumb (sometimes called the rule of zero) is to either define all of the essential
operations or none (using the default for all). For example:
struct Z {
Vector v;
string s;
};
Z z1; // default initialize z1.v and z1.s
Z z2 = z1; // default copy z1.v and z1.s
Here, the compiler will synthesize memberwise default construction, copy, move, and destructor as
needed, and all with the correct semantics.
To complement =default, we hav e =delete to indicate that an operation is not to be generated. A
base class in a class hierarchy is the classical example where we don’t want to allow a memberwise
copy. For example:
class Shape {
public:
Shape(const Shape&) =delete; // no copy operations
Shape& operator=(const Shape&) =delete;
// ...
};
void copy(Shape& s1, const Shape& s2)
{
s1 = s2; // error : Shape copy is deleted
}
A =delete makes an attempted use of the deleted function a compile-time error; =delete can be used
to suppress any function, not just essential member functions.








Copy and Move
By default, objects can be copied. This is true for objects of user-defined types as well as for builtin types. The default meaning of copy is memberwise copy: copy each member. For example,
using complex from §4.2.1:
void test(complex z1)
{
complex z2 {z1}; // copy initialization
complex z3;
z3 = z2; // copy assignment
// ...
}
Now z1, z2, and z3 have the same value because both the assignment and the initialization copied
both members.
When we design a class, we must always consider if and how an object might be copied. For
simple concrete types, memberwise copy is often exactly the right semantics for copy. For someSection 5.2 Copy and Move 69
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy;
for abstract types it almost never is.















Copying Containers
When a class is a resource handle – that is, when the class is responsible for an object accessed
through a pointer – the default memberwise copy is typically a disaster. Memberwise copy would
violate the resource handle’s inv ariant (§3.5.2). For example, the default copy would leave a copy
of a Vector referring to the same elements as the original:
void bad_copy(Vector v1)
{
Vector v2 = v1; // copy v1’s representation into v2
v1[0] = 2; // v2[0] is now also 2!
v2[1] = 3; // v1[1] is now also 3!
}
Assuming that v1 has four elements, the result can be represented graphically like this:
4
v1:
4
v2:
2 3
Fortunately, the fact that Vector has a destructor is a strong hint that the default (memberwise) copy
semantics is wrong and the compiler should at least warn against this example. We need to define
better copy semantics.
Copying of an object of a class is defined by two members: a copy constructor and a copy
assignment:
class Vector {
private:
double∗ elem; // elem points to an array of sz doubles
int sz;
public:
Vector(int s); // constr uctor: establish invariant, acquire resources
˜Vector() { delete[] elem; } // destr uctor: release resources
Vector(const Vector& a); // copy constr uctor
Vector& operator=(const Vector& a); // copy assignment
double& operator[](int i);
const double& operator[](int i) const;
int size() const;
};
A suitable definition of a copy constructor for Vector allocates the space for the required number of70 Essential Operations Chapter 5
elements and then copies the elements into it so that after a copy each Vector has its own copy of
the elements:
Vector::Vector(const Vector& a) // copy constr uctor
:elem{new double[a.sz]}, // allocate space for elements
sz{a.sz}
{
for (int i=0; i!=sz; ++i) // copy elements
elem[i] = a.elem[i];
}
The result of the v2=v1 example can now be presented as:
4
v1:
4
v2:
2 2
Of course, we need a copy assignment in addition to the copy constructor:
Vector& Vector::operator=(const Vector& a) // copy assignment
{
double∗ p = new double[a.sz];
for (int i=0; i!=a.sz; ++i)
p[i] = a.elem[i];
delete[] elem; // delete old elements
elem = p;
sz = a.sz;
return ∗this;
}
The name this is predefined in a member function and points to the object for which the member
function is called.
5.2.2 Moving Containers
We can control copying by defining a copy constructor and a copy assignment, but copying can be
costly for large containers. We avoid the cost of copying when we pass objects to a function by
using references, but we can’t return a reference to a local object as the result (the local object
would be destroyed by the time the caller got a chance to look at it). Consider:
Vector operator+(const Vector& a, const Vector& b)
{
if (a.size()!=b.siz e())
throw Vector_size_mismatch{};
Vector res(a.size());Section 5.2.2 Moving Containers 71
for (int i=0; i!=a.size(); ++i)
res[i]=a[i]+b[i];
return res;
}
Returning from a + involves copying the result out of the local variable res and into some place
where the caller can access it. We might use this + like this:
void f(const Vector& x, const Vector& y, const Vector& z)
{
Vector r;
// ...
r = x+y+z;
// ...
}
That would be copying a Vector at least twice (one for each use of the + operator). If a Vector is
large, say, 10,000 doubles, that could be embarrassing. The most embarrassing part is that res in
operator+() is never used again after the copy. We didn’t really want a copy; we just wanted to get
the result out of a function: we wanted to move a Vector rather than copy it. Fortunately, we can
state that intent:
class Vector {
// ...
Vector(const Vector& a); // copy constr uctor
Vector& operator=(const Vector& a); // copy assignment
Vector(Vector&& a); // move constructor
Vector& operator=(Vector&& a); // move assignment
};
Given that definition, the compiler will choose the move constructor to implement the transfer of
the return value out of the function. This means that r=x+y+z will involve no copying of Vectors.
Instead, Vectors are just moved.
As is typical, Vector’s move constructor is trivial to define:
Vector::Vector(Vector&& a)
:elem{a.elem}, // "grab the elements" from a
sz{a.sz}
{
a.elem = nullptr; // now a has no elements
a.sz = 0;
}
The && means ‘‘rvalue reference’’ and is a reference to which we can bind an rvalue. The word
‘‘rvalue’’ is intended to complement ‘‘lvalue,’’ which roughly means ‘‘something that can appear on
the left-hand side of an assignment.’’ So an rvalue is – to a first approximation – a value that you
can’t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference to something that nobody else can assign to, so we can safely ‘‘steal’’ its value. The res local
variable in operator+() for Vectors is an example.72 Essential Operations Chapter 5
A move constructor does not take a const argument: after all, a move constructor is supposed to
remove the value from its argument. A move assignment is defined similarly.
A move operation is applied when an rvalue reference is used as an initializer or as the righthand side of an assignment.
After a move, a moved-from object should be in a state that allows a destructor to be run. Typically, we also allow assignment to a moved-from object. The standard-library algorithms (Chapter
12) assumes that. Our Vector does that.
Where the programmer knows that a value will not be used again, but the compiler can’t be
expected to be smart enough to figure that out, the programmer can be specific:
Vector f()
{
Vector x(1000);
Vector y(2000);
Vector z(3000);
z = x; // we get a copy (x might be used later in f())
y = std::move(x); // we get a move (move assignment)
// ... better not use x here ...
return z; // we get a move
}
The standard-library function move() doesn’t actually move anything. Instead, it returns a reference
to its argument from which we may move – an rvalue reference; it is a kind of cast (§4.2.3).
Just before the return we have:
nullptr 0
x:
1000
y:
1000
z:
1 2 ... 1 2 ...
When we return from f(), z is destroyed after its elements has been moved out of f() by the return.
However, y’s destructor will delete[] its elements.
The compiler is obliged (by the C++ standard) to eliminate most copies associated with initialization, so move constructors are not invoked as often as you might imagine. This copy elision
eliminates even the very minor overhead of a move. On the other hand, it is typically not possible
to implicitly eliminate copy or move operations from assignments, so move assignments can be
critical for performance.
5.3 Resource Management
By defining constructors, copy operations, move operations, and a destructor, a programmer can
provide complete control of the lifetime of a contained resource (such as the elements of a container). Furthermore, a move constructor allows an object to move simply and cheaply from one
scope to another. That way, objects that we cannot or would not want to copy out of a scope can beSection 5.3 Resource Management 73
simply and cheaply moved out instead. Consider a standard-library thread representing a concurrent activity (§15.2) and a Vector of a million doubles. We can’t copy the former and don’t want to
copy the latter.
std::vector<thread> my_threads;
Vector init(int n)
{
thread t {heartbeat}; // run hear tbeat concurrently (in a separate thread)
my_threads.push_back(std::move(t)); // move t into my_threads (§13.2.2)
// ... more initialization ...
Vector vec(n);
for (int i=0; i!=vec.size(); ++i)
vec[i] = 777;
return vec; // move vec out of init()
}
auto v = init(1'000'000); // star t hear tbeat and initialize v
Resource handles, such as Vector and thread, are superior alternatives to direct use of built-in pointers in many cases. In fact, the standard-library ‘‘smart pointers,’’ such as unique_ptr, are themselves
resource handles (§13.2.1).
I used the standard-library vector to hold the threads because we don’t get to parameterize our
simple Vector with an element type until §6.2.
In very much the same way that new and delete disappear from application code, we can make
pointers disappear into resource handles. In both cases, the result is simpler and more maintainable
code, without added overhead. In particular, we can achieve strong resource safety; that is, we can
eliminate resource leaks for a general notion of a resource. Examples are vectors holding memory,
threads holding system threads, and fstreams holding file handles.
In many languages, resource management is primarily delegated to a garbage collector. C++
also offers a garbage collection interface so that you can plug in a garbage collector. Howev er, I
consider garbage collection the last choice after cleaner, more general, and better localized alternatives to resource management have been exhausted. My ideal is not to create any garbage, thus
eliminating the need for a garbage collector: Do not litter!
Garbage collection is fundamentally a global memory management scheme. Clever implementations can compensate, but as systems are getting more distributed (think caches, multicores, and
clusters), locality is more important than ever.
Also, memory is not the only resource. A resource is anything that has to be acquired and
(explicitly or implicitly) released after use. Examples are memory, locks, sockets, file handles, and
thread handles. Unsurprisingly, a resource that is not just memory is called a non-memory
resource. A good resource management system handles all kinds of resources. Leaks must be
avoided in any long-running system, but excessive resource retention can be almost as bad as a
leak. For example, if a system holds on to memory, locks, files, etc. for twice as long, the system
needs to be provisioned with potentially twice as many resources.
Before resorting to garbage collection, systematically use resource handles: let each resource
have an owner in some scope and by default be released at the end of its owners scope. In C++,74 Essential Operations Chapter 5
this is known as RAII (Resource Acquisition Is Initialization) and is integrated with error handling
in the form of exceptions. Resources can be moved from scope to scope using move semantics or
‘‘smart pointers,’’ and shared ownership can be represented by ‘‘shared pointers’’ (§13.2.1).
In the C++ standard library, RAII is pervasive: for example, memory (string, vector, map,
unordered_map, etc.), files (ifstream, ofstream, etc.), threads (thread), locks (lock_guard, unique_lock,
etc.), and general objects (through unique_ptr and shared_ptr). The result is implicit resource management that is invisible in common use and leads to low resource retention durations
























Copy Semantics
Copy Semantics is “the meaning of copy.” In practice, programmers use the term to mean the rules for making copies of objects: after x is copied into y, they’re equivalent and independent. That is, x == y is true after a copy (equivalence), and a modification to x doesn’t cause a modification of y (independence).

Copying is extremely common, especially when passing objects to functions by value

For fundamental and POD types, the story is straightforward. Copying
these types is memberwise, which means each member gets copied into its
corresponding destination. This is effectively a bitwise copy from one memory address to another.


Fully featured classes require some more thought. The default copy
semantics for fully featured classes is also the memberwise copy, and this
can be extremely dangerous.

A class that uses a pointer to a dynamic value that is memeberwise copied will not maintain independence. Both the original and copies will reference the same region of memory leading to memory clobbering as seemingly independent object operate on the same memory

This result is bad, but even worse things happen when those object start destructing. When one of the objects is destructed, the memory will be freed. When the remaining object tries to use that freed memory undefined behavior occurs. At some point, this remaining object will be destructed and free the memory location again, resulting in what is commonly called a double free.

NOTE
Like its nefarious cousin the use after free, the double free can result in subtle and hard-to-diagnose bugs that manifest only very infrequently. A double free occurs when you deallocate an object twice. Recall that once you’ve deallocated an object, its storage lifetime ends. This memory is now in an undefined state, and if you destruct an object that’s already been destructed, you’ve got undefined behavior. In certain situations, this can cause serious security vulnerabilities.


Copy Constructor
You can avoid this dumpster fire by taking control of copy semantics. You
can specify copy constructors and copy assignment operators

There are two ways to copy an object. One is to use copy construction, which
creates a copy and assigns it to a brand-new object. The copy constructor
looks like other constructors:
struct MyObject {
  --snip--
  MyObject(const MyObject& other);
};

Notice that other is const. You’re copying from some original MyObject,
and you have no reason to modify it. You use the copy constructor just
like other constructors, using the uniform initialization syntax of braced
initializers:
MyObject a;
MyObject a_copy{ a };

The second line invokes the copy constructor of MyObject with a to
yield a_copy.

Let’s implement the copy constructor of MyObject. You want what is known as a deep copy where you copy the data pointed to by the original

Rather than copying the pointer buffer, you’ll make a new allocation on
the free store and then copy all the data pointed to by the original buffer.

You shouldn’t pass by value to avoid modification. Use a const reference.



The copy constructor is a constructor which creates an object by initializing it with an object of the same class, which has been created previously. The copy constructor is used to:
  Initialize one object from another of the same type.
  Copy an object to pass it as an argument to a function.
  Copy an object to return it from a function.

If a copy constructor is not defined in a class, the compiler itself defines one. If the class has pointer variables and has some dynamic memory allocations, then it is a must to have a copy constructor. The most common form of copy constructor is shown here:

classname (const classname &obj)
{
   // body of constructor
}

Here, obj is a reference to an object that is being used to initialize another object.
Live Demo

#include <iostream>

using namespace std;

class Line {

   public:
      int getLength( void );
      Line( int len );             // simple constructor
      Line( const Line &obj);  // copy constructor
      ~Line();                     // destructor

   private:
      int *ptr;
};

// Member functions definitions including constructor
Line::Line(int len) {
   cout << "Normal constructor allocating ptr" << endl;

   // allocate memory for the pointer;
   ptr = new int;
   *ptr = len;
}

Line::Line(const Line &obj) {
   cout << "Copy constructor allocating ptr." << endl;
   ptr = new int;
   *ptr = *obj.ptr; // copy the value
}

Line::~Line(void) {
   cout << "Freeing memory!" << endl;
   delete ptr;
}

int Line::getLength( void ) {
   return *ptr;
}

void display(Line obj) {
   cout << "Length of line : " << obj.getLength() <<endl;
}

// Main function for the program
int main() {
   Line line(10);

   display(line);

   return 0;
}

When the above code is compiled and executed, it produces the following result −

Normal constructor allocating ptr
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Freeing memory!

Let us see the same example but with a small change to create another object using existing object of the same type −
Live Demo

#include <iostream>

using namespace std;

class Line {
   public:
      int getLength( void );
      Line( int len );             // simple constructor
      Line( const Line &obj);  // copy constructor
      ~Line();                     // destructor

   private:
      int *ptr;
};

// Member functions definitions including constructor
Line::Line(int len) {
   cout << "Normal constructor allocating ptr" << endl;

   // allocate memory for the pointer;
   ptr = new int;
   *ptr = len;
}

Line::Line(const Line &obj) {
   cout << "Copy constructor allocating ptr." << endl;
   ptr = new int;
   *ptr = *obj.ptr; // copy the value
}

Line::~Line(void) {
   cout << "Freeing memory!" << endl;
   delete ptr;
}

int Line::getLength( void ) {
   return *ptr;
}

void display(Line obj) {
   cout << "Length of line : " << obj.getLength() <<endl;
}

// Main function for the program
int main() {

   Line line1(10);

   Line line2 = line1; // This also calls copy constructor

   display(line1);
   display(line2);

   return 0;
}

When the above code is compiled and executed, it produces the following result −

Normal constructor allocating ptr
Copy constructor allocating ptr.
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Copy constructor allocating ptr.
Length of line : 10
Freeing memory!
Freeing memory!
Freeing memory!













Shallow Copying and Associated Problems
Classes that contain a pointer member buffer that points to dynamically allocated memory, allocated in the constructor using new and deallocated in the destructor using delete[].

When an object of this class is copied, the pointer member is copied, but not the pointed memory, resulting in two objects pointing to the same dynamically allocated buffer in memory. When an object is destructed, delete[] deallocates the memory, thereby invalidating the pointer copy held by the other object.

Such copies are shallow and are a threat to the stability of the program



Copy Constructor
The copy constructor is a constructor which creates an object by initializing it with an object of the same class, which has been created previously. The copy constructor is used to −

    Initialize one object from another of the same type.
    Copy an object to pass it as an argument to a function.
    Copy an object to return it from a function.

If a copy constructor is not defined in a class, the compiler itself defines one.If the class has pointer variables and has some dynamic memory allocations, then it is a must to have a copy constructor. The most common form of copy constructor is shown here −

classname (const classname &obj) {
   // body of constructor
}


Ensuring Deep Copy Using a Copy Constructor
The copy constructor is an overloaded constructor that you supply. It is invoked by the
compiler every time an object of the class is copied.
The declaration syntax of a copy constructor for class MyString is the following:
class MyString
{
MyString(const MyString& copySource); // copy constructor
};
MyString::MyString(const MyString& copySource)
{
// Copy constructor implementation code
}
Thus, a copy constructor takes an object of the same class by reference as a parameter.
This parameter is an alias of the source object and is the handle you have in writing your
custom copy code. You would use the copy constructor to ensure a deep copy

The copy constructor has ensured deep copy in cases such as
function calls:
MyString sayHello("Hello from String Class");
UseMyString(sayHello);
However, what if you tried copying via assignment:
MyString overwrite("who cares? ");
overwrite = sayHello;
This would still be a shallow copy because you still haven’t yet
supplied a copy assignment operator=. In the absence of one,
the compiler has supplied a default for you that does a shallow
copy.

an improved MyString that implements the
same:
MyString::operator= (const MyString& copySource)
{
//... copy assignment operator code
}

Using const in the copy constructor declaration ensures that
the copy constructor does not modify the source object being
referred to.
Additionally, the parameter in the copy constructor is passed by
reference as a necessity. If this weren’t a reference, the copy
constructor would itself invoke a copy, thus invoking itself again
and so on till the system runs out of memory

The class MyString with a raw pointer member, char* buffer
is used as an example to explain the need for copy constructors.
If you were to program a class that needs to contain string data
for storing names and so on, you use std::string instead of
char* and might not even need a copy constructor given the
absence of raw pointers. This is because the default copy constructor inserted by the compiler would ensure the invocation
of all available copy constructors of member objects such as
std::string.


Copy Assignment
The other way to make a copy in C++ is with the copy assignment operator.

You can create a copy of an object and assign it to another existing object

void dont_do_this() {
SimpleString a{ 50 };
a.append_line("We apologize for the");
SimpleString b{ 50 };
b.append_line("Last message");
b = a;
}
Listing 4-28: Using the default copy assignment operator to create a copy of an object and assign it to another existing object

NOTE
The code in Listing 4-28 causes undefined behavior because it doesn’t have a userdefined copy assignment operator.

The last line at copy assigns a to b.
The major difference between copy assignment and copy construction is that in copy assignment, b might already have a value. You must clean up b’s resources before copying a.

WARNING
The default copy assignment operator for simple types just copies the members from the source object to the destination object. In this case of a full featured object, this is very dangerous for two reasons.
First, the original object gets rewritten without freeing the dynamically allocated char array.

Second, now two objects own the same buffer, which can cause dangling pointers and double frees. You must implement a copy assignment operator that performs a clean hand-off.

The copy assignment operator uses the operator= syntax, as demonstrated:

struct SimpleString {
--snip--
SimpleString& operator=(const SimpleString& other) {
if (this == &other) return *this; u
--snip--
return *this; v
}
}
A user-defined copy assignment operator


The copy assignment operator returns a reference to the result, which
is always *this. It’s also generally good practice to check whether other
refers to this.
You can implement copy assignment for SimpleString by following these
guidelines: free the current buffer of this and then copy other as you did in
copy construction, as shown in Listing 4-30.
SimpleString& operator=(const SimpleString& other) {
if (this == &other) return *this;
const auto new_buffer = new char[other.max_size];
delete[] buffer;
buffer = new_buffer;
length = other.length;
max_size = other.max_size;
strcpy_s(buffer, max_size, other.buffer);
return *this;
}
Listing 4-30: A copy assignment operator for SimpleString

The copy assignment operator starts by allocating a new_buffer with the
appropriate size. Next, you clean up buffer. You copy buffer, length,
and max_size and then copy the contents from other.buffer into your own
buffer.


Default Copy
Often, the compiler will generate default implementations for copy construction and copy assignment. The default implementation is to invoke
copy construction or copy assignment on each of a class’s members.
Any time a class manages a resource, you must be extremely careful
with default copy semantics; they’re likely to be wrong (as you saw with
SimpleString). Best practice dictates that you explicitly declare that default
copy assignment and copy construction are acceptable for such classes
using the default keyword. The Replicant class, for example, has default
copy semantics, as demonstrated here:
struct Replicant {
Replicant(const Replicant&) = default;
Replicant& operator=(const Replicant&) = default;
--snip--
};
Some classes simply cannot or should not be copied—for example, if
your class manages a file or if it represents a mutual exclusion lock for concurrent programming. You can suppress the compiler from generating a
copy constructor and a copy assignment operator using the delete keyword.
The Highlander class, for example, cannot be copied:
struct Highlander {
Highlander(const Highlander&) = delete;
Highlander& operator=(const Highlander&) = delete;
--snip--
};
Any attempt to copy a Highlander will result in a compiler error:
--snip--
int main() {
Highlander a;
Highlander b{ a }; // Bang! There can be only one.
}
I highly recommend that you explicitly define the copy assignment operator and copy constructor for any class that owns a resource (like a printer, a
network connection, or a file). If custom behavior is not needed, use either
default or delete. This will save you from a lot of nasty and difficult-to-debug
errors.

Copy Guidelines
When you implement copy behavior, think about the following criteria:
Correctness You must ensure that class invariants are maintained.
The SimpleString class demonstrated that the default copy constructor
can violate invariants.
Independence After copy assignment or copy construction, the original
object and the copy shouldn’t change each other’s state during modification. Had you simply copied buffer from one SimpleString to another,
writing to one buffer could overwrite the data from the other.
Equivalence The original and the copy should be the same. The semantics of sameness depend on context. But generally, an operation applied
to the original should yield the same result when applied to the copy.









Private Assignment Operator
To avoid assignment, you declare a private assignment operator.
Thus, the solution is the following:
class President
{
private:
President(const President&); // private copy constructor
President& operator= (const President&); // private copy assignment operator
// … other attributes
};
There is no need for implementation of the private copy constructor or assignment
operator. Just declaring them as private is adequate and sufficient toward fulfilling your
goal of ensuring non-copyable objects of class President









For classes with pointer member variables, three things are normally done:
1. Include the destructor in the class.
2. Overload the assignment operator for the class.
3. Include the copy constructor.

Constructors, destructors, and copy and move operations for a type are not logically separate.

We must define them as a matched set or suffer logical or performance problems.

If a class X has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:
class X {
public:
X(Sometype); // ‘‘ordinar y constructor’’: create an object
X(); // default constructor
X(const X&); // copy constructor
X(X&&); // move constructor
X& operator=(const X&); // copy assignment: clean up target and copy
X& operator=(X&&); // move assignment: clean up target and move
˜X(); // destr uctor: clean up
// ...
};
There are five situations in which an object can be copied or moved:
• As the source of an assignment
• As an object initializer
• As a function argument
• As a function return value
• As an exception

An assignment uses a copy or move assignment operator. In principle, the other cases use a copy or move constructor. However, a copy or move constructor invocation is often optimized away by constructing the object used to initialize right in the target object.

For example:
X make(Sometype);
X x = make(value);
Here, a compiler will typically construct the X from make() directly in x; thus eliminating (‘‘eliding’’) a copy.

In addition to the initialization of named objects and of objects on the free store, constructors are used to initialize temporary objects and to implement explicit type conversion.
Except for the ‘‘ordinary constructor,’’ these special member functions will be generated by the compiler as needed. If you want to be explicit about generating default implementations, you can:
class Y {
public:
Y(Sometype);
Y(const Y&) = default; // I really do want the default copy constr uctor
Y(Y&&) = default; // and the default move constr uctor
// ...
};

If you are explicit about some defaults, other

A good rule of thumb (sometimes called the rule of zero) is to either define all of the essential operations or none (using the default for all). For example:

struct Z {
Vector v;
string s;
};

Z z1; // default initialize z1.v and z1.s
Z z2 = z1; // default copy z1.v and z1.s
Here, the compiler will synthesize memberwise default construction, copy, move, and destructor as needed, and all with the correct semantics.

To complement =default, we have =delete to indicate that an operation is not to be generated. A base class in a class hierarchy is the classical example where we don’t want to allow a memberwise copy.

For example:
class Shape {
public:
Shape(const Shape&) =delete; // no copy operations
Shape& operator=(const Shape&) =delete;
// ...
};
void copy(Shape& s1, const Shape& s2)
{
s1 = s2; // error : Shape copy is deleted
}
A =delete makes an attempted use of the deleted function a compile-time error; =delete can be used
to suppress any function, not just essential member functions.



















Move Semantics
Copying can be quite time-consuming at runtime when a large amount of
data is involved. Often, you just want to transfer ownership of resources from
one object to another. You could make a copy and destroy the original, but
this is often inefficient. Instead, you can move.
Move semantics is move’s corollary to copy semantics, and it requires that
after an object y is moved into an object x, x is equivalent to the former value
of y. After the move, y is in a special state called the moved-from state. You
can perform only two operations on moved-from objects: (re)assign them
or destruct them. Note that moving an object y into an object x isn’t just a
renaming: these are separate objects with separate storage and potentially
separate lifetimes.
Similar to how you specify copying behavior, you specify how objects
move with move constructors and move assignment operators.


Value Categories
Every expression has two important characteristics: its type and its value
category. A value category describes what kinds of operations are valid for
the expression. Thanks to the evolutionary nature of C++, value categories
are complicated: an expression can be a “generalized lvalue” (glvalue), a
“pure rvalue” (prvalue), an “expiring value” (xvalue), an lvalue (a glvalue
that isn’t an xvalue), or an rvalue (a prvalue or an xvalue). Fortunately for
the newcomer, you don’t need to know much about most of these value
categories.
We’ll consider a very simplified view of value categories. For now, you’ll
just need a general understanding of lvalues and rvalues. An lvalue is any
value that has a name, and an rvalue is anything that isn’t an lvalue.

lvalue and rvalue References
You can communicate to the compiler that a function accepts lvalues or
rvalues using lvalue references and rvalue references. Up to this point in this
book, every reference parameter has been an lvalue reference, and these
are denoted with a single &. You can also take a parameter by rvalue reference using &&.
Fortunately, the compiler does an excellent job of determining whether
an object is an lvalue or an rvalue. In fact, you can define multiple functions with the same name but with different parameters, and the compiler
will automatically call the correct version depending on what arguments
you provide when you invoke the function.

#include <cstdio>
void ref_type(int &x) { u
printf("lvalue reference %d\n", x);
}The Object Life Cycle 125
void ref_type(int &&x) { v
printf("rvalue reference %d\n", x);
}
int main() {
auto x = 1;
ref_type(x); w
ref_type(2); x
ref_type(x + 2); y
}
lvalue reference 1 w
rvalue reference 2 x
rvalue reference 3 y
Listing 4-33: A program containing an overloaded function with lvalue and rvalue
references
The int &x version u takes an lvalue reference, and the int &&x version v
takes an rvalue reference. You invoke ref_type three times. First, you invoke
the lvalue reference version, because x is an lvalue (it has a name) w. Second,
you invoke the rvalue reference version because 2 is an integer literal without
a name x. Third, the result of adding 2 to x is not bound to a name, so it’s an
rvalue y.

The std::move Function
You can cast an lvalue reference to an rvalue reference using the std::move
function from the <utility> header.

#include <utility>
--snip--
int main() {
auto x = 1;
ref_type(std::move(x)); u
ref_type(2);
ref_type(x + 2);
}

As expected, std::move changes the lvalue x into an rvalue u. You never
call the lvalue ref_type overload.

The C++ committee probably should have named std::move as std::rvalue, but it’s
the name we’re stuck with. The std:move function doesn’t actually move anything—
it casts.

Be very careful when you’re using std::move, because you remove the
safeguards keeping you from interacting with a moved-from object. You can
perform two actions on a moved-from object: destroy it or reassign it.
How lvalue and rvalue semantics enable move semantics should now be
clear. If an lvalue is at hand, moving is suppressed. If an rvalue is at hand,
moving is enabled.



Move Construction
Move constructors look like copy constructors except they take rvalue references instead of lvalue references.
Consider the SimpleString move constructor in Listing 4-35.
SimpleString(SimpleString&& other) noexcept
: max_size{ other.max_size }, u
buffer(other.buffer),
length(other.length) {
other.length = 0; v
other.buffer = nullptr;
other.max_size = 0;
}
Listing 4-35: A move constructor for SimpleString

Because other is an rvalue reference, you’re allowed to cannibalize
it. In the case of SimpleString, this is easy: just copy all fields of other into
this u and then zero out the fields of other v. The latter step is important:
it puts other in a moved-from state. (Consider what would happen upon the
destruction of other had you not cleared its members.)
Executing this move constructor is a lot less expensive than executing
the copy constructor.
The move constructor is designed to not throw an exception, so you
mark it noexcept. Your preference should be to use noexcept move constructors; often, the compiler cannot use exception-throwing move constructors
and will use copy constructors instead. Compilers prefer slow, correct code
instead of fast, incorrect code.



Move Constructors Help Improve Performance
There are cases where objects are subjected to copy steps automatically, due to the nature
of the language and its needs. Consider the following:
class MyString
{
// pick implementation from Listing 9.9
};
MyString Copy(MyString& source) // function
{
MyString copyForReturn(source.GetString()); // create copy
return copyForReturn; // return by value invokes copy constructor
}int main()
{
MyString sayHello ("Hello World of C++");
MyString sayHelloAgain(Copy(sayHello)); // invokes 2x copy constructor
return 0;
}
As the comment indicates, in the instantiation of sayHelloAgain, the copy constructor
was invoked twice, thus a deep copy was performed twice because of our call to function
Copy(sayHello) that returns a MyString by value. However, this value returned is very
temporary and is not available outside this expression. So, the copy constructor invoked
in good faith by the C++ compiler is a burden on performance. This impact becomes significant if our class were to contain objects of great size.
To avoid this performance bottleneck, versions of C++ starting with C++11 feature a
move constructor in addition to a copy constructor. The syntax of a move constructor is
// move constructor
MyString(MyString&& moveSource)
{
if(moveSource.buffer != NULL)
{
buffer = moveSource.buffer; // take ownership i.e. 'move'
moveSource.buffer = NULL; // set the move source to NULL
}
}
When a move constructor is programmed, the compiler automatically opts for the same
for “moving” the temporary resource and hence avoiding a deep-copy step. With the
move constructor implemented, the comment should be appropriately changed to the following:
MyString sayHelloAgain(Copy(sayHello)); // invokes 1x copy, 1x move constructors

You would ensure that your class cannot be copied by declaring a private copy constructor. This ensures that the function call DoSomething(ourPresident) will cause a
compile failure.




Move Assignment
You can also create a move analogue to copy assignment via operator=. The
move assignment operator takes an rvalue reference rather than a const
lvalue reference, and you usually mark it noexcept. Listing 4-36 implements
such a move assignment operator for SimpleString.
SimpleString& operator=(SimpleString&& other) noexcept { u
if (this == &other) return *this; v
delete[] buffer; wThe Object Life Cycle 127
buffer = other.buffer; x
length = other.length;
max_size = other.max_size;
other.buffer = nullptr; y
other.length = 0;
other.max_size = 0;
return *this;
}
Listing 4-36: A move assignment operator for SimpleString
You declare the move assignment operator using the rvalue reference
syntax and the noexcept qualifier, as with the move constructor u. The selfreference check v handles the move assignment of a SimpleString to itself.
You clean up buffer w before assigning the fields of this to the fields of
other x and zero out the fields of other y. Aside from the self-reference
check v and the cleanup w, the move assignment operator and the move
constructor are functionally identical.
Now that SimpleString is movable, you can complete the SimpleString constructor of SimpleStringOwner:
SimpleStringOwner(SimpleString&& x) : string{ std::move(x)u } { }
The x is an lvalue, so you must std::move x into the move constructor
of string u. You might find std::move odd, because x is an rvalue reference.
Recall that lvalue/rvalue and lvalue reference/rvalue reference are distinct
descriptors.
Consider if std::move weren’t required here: what if you moved from x
and then used it inside the constructor? This could lead to bugs that are
hard to diagnose. Remember that you cannot use moved-from objects
except to reassign or destruct them. Doing anything else is undefined
behavior.
Listing 4-37 illustrates the SimpleString move assignment.
--snip--
int main() {
SimpleString a{ 50 };
a.append_line("We apologize for the"); u
SimpleString b{ 50 };
b.append_line("Last message"); v
a.print("a"); w
b.print("b"); x
b = std::move(a); y
// a is "moved-from"
b.print("b"); z
}
a: We apologize for the w
b: Last message x
b: We apologize for the z
Listing 4-37: A program illustrating move assignment with the SimpleString class128 Chapter 4
As in Listing 4-31, you begin by declaring two SimpleString classes with
different messages: the string a contains We apologize for the u, and b contains Last message v. You print these strings to verify that they contain the
strings you’ve specified wx. Next, you move assign b equal to a y. Note that
you had to cast a to an rvalue using std::move. After the move assignment, a
is in a moved-from state, and you can’t use it unless you reassign it to a new
value. Now, b owns the message that a used to own, We apologize for the z.




The Final Product
You now have a fully implemented SimpleString that supports move and copy
semantics. Listing 4-38 brings these all together for your reference.
#include <cstdio>
#include <cstring>
#include <stdexcept>
#include <utility>
struct SimpleString {
SimpleString(size_t max_size)
: max_size{ max_size },
length{} {
if (max_size == 0) {
throw std::runtime_error{ "Max size must be at least 1." };
}
buffer = new char[max_size];
buffer[0] = 0;
}
~SimpleString() {
delete[] buffer;
}
SimpleString(const SimpleString& other)
: max_size{ other.max_size },
buffer{ new char[other.max_size] },
length{ other.length } {
std::strncpy(buffer, other.buffer, max_size);
}
SimpleString(SimpleString&& other) noexcept
: max_size(other.max_size),
buffer(other.buffer),
length(other.length) {
other.length = 0;
other.buffer = nullptr;
other.max_size = 0;
}
SimpleString& operator=(const SimpleString& other) {
if (this == &other) return *this;
const auto new_buffer = new char[other.max_size];
delete[] buffer;
buffer = new_buffer;
length = other.length;
max_size = other.max_size;
std::strncpy(buffer, other.buffer, max_size);The Object Life Cycle 129
return *this;
}
SimpleString& operator=(SimpleString&& other) noexcept {
if (this == &other) return *this;
delete[] buffer;
buffer = other.buffer;
length = other.length;
max_size = other.max_size;
other.buffer = nullptr;
other.length = 0;
other.max_size = 0;
return *this;
}
void print(const char* tag) const {
printf("%s: %s", tag, buffer);
}
bool append_line(const char* x) {
const auto x_len = strlen(x);
if (x_len + length + 2 > max_size) return false;
std::strncpy(buffer + length, x, max_size - length);
length += x_len;
buffer[length++] = '\n';
buffer[length] = 0;
return true;
}
private:
size_t max_size;
char* buffer;
size_t length;
};
Listing 4-38: A fully specified SimpleString class supporting copy and move semantics



Compiler-Generated Methods
Five methods govern move and copy behavior:
•	 The destructor
•	 The copy constructor
•	 The move constructor
•	 The copy assignment operator
•	 The move assignment operator
The compiler can generate default implementations for each under
certain circumstances. Unfortunately, the rules for which methods get
generated are complicated and potentially uneven across compilers.
You can eliminate this complexity by setting these methods to
default/delete or by implementing them as appropriate. This general rule
is the rule of five, because there are five methods to specify. Being explicit
costs a little time, but it saves a lot of future headaches.

[C++\Types&Values\Classes\Compiler Generated Methods.png]

If you provide nothing, the compiler will generate all five destruct/
copy/move functions. This is the rule of zero.
If you explicitly define any of destructor/copy constructor/copy assignment operator, you get all three. This is dangerous, as demonstrated earlier
with SimpleString: it’s too easy to get into an unintended situation in which
the compiler will essentially convert all your moves into copies.
Finally, if you provide only move semantics for your class, the compiler
will not automatically generate anything except a destructor.
