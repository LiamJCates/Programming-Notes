#### Scheduling

Threads don't just execute whenever they want to. A computer might have hundreds of processes with thousands of threads that all want their turn to run on just a handful of processors. So, how do they decide who goes first? That's the operating system's job.

The OS includes a scheduler that controls when different threads and processes get their turn to execute on the CPU. The scheduler makes it possible for a multiple programs to run concurrently on a single processor.

When a process is created and ready to run it gets loaded into memory and placed in the ready queue. It cycles through the ready processes so they get a chance to execute on the processor. If there are multiple processors, then the OS will schedule processes to run on each of them to make the most use of the additional resources. A process will run until it finishes and then the scheduler will assign another process to execute on that processor. Or, a process might get blocked and have to wait for an I/O event in which case, it'll go into a separate I/O waiting queue so another process can run. Or, the scheduler might determine that a process has spent its fair share of time on the processor and swap it out for another process from the ready queue. When that occurs, it's called a context switch. The operating system has to state the state or context of the process that was running so it can be resumed later. And it has to load the context of the new process that's about to run.

Context switches are not instantaneous. It takes time to save and restore the registers and memory state, so the scheduler needs a strategy for how frequently it switches between processes.

There's a wide variety of algorithms that different operating system schedulers implement. Some of these algorithms are preemptive which means they may pause or preempt a running low-priority task when a higher priority task enters the ready state. In non-preemptive algorithms, once a process enters the running state it'll be allowed to run for its allotted time.

Which algorithm a scheduler chooses to implement will depend on its goals. Some schedulers might try to maximize throughput or the amount of work they complete in a given time. Whereas others might aim to minimize latency to improve the system's responsiveness. Different operating systems have different purposes and a desktop OS like Windows will have a different set of goals and use a different type of scheduler than a real-time OS for embedded systems.

Now, while it's important to understand the concept of scheduling and that it's taking place, you usually don't need to worry about the nitty gritty details of how the scheduler works because it's often handled under the hood by the operating system. In fact, you might not have any control over when the parts of your program actually execute. This is an important thing to keep in mind. Avoid writing programs expecting that multiple threads or processes will execute in a certain order or for an equal amount of time, because the operating system may choose to schedule them differently from run to run.
