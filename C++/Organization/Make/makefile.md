## An Introduction to Makefiles



#### Creating And Running A makefile
The make utility follows the instructions in a text file called a makefile.

A simple makefile is a file that is named makefile with no extension

As a basic example, the makefile for a program called “hello” might contain:

```make
	hello.exe: hello.cpp
		g++ hello.cpp
```

This is a makefile comprised of a single rule
This rule indicates:
	hello.exe, a target
	hello.cpp, a prerequisite
	c++ hello.cpp, a recipe

This rule defines a relationship that ensures, when make is run:

	if the prerequisite file hello.cpp has a newer date than the target file hello.exe, make executes the recipe.

If you run:

make

the make program will look for a file named makefile in your directory, and then execute the rules that is lists.

There may be many rules, each with their own targets, prerequisites, and recipes. By creating such rules, you can modify any of your source code files, execute make and be certain that all the affected files will be rebuilt correctly.



### Naming a makefile
By default, when make looks for the makefile, it tries searching the current directory for the following names, in order:

	GNUmakefile, makefile and Makefile

(Only GNU make will look for GNUMakefile, so give it that name only if you know you're using GNU tools)


If you want to use a nonstandard name for your makefile, you can specify the makefile name with the ‘-f’ or ‘--file’ option. The arguments ‘-f name’ or ‘--file=name’ tell make to read the file name as the makefile.

If you use more than one ‘-f’ or ‘--file’ option, you can specify several makefiles. All the makefiles are effectively concatenated in the order specified.

The default makefile names GNUmakefile, makefile and Makefile are not checked automatically if you specify ‘-f’ or ‘--file’.



### makefile Contents

Most often, the makefile tells make how to compile and link a program.

This document will discuss a simple makefile that describes how to compile and link a text editor which consists of eight C source files and three header files. The makefile can also tell make how to run miscellaneous commands when explicitly asked (for example, to remove certain files as a clean-up operation).

When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor.

What a Rule Looks Like
A simple makefile consists of “rules” with the following shape:

```make
target ... : prerequisites ...
	recipe
	...
	...
```

where:

target
is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’

prerequisite
is a file that is used as input to create the target. A target often depends on several files.

recipe
is an action that make carries out.

A recipe may follow each line that contains a target and prerequisites. These recipes say how to update the target file. A recipe may have more than one command, either on the same line or each on its own line.

```
NOTE: begin every recipe line with a tab character, this is an obscurity that catches the unwary. Other than that, whitespace is generally ignored so you can format for readability.
```

Bear in mind that make does not know anything about how the recipes work. It is up to you to supply recipes that will update the target file properly. All make does is execute the recipe you have specified when the target file needs to be updated. A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target.

A rule can also explain how and when to carry out an action. Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, in the following section, the rule containing the delete command associated with the target 'clean' does not have prerequisites. The target 'clean' is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, 'clean' is not a prerequisite of any other rule. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified recipe. Targets that do not refer to files but are just actions are called phony targets.

A makefile may contain other text besides rules, but a simple makefile need only contain rules. Rules may look somewhat more complicated than shown in this template, but all fit the pattern more or less.



### A Simple Makefile

This makefile describes how an executable file called edit depends on
	eight object files:
	main.o, kdb.o, command.o, display.o, insert.o, search.o, files.o, utils.o

	which, in turn, depend on eight C source files:
	main.c, kdb.c, command.c, display.c, insert.c, search.c, files.c, utils.c

	and three header files:
	defs.h command.h buffer.h

In this example,
	all the C files include defs.h
	only those defining editing commands include command.h
	only low level files that change the editor buffer include buffer.h

```make
edit : main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

	cc -o edit main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o

main.o : main.c defs.h
	cc -c main.c

kbd.o : kbd.c defs.h command.h
	cc -c kbd.c

command.o : command.c defs.h command.h
	cc -c command.c

display.o : display.c defs.h buffer.h
	cc -c display.c

insert.o : insert.c defs.h buffer.h
	cc -c insert.c

search.o : search.c defs.h buffer.h
	cc -c search.c

files.o : files.c defs.h buffer.h command.h
	cc -c files.c

utils.o : utils.c defs.h
	cc -c utils.c

clean :
	rm edit main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o
```

We split each long line into two lines using backslash/newline; this is like using one long line, but is easier to read.

For more information on splitting lines, see:
[C++\Organization\Make\SplittingLines.md]


To use this makefile to create the executable file called edit, type:

make

To use this makefile to delete the executable file and all the object files from the directory, type:

make clean

In the example makefile, the targets include the executable file ‘edit’, and the object files ‘main.o’ and ‘kbd.o’.

The prerequisites are files such as ‘main.c’ and ‘defs.h’. In fact, each ‘.o’ file is both a target and a prerequisite.

Recipes include ‘cc -c main.c’ and ‘cc -c kbd.c’

When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first.

In this example, edit depends on each of the eight object files; the object file main.o depends on the source file main.c and on the header file defs.h.



### How make Processes a Makefile
By default, make starts with the first target (not targets whose names start with ‘.’). This is called the default goal. Goals are the targets that make strives ultimately to update.

In the simple example of the previous section, the default goal is to update the executable program edit; therefore, we put that rule first.

Thus, when you give the command:

make

make reads the makefile in the current directory and begins by processing the first rule.

In the example, this rule is for relinking edit; but before make can fully process this rule, it must process the rules for the files that edit depends on, which in this case are the object files.

Each of these files is processed according to its own rule.

These rules say to update each ‘.o’ file by compiling its source file. The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist.

The other rules are processed because their targets appear as prerequisites of the goal.

If some other rule is not depended on by the goal (or anything it depends on, etc.), that rule is not processed, unless you tell make to do so (with a command such as make clean).

Before recompiling an object file, make considers updating its prerequisites, the source file and header files.

This makefile does not specify anything to be done for them — the ‘.c’ and ‘.h’ files are not the targets of any rules — so make does nothing for these files.

After recompiling whichever object files need it, make decides whether to relink edit.

This must be done if
	the file edit does not exist
	any of the object files are newer than it.

If an object file was just recompiled, it is now newer than edit, so edit is relinked.

For example

if we change a single file like insert.c and run make, make will compile that file to update insert.o, then link edit.

If we change the file command.h and run make, make will recompile the object files kbd.o, command.o and files.o, as they all have command.h as a prerequisite, then link the file edit.







### Variables Make Makefiles Simpler

A makefile may contain variables that allow for simple and convenient string replacement.

A makefiles might use a macro to invoke the C++ compiler:

```make
	CPP = mycompiler 			#like g++
	hello.exe: hello.cpp
		$(CPP) hello.cpp
```

The = is used to identify CPP as a variable, and the $ and parentheses expand the variable at any location that follows it's declaration in the makefile.

In this case, the expansion means that the variable call $(CPP) will be replaced with the string "mycompiler".

With the variable above, if you want to change to a compiler like
g++, you just change the variable to:

	CPP = g++

This variable can then be used anytime we want to invoke the compiler in the makefile.

You can also add compiler flags, etc., to the macro, or use separate macros to add compiler flags.

The advantage of variables becomes relevant when we want to change something in multiple places. If we define a variable, anytime that we need to change the string that the variable represents we can change the string at a single location, the variable definition, rather than at every location that the variable might be used.

In our example, we had to list all the object files twice in the rule for edit (repeated here):

```make
edit : main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

	cc -o edit main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o
```

Such duplication is error-prone; if a new object file is added to the system, we might add it to one list and forget the other.

We can eliminate the risk and simplify the makefile by using a variable.

A variable would allow a text string to be defined once and substituted in multiple places later.

It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names.

We would define such a variable objects with a line like this in the makefile:

```make
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
```

Then, each place we want to put a list of the object file names, we can substitute the variable’s value by writing '$(objects)'

Here is how the complete simple makefile looks when you use a variable for the object files:

```make

objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

main.o : main.c defs.h
	cc -c main.c

kbd.o : kbd.c defs.h command.h
	cc -c kbd.c

command.o : command.c defs.h command.h
	cc -c command.c

display.o : display.c defs.h buffer.h
	cc -c display.c

insert.o : insert.c defs.h buffer.h
	cc -c insert.c

search.o : search.c defs.h buffer.h
	cc -c search.c

files.o : files.c defs.h buffer.h command.h
	cc -c files.c

utils.o : utils.c defs.h
	cc -c utils.c

clean :
	rm edit $(objects)
```






### Letting make Deduce the Recipes

It is not necessary to spell out the recipes for compiling the individual C source files, because make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command.

For example, it will use the recipe ‘cc -c main.c -o main.o’ to compile main.c into main.o.

We can therefore omit the recipes from the rules for the object files.

When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe.

Here is the entire example, with both of these changes, and a variable objects as suggested above:

```make
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

clean :
	rm edit $(objects)
```

This is how we would write the makefile in actual practice. Because implicit rules are so convenient, they are important. You will see them used
frequently.



### Another Style of Makefile
When the objects of a makefile are created only by implicit rules, an alternative style of makefile is possible. In this style of makefile, you group entries by their prerequisites instead of by their targets. Here is what one looks like:

```make
objects = main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

Here defs.h is given as a prerequisite of all the object files; command.h and buffer.h are prerequisites of the specific object files listed for them.

Whether this is better is a matter of taste: it is more compact, but some people dislike it because they find it clearer to put all the information about each target in one place.



### Rules for Cleaning the Directory

Compiling a program is not the only thing you might want to write rules for.

Makefiles commonly tell how to do a few other things besides compiling a program: for example, how to delete all the object files and executables so that the directory is ‘clean’.

Here is how we could write a make rule for cleaning our example editor:

```make
clean:
	rm edit $(objects)
```

A rule such as this should not be placed at the beginning of the makefile, because we do not want it to run by default! Thus, in the example makefile, we want the rule for edit, which recompiles the editor, to remain the default goal.

Since clean is not a prerequisite of edit, this rule will not run at all if we give the command no arguments:

make

In order to make the rule run, we have to type

make clean


In practice, we might want to write the rule in a somewhat more complicated manner to handle unanticipated situations. We would do this:

```make
.PHONY : clean

clean :
	-rm edit $(objects)
```

This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm.

# (See Section 4.5 [Phony Targets], and Section 5.5 [Errors in Recipes])



### How make Reads a Makefile

GNU make does its work in two distinct phases.

	During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values and implicit and explicit rules, and builds a dependency graph of all the targets and their prerequisites.

	During the second phase, make uses this internalized data to determine which targets need to be updated and run the recipes necessary to update them.

It’s important to understand this two-phase approach because it has a direct impact on how variable and function expansion happens; this is often a source of some confusion when writing makefiles.

Below is a summary of the different constructs that can be found in a makefile, and the phase in which expansion happens for each part of the construct.

We say that expansion is immediate if it happens during the first phase: make will expand that part of the construct as the makefile is parsed.

We say that expansion is deferred if it is not immediate.

Expansion of a deferred construct part is delayed until the expansion is used: either when it is referenced in an immediate context, or when it is needed during the second phase.

You may not be familiar with some of these constructs yet. You can reference this section as you become familiar with them, in later chapters.

Variable Assignment

Variable definitions are parsed as follows:

immediate = deferred
immediate ?= deferred
immediate := immediate
immediate ::= immediate
immediate += deferred or immediate
immediate != immediate

define immediate
	deferred
endef

define immediate =
	deferred
endef

define immediate ?=
	deferred
endef

define immediate :=
	immediate
endef

define immediate ::=
	immediate
endef

define immediate +=
	deferred or immediate
endef

define immediate !=
	immediate
endef

For the append operator ‘+=’, the right-hand side is considered immediate if the variable was previously set as a simple variable (‘:=’ or ‘::=’), and deferred otherwise.

For the shell assignment operator ‘!=’, the right-hand side is evaluated immediately and handed to the shell. The result is stored in the variable named on the left, and that variable becomes a simple variable (and will thus be re-evaluated on each reference).



### Conditional Directives
Conditional directives are parsed immediately. This means, for example, that automatic variables cannot be used in conditional directives, as automatic variables are not set until the recipe for that rule is invoked.

If you need to use automatic variables in a conditional directive you must move the condition into the recipe and use shell conditional syntax instead.



### Rule Definition
A rule is always expanded the same way, regardless of the form:

immediate : immediate ; deferred
	deferred

That is, the target and prerequisite sections are expanded immediately, and the recipe used to build the target is always deferred. This is true for explicit rules, pattern rules, suffix rules, static pattern rules, and simple prerequisite definitions.



### How Makefiles Are Parsed
GNU make parses makefiles line-by-line.

Parsing proceeds using the following steps:
1. Read in a full logical line, including backslash-escaped lines.

2. Remove comments.

3. If the line begins with the recipe prefix character and we are in a rule context, add the line to the current recipe and read the next line (see Section 5.1 [Recipe Syntax], page 43).

4. Expand elements of the line which appear in an immediate expansion context (see Section 3.7 [How make Reads a Makefile], page 16).

5. Scan the line for a separator character, such as ‘:’ or ‘=’, to determine whether the line is a macro assignment or a rule (see Section 5.1 [Recipe Syntax], page 43).

6. Internalize the resulting operation and read the next line.

An important consequence of this is that a macro can expand to an entire rule, if it is one line long. This will work:

myrule = target : ; echo built
	$(myrule)

However, this will not work because make does not re-split lines after it has expanded them:

define myrule

target:
	echo built
endef

$(myrule)

The above makefile results in the definition of a target ‘target’ with prerequisites ‘echo’ and ‘built’, as if the makefile contained

target: echo built

rather than a rule with a recipe.

Newlines still present in a line after expansion is complete are ignored as normal whitespace.

In order to properly expand a multi-line macro you must use the eval function: this causes the make parser to be run on the results of the expanded macro (see Section 8.9 [Eval Function], page 97).


Secondary Expansion pg 31
