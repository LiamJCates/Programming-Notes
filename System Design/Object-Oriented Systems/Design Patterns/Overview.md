# Design Patterns in Java: The Big Picture

Design patterns capture knowledge from experts that provide best practice to solve a particular problem.

Design patterns help you:
improve your object-oriented skills
not reinvent the wheel
use a common vocabulary for more precise and simpler communication.

This document is an overview of design patterns as described by the Gang of Four book.
<br/><br/>

## What Are Design Patterns?

The Gang of Four that refers to four authors, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. In 1995, they raised the book that popularized design patterns in our field, Design Patterns: Elements of Reusable Object-Oriented Software, often referred as the GoF or Gang of Four book.

What exactly is a design pattern?
The definition you can find almost everywhere is that a design pattern is a solution to a problem in a context. But this definition is kind of incomplete.
Context is the situation in which the pattern applies.
Problem is what you are trying to achieve and any constraints of the context.
The solution is what solves the problem in that context.

Also, patterns are not described and documented in terms of just problems, context, and solutions.
An important part of a pattern is its name.
A name allows us to talk about the pattern and communicate its intended solution.

A more complete definition is this, a pattern is a reusable and named solution to a recurring problem in a context.

Patterns are discovered, not created. They represent good design techniques, and unless the pattern has been successfully applied in a few real-world situations, it cannot qualify as a pattern.

For now to really understand design patterns, you must know the basics of object-oriented programming, so let's review the most important concepts.
<br/><br/><br/>

## Object-oriented Programming Building Blocks

In object-oriented programming, objects contain the functionality of the application. To build this object, you apply four concepts or building blocks, which are abstraction, encapsulation, inheritance, and polymorphism.

### Abstraction
Abstraction is about identifying the essential details or characteristics of an object with the objective of hiding the complexity of how they are implemented.

In Java, abstraction is achieved through interfaces and abstract classes.
For example, consider and Engine interface, to use it we just have to know it provides two methods, a start and a stop. We don't need to know how it does it, the inner mechanisms, and this process can be repeated at higher levels of abstraction. For example, we can use the abstraction of an engine to compose an abstraction of a car.

### Encapsulation
Encapsulation is about hiding information, deciding what an object should expose to the world.
Here the idea is to protect one part of your application from other parts. This way when you have to change one part, you don't have to change all the other parts too. This also applies to behavior, it's not just for data. Because for a lot of people encapsulation just means making your member variables private and providing setter and getter methods to control access to these variables. And yes, this is a form of encapsulation, but there's more than that. Encapsulation can also help you separate behavior from other parts of your application. For example, instead of having a big method in the Car class for checking all the types of engine a car can have, we can extract or encapsulate this functionality in a separate class, EngineChecker. And now the Car class will have to use this class to access the functionality. It's the same principle as with data, separating parts of your application to protect the access to them.

### Inheritance
Inheritance is the process by which one class can inherit the methods and properties from another class.
Inheritance lets you build classes based on other classes to avoid duplicated code. In Java, inheritance is achieved by extending the class or implementing an interface. In the EngineChecker class, instead of having a big method to check each type of engine, we can create sub classes for each type. For example, one for FourCylinderEngines and another one for V6Engines.

### Polymorphism
Polymorphism is closely related to inheritance
when one class inherits from another, polymorphism allows a subclass to stand in for the superclass.

You can write code that works on the superclass and also on any of its subclasses, making your code more flexible because if you need new functionality, you could grab a new subclass, and the actual object type is decided at runtime. For example, in addition to creating objects using just the base class EngineChecker, we can create objects of the subclass V6EngineChecker using a reference of type Engine, and thanks to polymorphism, the right method will be called at runtime.
<br/><br/><br/>

## Object-oriented Programming Principles

A design principle is a technique that can be applied when designing or writing code to make it more maintainable, flexible, or extensible.

One of the main problems when developing software is dealing with change. Software that is not well designed breaks easily at the first sign of change, but well-designed software can be changed easily.

### SOLID principles
The most popular set of principles are the SOLID principles.

SOLID is an acronym for
* Single responsibility
* Open-closed
* Liskov substitution
* Interface segregation
* Dependency injection

### Single Responsibility
The Single Responsibility principle states a class should only do one thing, this way you're making sure each class has only one reason to change. When you see a class that has more than one reason to change, it's probably trying to do too many things. Take for example this Car class represented in a UML class diagram, drive, fillTank, changeTires. Sounds like this class is trying to do too many things. So maybe it could be better to have some methods to start and stop the car in the Car class and move the drive and fillTanks methods to a Driver class, passing a current instance as a parameter of these methods. In the same way, we can move the changeTires method to a Mechanic class.

### Open-Closed
The Open-Closed principle states classes will be open for extension and closed for modification. This means allowing change, but in a way that doesn't require you to modify existing code. The easiest way to apply this principle is by using inheritance. For example, instead of modifying the Car class to make it behave like an SUV, we can extend it to create an SUVCar subclass. Applying this principle is actually a combination of applying encapsulation and abstraction. The behavior that stays the same is abstracted into a base class and locked for a modification. When you need new or different behavior, subclasses can handle the changes by extending the base class.

### Liskov Substitution
The Liskov substitution principle says that when you inherit from the class, you must be able to substitute the subclass for base class without things going wrong. When you use inheritance, your subclass gets almost all the methods and fields from the superclass. If you use inheritance incorrectly, you're going to end up with methods and fields that probably don't make sense or that you don't need on your subclass. For example, can you actually use an SUVCar class instead of the more generic Car class? Does it make sense in your application? That's what the Liskov substitution principle is about.

### Interface Segregation
The interface segregation principle says that you should define fine-grained interfaces as specific to the client that is going to use them. This means that it's better to have many as modern interfaces than fewer bigger interfaces. For example, let's say we have an interface with the methods start, stop, activate4WheelDrive, and openSunRoof. And for the purpose of this example, the interface doesn't violate the single responsibility principle. So following the interface segregation principle, we can break this interface into three smaller ones, separating the FourWheel and the SunRoofBehaviors. Not every car has a 4-wheel system or a sun roof, so this will allow us to make different combinations.

### Dependency Injection
The Dependency Injection principle states high-level modules should not depend on low-level modules; however, both should depend upon instructions, which can be interfaces or after classes. In this example, the Car class depends on Engine, the base class for FourCylinderEngine and V6Engine. This way through polymorphism we can inject into Car either one of these subclasses.

### Other Principles
There are many other principles that I'll be mentioning throughout the course, the don't repeat yourself principle, or DRY for short, about avoiding duplicated code, encapsulate what changes to protect your classes for unnecessary changes, favor composition over inheritance because object composition is an alternative to class inheritance that allow us to keep each class encapsulated and focused on one task, and programming to an interface, not an implementation because by using interfaces, your code will work with all the present and future implementations, which give you flexibility. If you know these principles by heart, your software well be well designed. But you don't have to start from scratch with these principles, it's better to reuse solutions that have worked for us in the past. The same patterns represent these reasonable solutions, and they are based on all these principles. We can say that principles are low-level design knowledge and patterns are high level. Patterns are proven solutions that other experts have applied successfully, and everyone can apply them without having to rediscover them.
<br/><br/><br/>

## Pattern Classification
Now let's talk about how the Gang of Four patterns are classified.
Classifications allow thinking at a higher level of abstraction. The GoF patterns can be classified in many ways, but there are two that stand out.

### Purpose
The first and most popular is by purpose. This includes three categories, creational, behavioral, and structural.
There are five creational patterns related to object instantiation, providing a way to decouple the code that creates the object from the object itself.
There are 11 behavioral patterns which concern how objects interact and distribute responsibility.
There are seven structural patterns which describe how classes and objects are composed to create new structures or functionality.

Classifying patterns allow us to compare and understand patterns more easily because we can talk about a set of patterns as a group. For example, you might need a creational pattern without knowing exactly which one, and still talk about the pattern that can help you create an object in a certain way.


### Scope
We can also classify patterns by a scope into class and object patterns.
Class patterns describe how relationships between classes are primarily defined via inheritance. These relationships are established at compile time. And here's an important thing, notice how there are only four patterns in this category. Now see how many patterns fall under the object category. The difference is remarkable. Object patterns describe relationships between objects that are primarily defined by composition. These relationships are created at runtime and are more dynamic and flexible than the ones defined by inheritance. That's why most of the patterns are about the replacing inheritance with composition.
<br/><br/><br/>

## Things to Remember

In this module, you have learned that the same patterns oriented in the field of architecture with the work of Christopher Alexander. While in the software field, patterns were popularized by the Gang of Four and their book Design Patterns: Elements of Reusable Object-Oriented Software. We reviewed the definition of a pattern, a reusable and named solution to our recurring problem in a context. Patterns represent good design techniques that have been successfully applied by other experts and that you can also apply. However, to really understand patterns, you must know the four building blocks of object-oriented programming, abstraction, encapsulation, inheritance, and polymorphism, as well as object-oriented design principles like the SOLID principles of single responsibility, open-closed, Liskov substitution, interface segregation, and dependency injection, and other principles like don't repeat yourself, encapsulate what changes, favor composition over inheritance, and programming to interfaces. But remember, these principles and concepts will help you understand patterns and even discover other patterns, but usually it's better to take advantage of the high-level solutions that patterns provide. Finally, you learned that by classifying patterns, we can easily talk about them, compare them, and understand them. The most common classification organizes patterns by their intent or purpose in creational, behavioral, and structural patterns. We also reviewed another classification by a scope, that tell us if their relationships between classes described by the pattern are primarily defined by inheritance or composition. Now in the next module, I'll talk about the importance of learning patterns, and I'll show you an example of how a pattern can be applied to improve a design. Take care, and thanks for watching.
<br/><br/><br/>

## Why Are Design Patterns Important?

### The Importance of Patterns

Why should you learn design patterns?
Well, it's like playing a sport, for example. To play a sport you have to know its rules, but knowing the rules is not enough to be a good player. In addition to practicing a lot, you also need good guidance, knowledge from experts. You get that knowledge from playbooks and coaches.

Patterns are the equivalent of software playbooks.
They capture expert knowledge to create well-designed software. Understanding by well-designed software, software that is flexible, easy to maintain, and reusable, so it can change without too much rework. In particular, since patterns are about reusing expert knowledge, they help you by making sure you are not trying to solve a problem that someone else has already figured out. Patterns also help you find an appropriate design. Sometimes the hardest part of object-oriented design is the composing a problem into objects. Some objects come from the analysis of the business domain, but most of the time in the design phase, you end up with classes that have no counterparts in the real world. Design patterns help you identify not so obvious abstractions and the objects that represent them. Under granularity, in other words, what should be in an object, also patterns have an impact in communication and documentation. They give you a shared vocabulary that is precise and complete, and that you can use in meetings, discussions, documentation, and in code as comments and naming conventions. It's in of the same saying something like I encapsulated this behavior in an interface, implementing each variation in a class that I will inject in this other class to delegate the behavior, instead of just saying I used the strategy pattern. Precise, complete, and easy to understand once you know about this pattern. And talking about the strategy pattern, let's see how this pattern and some design principles and replacing inheritance with composition for a more flexible design.

From Inheritance to Composition with the Strategy Pattern

Most design patterns are about the replacing inheritance with composition because in many situations composition produces a more flexible design.

Example:
Let's say we have a class MediaFile that represents video and audio files. Among other methods, we have the method play to reproduce the file, and compress to compress the file with a general purpose compression algorithm.

While methods like compress apply to both types of files, methods like play have to be implemented in a different way for each type of file. We can do that with if and else statements, but we are talking about object-oriented programming here, so the most obvious solution is using inheritance.
Have a video and an audio subclass, both defining a play method.

But you know how things are, the requirements are always changing, and now we have to support another type of file, images. And here's where the problems start appearing...

1) An image can't be played, we view images
Of course we can implement the play method with the code to be an image, but this can be confusing, the name of the method doesn't describe what it does. We can add the method view to the superclass, but then all the classes will inherit this method. Do you remember the Liskov substitution principle? This principle says that the objects of the superclass should be replaceable with objects of its subclasses without breaking the application. This design doesn't follow this principle.

2) The design is not flexible.
What if we need to support animated GIF images? The animation can be played, so we could add another class to the hierarchy, PlayableImage. But now we have two classes related to images. Probably they have methods in common, so we can have a superclass for images from which the classes NonPlayableImage and PlayableImage can extend. As you can see, this is starting to become a mess. Have you ever heard the term subclass explosion? It happens when the number of classes needed to have a new functionality to a given class hierarchy grows exponentially.

Solution
To solve these problems, we are going to use the strategy pattern.
The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. A strategy lets the algorithm vary independently from clients that use it. In other words, it allows you to change a part of a system independently of all other parts and swap out behavior at runtime. There's a principle that says that we shall separate behavior that changes from behavior that stays the same.

In this example, the behavior that changes is the PlayBehavior. So following the design principle of programming to an interface, not an implementation will create the interface PlayBehavior and the classes for playing video, audio, and image animations will implement that interface. By the way, program to an interface actually means program to a super type. It doesn't have to be an interface, it can be an installed class. The point is to use polymorphism by programming to a super type to avoid locking the type of an object at runtime. This will also allow us to add new behaviors without modifying the code that uses this hierarchy.

Now the key is that the MediaFile class will have a field of type PlayBehavior
The PlayBehavior object will be used to delegate the playing behavior instead of implementing it directly in the play method.

This is how the structure of the classes looks now. That's how the strategy pattern in its basic form looks once it's implemented. In code, we have a private field of type PlayBehavior which is set in the constructor of the class. The play method just checks if the PlayBehavior is set. It delegates the functionality to that implementation; otherwise, a message is printed. And we can also add a setter method to change the implementation dynamically. This way when we create an object of this class, if we pass an instance of PlayVideo, the file will be played as video. If we set the behavior to PlayAudio, the class will be played as audio. Or we can set the behavior to null to have no play behavior for images. MediaFile doesn't care which implementation is being used. This is the strategy pattern. Of course there can be many more variations or more behaviors, but the point here is that by changing the relationship from inheritance to composition, we have a more flexible design, a design that encapsulates a family of behaviors into their own set of classes and lets you change them at runtime. However, you might be thinking is this really a design pattern? Isn't this just polymorphism? Okay, this is a simple pattern, but it's not just polymorphism. The pattern uses polymorphism to make the behaviors interchangeable, but it's better to think of the strategy pattern as a mix of the following principles, encapsulating what changes, favoring composition over inheritance, the open-close principle, and programming to interfaces. You could know nothing about patterns, but if you know this and the other principles we have talked about, you will have well-designed software. However, design patterns offer shortcuts to apply solutions that have worked before, so there's no need to reinvent the wheel. Since they are based on simple ideas like favoring composition over inheritance, many of them actually look very much the same. For example, this is the canonical UML diagram of the strategy pattern, and this is the diagram of the state pattern. It's the same. The only difference is the intention of the pattern. The state pattern is used when an object changes its behavior based on its internal state. And look at the diagram of another pattern, abstract factory. You don't have to know what is this pattern about, just by looking at this diagram, you can see it's a special case of the strategy pattern. It just adds another hierarchy to deal with a family of products or objects. Now let's wrap up this module.


Things to Remember

Design patterns capture knowledge from experts. They allow you to reuse that knowledge, find the appropriate design in terms of identifying objects and their granularity, and give you a vocabulary that you can use in meetings, documentation, and in the code for a more precise and complete communication. Usually IS-A relationship is implemented with inheritance and a HAS-A relationship with composition, but the truth is that in many situations you can replace inheritance with composition. With composition, you get new functionality by assembling or composing objects. This way no internal details of those objects are visible. They appear as black boxes, which helps you keep each class encapsulated on focused on one task. Using design principles, I showed you how to replace inheritance with composition while at the same time implementing the strategy design pattern, but you don't have to start from design principles every time, that's what patterns are for. However, you need to study and know patterns well. So beginning with the next module, I'll give you a high-level overview of the most important Gang of Four patterns. So I'll see you in the next module. Take care, and thanks for watching.


Getting to Know the Behavioral Design Patterns
Behavioral Patterns

Behavioral patterns describe how objects or classes should communicate, as well as their responsibilities. The Gang of Four book describes 11 patterns in this category; however, only 2, interpreter and template method use inheritance to distribute behavior between classes. For example, the interpreter pattern represents a grammar as a class hierarchy and implements an interpreter as an operation on instances of these classes. On the other hand, the rest of the patterns use object composition to achieve their purpose. Some describe how we can encapsulate behavior in an object to delegate functionality like the iterator pattern, which abstracts the way to access the elements of an aggregate object without exposing its underlying representation, or the visitor pattern, which encapsulates an operation that has to be performed on the elements of an object structure. Other patterns describe how a group of objects work to perform a task instead of letting a single object carrying the task out by itself, like the chain of responsibility pattern that lets you send requests through a chain of objects where any of them may fulfill their request depending on runtime conditions. Or mediator, which promotes loose coupling by keeping objects from referring to each other explicitly, acting as an intermediary between them. In this module, I'll give you an overview of the most popular behavioral patterns, the strategy and the state pattern, which are basically the same pattern, but with different intentions, the command pattern, and the observer, and template method patterns. I talked about the strategy pattern in a previous module, but here I'll review it in the context of behavioral patterns and to compare it to the state pattern.
The Strategy and State Patterns

One important part of a pattern is its name. We have talked about this before. Among other things, it allows us to learn what the pattern is about. In the case of the strategy pattern, a strategy is a synonym for a plan or an approach for doing something. A strategy can be also compared to an algorithm, something that produces an output from an input. When developing software, these strategies, plans, approaches, or algorithms come in groups or families. I mean many strategies can have the same inputs and outputs, but different implementations are ways of performing an operation to produce the same output. This can make the code complex, for example, when selecting the strategy to execute with if else statements, or when the execution of many strategies results in many paths or branches. However, the strategy pattern can help us simplify the code in these cases because strategies of the same group can have the same interface to make them interchangeable, so what we need to do is create an interface that defines the operation that we want to encapsulate and implement the interface with classes that represent each strategy. Then we need to modify the class that is going to select and use an instance of the strategy class. This class in the pattern's documentation is called context and has a reference to the strategy interface. This way via polymorphism, we can configure any of the concrete classes that represent a variation of the strategy. That's the strategy pattern, but you can replace the words strategy or algorithm with the word state from what I have said so far, and everything will fit almost perfectly. On paper, these two patterns look exactly the same; however, the intention is different. An object's state is the combination of the values of its attributes. For example, for this Switch class, brand, devices, and isOn, by calling setter methods to change the values of these attributes, you can change the object's state; however, sometimes there's an attribute that stands out, that when we refer to the object's state, we're actually referring to that attribute. For example, for this Switch class, this attribute will be the one that tells us if the switch is off or on. As a result, there's usually code spread through many of the class methods telling it how to behave according to the value of this attribute, sometimes implemented with if statements. The problem is that if there's another state value you need to support, you have to change a lot of if statements in several methods, so what the state pattern says is that we should model states as objects, encapsulating a state as specific methods in separate classes. For this, first we create either an interface or an abstract class to hold the methods that change according to the state of the object. And then create classes that represent each possible state. These classes will implement the interface or extend the after class to redefine the behavior of the methods according to the state. This way just like in the strategy pattern, we use composition to have a variable of type SwitchState in the Switch class, and delegate the functionality of the methods change, status, and complete to either switch on or switch off at runtime if you change this implementation, in other words, if you change the state, the functionality of the methods will also change. So that's the state pattern. Now let's take a look at the command pattern.
The Command Pattern

In a few words, the command pattern encapsulates method invocations. Usually you execute the method just by calling it using an object reference and optionally passing one or more arguments. Let's assume we have a menu object that supports operations like opening, saving, deleting, or printing a file. Each time you want to support a new operation, you have to add a method to this class and code the method invocation in the appropriate part of the application. But what if you want to make the invocation more generic? Maybe you could have just an execute method. And instead of passing a value as the argument of this method, you could pass an object, a command object that encapsulates an operation. ExecuteAction will not have any idea what the operation is, it will just call the method of the command object that gets the work done. Let's call it execute, this way you can use an anonymous class to define what the execute method does, or better yet, a lambda expression, and this verbose representation of an anonymous class. So now to support a new operation like saving a file, instead of defining another method in the menu class, you just pass the operation as an argument of the generic method, executeAction. So to encapsulate commands or method invocations like in the other behavioral patterns, you define a super type, which can be an interface or abstract class exposing one method usually called execute, and for each particular command you want to support, you define a subclass that overrides the execute method in a particular way. In addition to command object, this pattern talks about other objects. First, we have client that creates a command object. In the example of the menu, client can be an app or menu bar class. Then the client sets the command on an invoker object maybe using a setter method. In the example, the invoker is the menu class. At some point, the invoker calls the command's execute method. However, sometimes the command object doesn't actually perform the operations, sometimes it has a reference to a receiver object, usually set by the client class, and the execute method delegates the operations to the receiver object. In the example a SaveFileCommand object and delegate the actual saving operation to a file class, which will act as the receiver. Having a receiver is optional, it's better to have one for flexibility, but command objects can implement most, if not all of the logic needed to execute a request. To recap, the command pattern uses a super type for all commands, exposing an execute method. Each concrete command redefines this method to implement a particular operation. The invoker halts the command and invokes its execute method to carry out a request. Sometimes this execute method invokes a method on a receiver class to fulfill the request. And the client is responsible for creating the concrete command and setting its receiver. In a variation of the command pattern, since the operation is encapsulated in a command object, this method can implement a method to undo the operation performed by the execute method. That's why undo operations are often implemented with the command pattern. Alright, now let's talk about the observer pattern.
The Observer Pattern

The observer pattern is about notifying one or more objects when the state of another object changes. For example, let's assume we have an Order class that represents a sales order, and this class has to send an email to the client when the products of the order have been shipped. Usually inside the Order class we will have a shipOrder method that will contain the instruction to send an email to the client, but you know, requirements are always changing, and now as soon as the order is shipped, we need to create an invoice. So now we need to modify the shipOrder method to have the code to create an invoice, but what if another object also needs to be notified when an order has been shipped? Do you realize the problem or problems with this approach? First, for every new operation that we need to support when an order has shipped, we need to modify the code of the Order class. Second, there's no way to add or remove operations at runtime. Also, we are not following some design principles, we are not encapsulating the part that changes, and we are programming to concrete implementations, not interfaces. Basically the problem we are facing here is how do we notify one or more subscribers when a publisher publishes events, and in such a way that we can dynamically add or remove subscribers without changing the publisher and her coding references between subscribers and publishers. The observer patterns offers a solution to this problem. Just as other patterns do, it creates a hierarchy for the objects that need to be notified. They are called observers. This way, we can have a client subclass that will redefine the update method to send an email, and an invoice of class that will redefine the update method to create an invoice and so on. The point is that all the classes that have to be notified when an order has been shipped can implement this interface so that Order class only has to deal with one type of classes, observer. The Order class can have methods to register or remove observers. The most common implementation, it stores them in a list. And now the shipOrder method will only have to call another method, notifyObservers that iterates over the observer's list, calling their update method. The Order class is called subject, and the observer pattern says that you can also create a hierarchy for subjects, so we can reuse and change subjects and observers independently of each other. To add new observers at any time, the only thing the subject needs to know about an observer is that it implements the observer interface. We never need to modify the subject. In addition, a concrete observer can have a reference to its subject in case it needs to pull out some state from it. And that's how the observer pattern provides a design where subjects and observers are loosely coupled. In other words, a design that can handle change because it minimizes the interdependency between objects. Now let's talk about the template method pattern.
The Template Method Pattern

Template method is one of the two behavioral patterns that don't use object composition. It defines the steps of an algorithm, allowing subclasses to provide the implementation for one or more steps. Methods have bodies that specify a sequence of statements or steps. In this sense, you can think of methods as templates that outline a series of instructions to execute; however, in some cases, you may not know how to implement some steps where you may want to define a generic template, leaving some steps as abstract methods so other classes can supply an implementation. Take for example this document class. We may have many types of documents that need to be processed following three general steps. First, we back up the document, then we do the actor processing, and finally we execute some validations. The backup and validation steps are the same for any type of document. The only method that varies for each type is process. Process is an abstract method that doesn't have an implementation. Because of this, document is an abstract class that will be the parent of classes like TextDocument or a SpreadsheetDocument. These classes will inherit the methods processDocument, backup, and validate, but they must provide an implementation for the process method to complete the algorithm defined by the method processDocument. So the intent of a template method is to implement an algorithm, leaving the definition of some operations or steps to a concrete subclass. Each concrete subclass must provide an implementation of the undefined steps of the template method's algorithm. So it's a good idea to minimize the number of abstract methods by not making the steps too granular, but it's obviously a tradeoff. The less granularity, the less flexibility. Also, some steps will be optional. You can implement these are hooks rather than abstract methods. The difference is that abstract methods are required, so the missing steps must be customized or implemented; otherwise, the class has to be marked as abstract. On the other hand, a hook represents an optional part of the algorithm, a part that can be escaped. With hooks, a subclass may choose to implement the hook, but it doesn't have to. The abstract class may provide a default implementation for this purpose, and that's the template method pattern. Now let's wrap up this module.
Things to Remember

In this module, you have learned about the most popular behavioral patterns. Behavioral patterns describe how objects or classes should communicate, as well as their responsibilities. Most of them use object composition to encapsulate behavior in an object and delegate functionality. The strategy pattern encapsulates the strategies or algorithms so you can have multiple implementations independently of the code that uses and selects the strategy. The state pattern models states as objects, encapsulating a state as specific methods in separate classes. So when the object changes its state, the functionality of the methods also changes. The command pattern encapsulates method invocations as objects, allowing clients to execute different operations without knowing anything about them. The observer pattern notifies one or more objects called observers when the state of another object, the subject changes, minimizing the interdependency between them. And the template method pattern defines an algorithm in a method, leaving some steps to be redefined by subclasses. Now let me give you a bonus tip, the template method pattern is an alternative to the strategy pattern. The intention of both is similar, but one uses inheritance and the other composition. In particular, the template method pattern uses inheritance to change part of an algorithm, and the strategy pattern uses composition to change the entire algorithm. And that wraps up the topic of behavioral patterns. In the next module, I'll give you a high-level overview of the most important creational pattern. Take care, and thanks for watching.
Getting to Know the Creational Design Patterns
Creational Patterns

Creational patterns describe how to abstract the process of creating an object, hiding how objects are created and put together when exposing only their interface. This gives a lot of flexibility in what gets created, when it's created, who created it, and how it gets created. The Gang of Four book describes five patterns in this category; however, only one, the factory method uses inheritance to create objects. On the other hand, the rest of the patterns use object composition to delegate the creation of instances to another object. In this module, I'll give you a high-level overview of four creational patterns, singleton, factory and abstract factory, and the builder pattern. The only one missing is prototype. Prototype is about making new instances by copying existing ones. In other words, it's about cloning objects, and in Java this is done by implementing the java. lang Cloneable interface, and the clone method that all objects have. Alright, let's start with the singleton pattern.
The Singleton Pattern

The singleton pattern is one of the most simple patterns, and at the same time the hardest to get it right. The intention of this pattern is to ensure a class only has one instance, providing a global point of access to it. Take for example this Calculator class. In Java, we create instances with the new operator, but creating only one instance of this class means that creating a calculator2 variable is not allowed. So we cannot let anyone create an object of the Calculator class with the new operator. But you might be wondering how do we do this? When you use the new operator, you're actually calling a constructor of the class. So in Java, the key to the singleton pattern is restricting the access of who can call the constructor of a class. Constructors can have access modifiers just like methods. And it looks a bit weird, but you can make the constructor private. No one will be able to call it except for the class that defines it. Now the only way to get an instance of this class is having a static method to create it and return it. Remember that static methods and variables belong to the class and can be called without a reference to an object. To implement this method, we need a private static variable to hold the instance of our class. And in the method, first we check if the variable is null. If so, we create the instance and then return it. The next time this method is called, the if block will be skipped and the already-created instance will be returned. This is how the singleton pattern looks in a class diagram. There is a class field that holds an instance of the same class, a private constructor and a static method that controls the creation of the instance and returns it. Simple, right? Well, actually no. It turns out that trying to control that there's only one instance of a class, it's a very hard problem. For example, what will happen with this implementation in a multithreaded environment? Let's say we have two threads accessing the get instance method at the same time. Now imagine the first thread checks if the variable is null, and before creating the instance, it gets suspended. Next, the other thread enters the method, and since the first thread didn't get the chance to create the instance, this thread creates the instance and returns it. When the other thread resumes its execution, it also creates an instance of the class, and now there are two instances of the class, one per thread. We can avoid this problem by creating the instance when the variable that holds it is declared. This way the get instance method will only have to return it. But the problem with this implementation is that the instance is created no matter what. What if the instance is expensive to create and no one uses it? The previous implementation only created the instance when the method was called. We can also solve the threading problem by synchronizing the getInstance method. But this will have an impact in performance, and in fact we only need to synchronize the access to the method once, when the instance is created. Some people implement a double-check mechanism to create the instance, but this just makes the code more complex. And multithreading is not the only problem, there are others. For example, we can create another instance of the class using the reflection API by passing all check-ins. Serialization, the process of storing the state of the class in the file system can also create multiple instances of the class. Custom or multiple class loaders can create more than one instance and many other situations. In recent versions of Java, the most acceptable way to implement the singleton pattern is by using an enumeration. This gives you a private constructor and is not affected by multithreading. However, enumerations cannot extend from another class, so you won't be able to use them for every situation. This is the singleton pattern in Java. Now let's review the factory patterns.
The Factory and Abstract Factory Patterns

The factory and abstract factory patterns are about delegating the creation of one or more objects to a special class called factory. There are three types of factories, simple factory, factory method, and abstract factory. Simple factory is too simple to be considered a pattern, but it will lead us to the factory method pattern. So let's start with this one. In Java, we create a reference of a certain class type and call a constructor of the class with the new operator to create an instance. But thanks to inheritance and polymorphism, if Vehicle is the parent of a Car class, we can have a reference of type Vehicle and an object of type Car or any other of the subclasses of Vehicle. The problem is that by using the new operator directly in the assignment, we cannot dynamically change the object, let's say to a Motorcycle. To do this, we need to avoid the new operator. The solution just like in the case of the singleton pattern is to move the code that creates the object to a method. We can pass as the argument of this method an identifier of the class we want to create, so the method can create more than one object. Of course for this to work, this object needs to have a common supertype, so any of its subclasses can be returned. This is an example of a simple factory. We can call this method, passing either the string car or motorcycle to get a different type of object. This parameter can be a variable that you can change dynamically in another part of your program. But we have one problem. If we have a large number of objects to create, for example, many types of cars or motorcycles, this method can become a nightmare to maintain. In this case, we can create a hierarchy of factory classes, defining a supertype, usually an abstract class, and then a factory just for cars and a factory just for motorcycles. This is the idea behind the factory method pattern. Sometimes these factory classes don't only have a method to create objects, they also have methods to configure objects. For example, if they're creating a particular type of vehicle, we could set a color and build the vehicle to return a fully-configured instance of this class. If we place this configureVehicle method in the parent class, so the subclasses only have to implement the create method, factory method becomes a specialization of the template method pattern. If you have seen the module Getting to Know the Behavioral Patterns, you'll know that this pattern defines the steps of an algorithm, letting subclasses redefine some of them. But back to the factory method pattern, notice that we have two parallel hierarchies, one for factory or creator classes, and another one for vehicles or product classes. For simplicity, all types of cars and motorcycles extends from vehicle in this example, but the point here is that in the factory method pattern we have on the one hand a hierarchy of creator classes, where the supertype defines an abstract method to create objects and optionally some additional methods, while the subclasses implement the factory method to create concrete types of objects. And on the other hand, we have the hierarchy of the object the factories create. Without the factory method pattern, this is how our simple factory method will look like, and I think I don't need to say how bad it will be. Now you can think of the abstract factory pattern as an extended version of the factory method. Instead of creating a single hierarchy of objects, abstract factory is used to create a family of related objects. In other words, the abstract factory has several abstract product classes, and if the factory method has one abstract create method that is implemented by each ConcreteFactory. The Abstract Factory has method for each abstract product. So in this case, each ConcreteFactory has to implement a method for one of the types of ProductA and a method for one of the types of ProductB. The client that uses the factory only knows about the supertypes of the products and the factories. Finally, here's an example of the abstract factory pattern. As the client, we have a car dealership class that creates cars and motorcycles using two factory classes for two categories, one factory creates cheap compact cars and scooters, while the other one creates more expensive cars and sport bikes. Alright, now let's talk about the builder pattern.
The Builder Pattern

Using constructors to create instances of classes with a large number of optional attributes is not a good idea. For example, this class represents a book and has two attributes, author and title. Now let's say we need to have an optional attribute, pages. We also need to add another version of the constructor, one that includes the new attribute. But what happens when we need to add more attributes? For every new optional attribute, we add an additional version of the constructor, and this can get out of control easily, to the point of having a big constructor in case someone wants to create an instance of the class with all of its attributes. Now you might be wondering, wouldn't it be easier to use setter methods? Yes, in some cases. The problem with constructing an object with setter methods is that the construction is split across multiple method calls, and there's no way to enforce setting all the required attributes. This may leave the object in an inconsistent state. The builder pattern offers a solution to the problem of constructing classes with many attributes, especially if they are optional. The objective of this pattern is to separate the construction of an object from each representation, so that the same construction process can create different representations. So there's an abstract class or interface that defines all the steps that must be taken in order to correctly create the product. Its subclasses or implementations contain the functionality to create that product, and a class called Director controls the building of the object in a construct method. This method takes as a parameter the ConcreteBuilder object used to generate the product. The Director then calls in the correct order methods of the Builder to generate the object. And then the getResult method of the builder object can be used to get the object. Applying this pattern to the book example, we can have an interface BookBuilder that defines methods to set all the attributes of the Book class. The method to get the book object at the end of the construction process is also on this interface. As implementations, we can have a traditional BookBuilder class and an independent BookBuilder class, and as the Director and Author class that contains a reference to a BookBuilder instance and the method to construct the book. Here's the code of the BookBuilder interface. There's a build method for each attribute of the Book class. Notice that some methods accept the parameter to configure the object. For the ones that don't, the subclasses will provide the values. For example, the class IndependentBookBuilder is supposed to build a self-published book, so a blank string is set as the publisher. On the other hand, for the class TraditionalBookBuilder, the string Traditional Imprint is set. Now in the Author class, the constructBook method calls all the build methods of the builder. And the getBook method calls the getBook methods from the builder to get the final object. This way to build a book, we create an instance of the Author class, set a BookBuilder implementation, and then we call the constructBook method and get the book instance. And just by changing the BookBuilder, we can get a book with different attributes. But a popular way to implement this pattern is by using method chaining, where the build methods in the concrete builder return an instance of the concrete builder itself, represented by the this keyword. So we can call one build method after another. And in a simplified version, the director is omitted, the builder is placed inside the product class as a static member, and the prefix build is replaced by another one like with, and build is used as the name of the method to get the object. Call this to create a more fluent and readable API. Okay, now let's review what you have learned in this module.
Things to Remember

In this module, you have learned about the most popular creational patterns. They describe how to abstract the process of creating an object, which means encapsulating the creation of an object to avoid using the new operator. In the case of the singleton pattern, it ensures only one instance of the class can be created, for this you have to make the constructor of the class private and have a static method as a global point of access. However, it's hard to ensure there's only one instance of the class when you take into account things like concurrency, reflection, serialization, and many others. Factory method encapsulates the creation of a family of objects in a method, along with subclasses to override that method to decide which class to instantiate. Actually, factory method is just a particular case of abstract factory. The abstract factory pattern deals with many hierarchies or families of objects, but if it is applied to a single hierarchy of objects, then we have the factory method pattern. And finally, the builder pattern separates the construction of an object from its representation, so that the same construction process can create different representations, replacing big constructors for a group of setter methods with a more readable group of builder methods. Alright, in the next module, I'll give you a high-level overview of the most important structural patterns. Take care, and thanks for watching.
Getting to Know the Structural Design Patterns
Structural Patterns

Structural patterns describe how classes and objects are composed to form larger structures. The Gang of Four book describes seven patterns in this category; however, only one, adapter, uses inheritance to achieve its purpose. On the other hand, the rest of the patterns use composition. For example, the bridge pattern uses object composition to breach two hierarchies, one for abstractions and another one for implementations when you need to combine two kinds of variations of these hierarchies. Or compose it, which uses two types of objects, primitive and composite, so the composite object can compose primitive and even other composite objects into complex structures. But here's something interesting, the adapter pattern can be also implemented with composition, so it can qualify as both, a class and an object structural pattern. We will talk about this because in this module, I'll give you a high-level overview of the faade, decorator, adapter, and proxy patterns. Let's start with the easiest one, the faade pattern.
The Facade Pattern

Faade is a pattern based on the idea that when designing a system, it's better to keep the number of interactions between classes to a minimum. Specifically, this pattern provides a simplified interface to use the classes of a subsystem, a group of related classes. It's important to mention that this pattern doesn't encapsulate subsystem classes, it just provides a simple interface to access their functionality. So instead of calling five methods from the five different classes, you only have to call one method of the faade, and this will call the other methods for you. The faade will add a bit of functionality, but nothing game changing. Of course the subsystem classes will be still available for direct use. This pattern also decouples a client of the subsystem from the subsystem itself so that changes in one part don't cascade to other parts. So we have a subsystem that groups classes with related functionality and a faade that knows which classes are responsible for a particular request, so it can delegate client requests to the appropriate subsystem classes. The classes don't have any knowledge of the faade, they don't keep a reference to it. For example, when some class registers an order in an order fulfillment system, instead of calling the registerOrder method of the Order class, sendNotification on the customer and warehouse objects, and they generateOrderReport on the sales object, we could grab all these methods in one method of an OrderFulfillmentFacade, so the client only calls this method instead of dealing with all the other classes. In this example, I'm manually constructing the faade object, but most likely this object will be build by a framework and just injected into the client. Alright, now let's talk about the decorator pattern.
The Decorator Pattern

Just like you can add ornaments or decorations to your house or Christmas tree to make them look nicer, you can add additional responsibilities or decorations to an object. The idea behind the decorator pattern is to add these decorations dynamically at runtime instead of adding them via inheritance at compile time. Take this Pizza class hierarchy for example. Pepperoni, Hawaiian, VeganPizza, all of them are pizzas, so this hierarchy makes sense, but what happens when you have toppings? Let's say we add two toppings, barbeque sauce and extra cheese, will it make sense to have a PepperoniBBQSausePizza class and a PepperoniExtraCheesePizza class to the hierarchy? And for the other pizzas? And what if we have more toppings or more types of pizzas? So no, it doesn't make sense. Instead, just like you can grab a Christmas tree in decorations like real ones and lights, you can implement toppings as decorators and decorate pizza objects by wrapping them in those decorators. Let me show you what I mean by using a Hawaiian pizza with the two toppings, and I get description method as an example. The description has to be composed by the description of the pizza and the additional toppings. So starting with a Hawaiian Pizza, we can add an Extra Cheese topping that will wrap the Hawaiian Pizza object. In other words, the Extra Cheese object will contain a Hawaiian Pizza object; however, notice that I am not using the label Extra Cheese topping, but Extra Cheese Pizza. I'm considering toppings as pizzas, you'll see why in a few moments. Now just like before, we can grab the Extra Cheese Pizza in a BBQ Sauce Pizza. This way as BBQ Sauce Pizza is the outer-most object, we call its getDescription method. This method will call the getDescription method of Extra Cheese Pizza, the grabbed object, which in turn will call the getDescription method of the Hawaiian Pizza object in a recursive way. Hawaiian Pizza's method will return Hawaiian Pizza, Extra Cheese Pizza's method will return Extra Cheese, and finally BBQ sauce will be returned. This is the key to the decorator pattern, Objects wrapping other objects in recursive method calls. The decorator pattern defines a component class from which subclasses extend. To decorate this component, the Decorator class should inherit from the Component part. This class has an attribute of the same type of the Component to wrap it and add functionality. However, this is actually done by subclasses in the form of new operations and new state. The relationship between the component and the decorator is usually through inheritance, and a question often asked is how is this possible? Isn't the purpose of this pattern to remove inheritance? Well, there's also a composition relationship between the Decorator and the Component. But the main thing you need to realize is that the decorator pattern doesn't use inheritance to get behavior, it uses inheritance to match the type of the component so it can pass as one of them. In the pizza example, as the parent component, we have a base Pizza object and the HawaiianPizza as its class. On the other hand, as the base decorator, we can have a PizzaWithTopping class with a reference to a pizza object. And representing the toppings, we'll have a PizzaWithExtraCheese class and a PizzaWithBBQSauce class. In the HawaiianPizzaClass, the getDescription method just returns the string HawaiianPizza. The base decorator PizzaWithTopping extends from the base Pizza class, contains a reference to a pizza object, and declares as abstract the method getDescription. The subclass PizzaWithExtraCheese adds or decorates the description of the pizza it contains with the string ExtraCheese. And the subclass PizzaWithBBQSauce adds the string BBQSauce. This way we can create a base pizza object, wrap it in a PizzaWithExtraCheese object, and in turn wrap this object in a PizzaWithBBQSauce. We can also do this in a single line if you prefer. The point is that when we call the getDescription method of the last returned pizza object, it will recursively call the getDescription methods of the decorated objects to get the complete description. And that's the decorator pattern. Now let's review the adapter pattern.
The Adapter Pattern

The adapter pattern does the same thing real-world adapters do. For example, between your all-entrusted headphones and your new phone, I'm sure there will be an adapter that will let you plug the cable of your headphones into the USB-C port of your phone. The adapter changes the interface of the headphones into one that your phone expects. That's the idea behind the adapter pattern. A common use case is when you're trying to integrate a legacy code base with a new one. They'll have different interfaces, so you'll need an adapter to convert one interface into another to make them work together without changing either one of them. So in the adapter pattern, there's a Target class that a Client uses and an Adaptee class that needs to be adapted to be used. In the class version of this pattern, the adapter uses multiple inheritance to get the functionality of both classes and adapt one to another. The problem is that in Java, you could not extend from two classes. There is no multiple inheritance of classes, so we'll have to use the object version of the pattern, but it doesn't change much. The only difference is that with an object adapter, we use composition to delegate request to the adaptee. Here's an example. Let's suppose we have an interface to play all the files. And now that Video support has been added, we want to play the audio part of a video without making changes to the client. To solve this, we can have a VideoAdapter class. This class implements the audio interface and has a reference to the video class set in the constructor. Now in the play method, we call another method to extract the audio part of the video file, so we can play it like any other audio file. This illustrates another point about adapters, sometimes you'll need to implement additional methods or classes to make the interfaces work, and you'll have to think what's better, rework all your client-side calls to fit the new interface or provide an Adapter class? Alright, now let's talk about the proxy pattern.
The Proxy Pattern

A proxy is a surrogate or representative for another object. It behaves exactly like the real object, so a client can use the proxy just as it will use the real object. For example, let's assume we have a MusicPlayer class that has a reference to a Song class with a play method, but instead of having a reference to the real song object, the MusicPlayer class can have a reference to a SongProxy class. In turn, this proxy class will have a reference to the Real Song class to forward all play requests. So what's the purpose of a proxy class, you may ask. Well, you can add new functionality before or after calling the method on the real object. For example, you can check if the user has permission to play the song, or you can log the number of times the song has been played, but the main intent of this pattern is to provide a surrogate or placeholder for another object to control access to it. And there's an interface called Subject that is used by a client and that the real subject and the proxy implement, and let me tell you, we can find proxy objects everywhere. Proxies are used for remote calls, handling the network details, so we can work as if the remote calls were log code, for security, to control access to a resource based on access rights, for caching objects to a speed of calls, or as a visual proxy, likely initializing resources that are expensive to create. Now you might have noticed that there's a level of overlap between the structural patterns we reviewed, maybe more than in other pattern's categories. Sometimes you'll have the option to use any of these patterns to solve a problem, but you need to be aware that there are some subtle differences. Both facades and proxies represent objects, but the purpose of the faade is present a simpler interface of an entire subsystem composed of many objects. It can add some functionality to a request, but nothing the way a proxy does. In addition, the client is unaware of the proxy, this is not the case for the faade. Both decorators and proxies can add functionality to an object, but the purpose is different. A decorator adds one or more responsibilities to an object, while a proxy controls access to it, sometimes adding functionality in the process. Both proxies and adapters stand in front of other objects and forward requests to them, but an adapter provides a different interface to the object it adapts. In contrast, a proxy provides the same interface as its object. Alright, now let's wrap up this module.
Things to Remember

In this module, you have learned about the most popular structural patterns. They describe how classes and objects are composed to form larger structures. A faade not only simplifies an interface to a subsystem of components, it also decouples a client from it. The decorator pattern adds additional responsibilities or decorations to an object dynamically instead of adding them via inheritance. The adapter pattern converts the interface of a class into another that clients expect without changing the client or the adapted interface. Finally, the proxy pattern provides a surrogate or representative for another object to control access to it. Sometimes there's an overlap between these patterns. Proxy and decorator have the same interface as the classes they grab, but their intentions are different. A decorator adds one or more responsibilities to an object, while a proxy controls access to it. Besides, most of the time the proxy creates the instance, while the decorator takes an instance in the constructor. Decorators and adapters wrap an existing object, but adapters change the object's interface. Decorator adds responsibilities to an object. Proxy provides the same interface of the object it grabs. Decorator provides the same interface, but in an enhanced way. An adapter provides a different interface to its subject. Some adapter implementations can adapt more than one interface, and in this sense facades and adapters may be similar when grabbing multiple classes, but the faade's intent is to simplify, while an adapter converts an interface to something different. Alright, we have reviewed the most important GoF patterns. In the next module, we'll review patterns from other fields, and we'll see how they are related to these GoF patterns. Take care, and thanks for watching.
Exploring Other Design Patterns in Java
Introduction

We have come a long way in the field of patterns since the publication of the Gang of Four book. However, the Gang of Four patterns are still the ones to learn because they offer a solid foundation to learn other patterns. This module has two objectives. I want to give you a taste of the patterns that exist in the areas of enterprise development, functional programming, and reactive programming, but perhaps more importantly I want to show you how the patterns of these fields can be considered as specializations of the Gang of Four patterns. For enterprise development, I'll talk about how the model-view-controller pattern can be considered a combination of patterns. In the case of functional programming, I'll answer two questions that are often asked, do GoF patterns apply to functional programming, and does functional programming have design patterns, and for reactive programming, I'll tell you how it is closely related to two GoF patterns. You don't have to know anything about functional programming or reactive programming, and I won't show you complex examples. The important thing is that you understand how the Gang of Four patterns relate to other patterns. So let's get started.
Enterprise Development Patterns

Enterprise software like payroll, customer service, or human resource systems often have to deal with a lot of data and complex business rules to satisfy the needs of an organization. Some of the challenges that we must face when developing enterprise software are related to data persistence, sometimes involving transactions across multiple databases, concurrency, allowing many users to access the same data at the same time without hurting performance or causing errors, and integrating different applications using many communication protocols. So there are a lot of patterns that describe solutions to these and other common problems. Martin Fowler keeps a catalog of patterns for enterprise software in many categories. There are patterns for application architecture, some as specific to the Java Enterprise platform, integration patterns, data model patterns, and here's something interesting, the Gang of Four patterns are included in this catalog. He says these are mostly fundamental patterns which are not specifically for enterprise software development, but enterprise patterns reference them widely. Sometimes more than one of these patterns work together to form more complex patterns. Take for example one of the most popular architectural patterns, MVC, or model-view-controller. Actually this pattern is older than the Gang of Four patterns, dating back to the late '70s. But remember, patterns are discovered, not invented. And the MVC pattern can be described in terms of the Gang of Four patterns. In the model-view-controller pattern, the model includes the objects that contain the business logic and the data of the application. The view is the part of the application that presents the model's data to the user. And the controller is the part that receives user input and decides what to do with it, tying together the model and the view. The main idea or principle behind MVC is the separation of concerns, making a clear separation between the objects that contain the business logic of the application and the presentation objects, in such a way that business objects work without referencing the presentation. When the user does something in the view like clicking a button, the view sends the user actions and input to the controller. As a result, the controller interprets the input and manipulates the model to change the state of the application. The controller may also tell the view to change, for example, by showing another screen or by enabling something. When something changes in the model, the model notifies the view that its state has changed, so the view can get the state and display it from the model. Sometimes the controller is the one that is notified of changes and then asks the view to update its display accordingly. In any case, all this interaction is based on three patterns, composite, strategy, and observer. The view implements the composite pattern. It is made by components like windows or forms that contain other components, which can contain other components and so on until reaching live nodes, like a button. The relationship between the view and the controller is an example of the strategy pattern. The view only knows about displaying something. It delegates to the controller the handling of the user actions without knowing how it's done. For other actions, the behavior can be changed by calling other controllers. And the model uses the observer pattern to keep the view or controller updated when the state changes. MVC can use other design patterns, for example, it can use the decorator pattern to add functionality to a view, but the main relationships are given by the composite, strategy, and observer pattern.
Functional Programming Patterns

In object-oriented programming we work with objects. Objects can hold references to other objects, and we can pass objects to methods as their arguments. In functional programming, we hold references to functions, and we pass functions as arguments of other functions as if they were objects. We call these functions high order functions. A function must be pure, which means that it shall do only one thing, it must have no side effects, which means that it doesn't have to change the state of the program, and it must be referentially transparent, which means that for the same input, the output of the function must be the same. But do the Gang of Four design patterns also apply to functional programming? Well, not really. I mean there are some design patterns in functional programming, but since this is a different programming paradigm, the Gang of Four patterns don't apply. Java is not really a functional programming language. It became a functional-like programming language with the introduction of a string and lambda expressions in Java 8, but in a functional programming language, object-oriented patterns are irrelevant because functional languages work at a higher level of abstraction, and in many cases, the language itself provides operators that do the same thing that patterns do. Even the Gang of Four book recognizes this. The choice of programming language is important because it influences one's point of view. Our patterns assume a Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. For example, when working with Scala, which is a functional language that also works on the Java Virtual Machine, there's no need to implement the singleton pattern. The language provides objects declared with the object keyword, there are classes that have exactly one instance and are created lazily. However, there are still design problems that are not solved by functional programming languages. For example, three popular functional design patterns are MapReduce, which it's about breaking tasks into multiple smaller ones, the map part and aggregate the result, the reduce part. Memoization, which caches the result for a given input and use it to speed up further calls to the same function given the same input. And monads that act as containers for wrapping other types, defining rules of interactions and providing functions to connect or compose other monads. You can also use these patterns in Java, for instance, the optional type is an example of a monad in Java. It acts as a container object, which may or may not contain null values, but most of the time functional constructs are used to implement object-oriented patterns. Do you remember the command pattern, the one about encapsulating requests or method invocations by creating an interface that exposes a generic operation that subclasses redefine? Well, don't you think this is a way to mimic high order functions? Using just the object-oriented features of Java, you have to wrap up the function in a class. However, using a lambda expression, we can just pass the function as the argument to the method, and rather than seeing the Gang of Four patterns as obsolete or in any other negative terms, I believe that is better to see the GoF patterns as one way to understand functional programming concepts. It's like design principles and design patterns, in the same way that principles are low level and patterns are high level, functional programming is at a higher level of abstraction, but object-oriented patterns teach you how to encapsulate and work with the small bits of functionality. I'm talking about design principles, let me tell you that they apply regardless of the programming style you're using. Concepts like that classes or functions shall only have a single responsibility are universal, no matter how they are implemented. So back to the idea of using GoF patterns to understand functional programming concepts, here are two examples. The strategy pattern can help you understand and think in terms of high-level functions. The strategy pattern is about generalizing. It requires you to use different, but interchangeable algorithms. In this example, you can generalize the way a method formats strings in such a way that you can change the functionality of the method just by passing a different strategy in the form of a lambda expression. Another important concept of functional programming is composing or linking functions. This is about creating small, reusable functions that you can combine to create new functions. It sounds a bit like the decorator pattern, don't you think? But in functional-style programming, you work with functions instead of subclassing and instantiating classes. Alright, now let's talk about reactive programming and its relationship with patterns.
Reactive Programming Patterns

Reactive programming is another style of programming with its own set of rules. It's event driven, and it focuses on the flow of data. The idea is that changes or updates are propagated in a stream to everyone listening for those changes. Reactive programming also involves three concepts, non-blocking programming, which means that the application doesn't wait until every quest finishes to handle a new request, asynchronous programming, which means that the application can execute an operation in parallel or in the background, so it can execute other things without waiting for the operation to finish. And declarative programming, which allow us to emphasize the flow of data by describing what we want to do instead of explicitly writing the boilerplate code that handles the operation to be performed. Here's an example of reactive programming. What we are doing here is creating a data flow that consists of a source that is called Observable. An Observable represents any object that you can get data from a data source, in this case an array of a string. And we subscribe or observe that a string of data to get one element at a time. However, there may be one or more intermediate steps called operators that apply a function to transform the data and return or emit another observable, so you can chain many operators together. If you're wondering about the name Observable, yes, you guessed it. The reactive programming model is based on the observer and the iterator patterns, but with a twist. In the observer pattern, a subject or producer publishes events and there are one or more observers or consumers of those events, but the problem is that if the consumer cannot keep up with all the events generated by the producer, there's no mechanism, so it can seek now the producer to send or stream the event at a different rate. In reactive programming, this mechanism exists and it's called backpressure. Also, the producer called observable in reactive programming doesn't start streaming events until at least one observer has subscribed to it. Like an iterator, the observable emits these values in order and can seek null where the sequence of events is completed. So this is another example of how your knowledge of the Gang of Four patterns can help you understand other styles of programming. About patterns specific to reactive programming, as reactive programming works in a non-blocking asynchronous way, patterns related to asynchronous programming apply here. However, as there are no mainstream reactive programming languages, the way you do reactive programming is through libraries or APIs that already implement many of these patterns. ReactiveX is one of the most popular APIs for reactive programming. The implementation for Java is a library called RxJava. On the other hand, you can also find a set of reactive design patterns related to the architecture of systems that comply with the principles of the reactive manifesto. However, reactive systems are not exactly the same as reactive programming. You can write a reactive application using reactive programming, but that is just an implementation detail. This doesn't make an application reactive under the perspective of the reactive manifesto. Alright, now let's wrap up this module with a quick review.
Things to Remember

In this module, we have reviewed patterns that exist in some areas of software development and how some of these patterns can be considered specializations of the Gang of Four patterns. About enterprise development, we reviewed one of the most popular architectural patterns, model view controller. The view implements the composite pattern because it is made by components that contain other components. The controller is an example of the strategy pattern. You can change the behavior of the view by changing the controller it references. And the model uses the observer pattern to keep the view and the controller updated when the state changes. We talked about how in functional programming object-oriented patterns are irrelevant because functional programming works at a higher level of abstraction, and in many cases, the language itself provides operators that do the same thing that patterns do. However, you can apply your knowledge of design principles and patterns to understand concepts like chaining and high order functions. Finally, remember that reactive programming is an event-driven style of programming that is based on the observer and iterator patterns where the observable, the object that produces events, doesn't start streaming until at least one observer has subscribed to it. The observable emits its values in order. It can seek null when the sequence of events is completed, and there's a mechanism to instruct the observable to send the events at the different rate. Alright, in the next module, I'll give you some final tips and wrap up the course. Take care, and thanks for watching.
Where to Go from Here
Introduction

Now that you have learned the fundamentals of design patterns, you might be thinking and now what? In this module, I'll wrap up the course by giving you some tips on how to use design patterns, and then I'll give you a quick summary of the course and some recommendations to learn more. So let's get started.
Tips for Using Patterns

Now that you have started learning and understanding patterns, there's something you have to take into account. Patterns can easily complicate things. It's true that patterns give you more flexibility, and they can mitigate the complexity of some designs, especially the ones that rely too much on inheritance, but if you are not careful, patterns can also complicate things by adding an unnecessary ledger of objects or implementing over-killing solutions. You can find a lot of examples of bad uses of patterns by searching for the terms pattern abuse. Here's one that uses the AbstractFactory pattern to create an object that prints the message HelloWorld. I cannot show you all the code, it will take a lot of slides. And let's not talk about this other example that uses four patterns to code a HelloWorld program, Singleton, AbstractFactory, Observer, and Command. Of course these are exaggerations, but then you must be wondering how do I know when to use a pattern? I can tell you something like always start from the simplest code that can do the job, and only use a pattern if you are sure it's necessary to solve a problem, or that you will have to deal with change in the future, but probably that will not mean much because every situation will be different. So I can only say that knowing when a pattern applies is a matter of knowledge and experience. Without a good knowledge of patterns, you won't know if a pattern is a good match for a problem, and without experience, you will know if the pattern is really needed or if a simple solution can do the job. About experience, in the beginning, most people are in love with patterns. They use them in their code all the time. And this is actually a good thing because this way people gain experience implementing patterns. They will make mistakes and learn from those mistakes. Then as they progress in their learning, they'll start to see where patterns are needed and where they aren't. In some cases, they adapt the pattern to fit a situation. Then one day they will understand that patterns should not influence the design, the design should be as simple as possible, and they have to let patterns emerge and fit naturally in the design. However, here are some actionable tips that can help you implement patterns. First when implementing a pattern, define names that are meaningful in the context of the application. Sometimes it will help to include the name of the pattern or one of its participants in the name of the classes, interfaces, or even methods. This will make the use of the pattern more explicit, but you will have to be consistent in your naming conventions. Also, don't think design time is the only time you use patterns. You can do it at developing time with the help of refactoring. Refactoring is the process of making changes to the code to improve its structure without changing its behavior. You can review your code to see if it might be better structure with patterns, or if the code has become complex and the flexibility the patterns gives you is not needed, you can even replace the pattern with a simpler solution. Now let me give you a quick review of the course and some resources to learn more.
Course Wrap-up

In this course, you have learned the most important concepts of design patterns. We reviewed the definition of a pattern, a reusable and named solution to our recurring problem in a context. Patterns represent good design techniques that have been successfully applied by other experts. They give you a vocabulary that you can use in meetings, documentation, and in the code for a more precise and complete communication. To really understand patterns, you must know of the four building blocks of object-oriented programming, abstraction, encapsulation, inheritance, and polymorphism, as well as object-oriented design principles like the solid principles and others like encapsulate what changes and programming to interfaces. You learned that inheritance is not always the best solution to a design problem. In many situations, you can replace inheritance with composition. Actually, most of the Gang of Four patterns use composition to achieve their purpose. We can classify the Gang of Four patterns by their intent in behavioral patterns, which are concerned with the assignment of responsibilities and the communication between objects. Two examples are the strategy and the observer patterns. Creational patterns, which abstract the way objects are created and represented. Two examples are singleton and factory method. And structural patterns, which are concerned with how classes and objects are composed to form larger structures. Two examples are adapter and decorator. There are many more patterns, some apply to particular fields such as enterprise systems, and others are related to different styles of programming, but the Gang of Four patterns are the foundation. However, be aware that it's easy to overuse patterns. Probably this is a good thing when you are a beginner because this way you can practice implementing patterns and make mistakes from which you can learn. Now to continue learning about patterns, there are some courses in the Pluralsight library that I can recommend. For example, there's a series of courses by Bryan Hansen where he goes into the details of each pattern, one course for Behavioral patterns, another for Creational patterns, and yet another one for Structural patterns. There's also a course by Paolo Perrotta about the Structural Patterns with great graphics and explanations that I totally recommend. Or if you want to go beyond design patterns, there's also a course by Allen Holub where you can learn the foundations of object-oriented design. With this, we reach the end of this course. Remember that you can contact me if you have questions or problems. Thanks for watching this course. I hope you had a great time learning about the big picture of design patterns. Take care, and bye for now.
