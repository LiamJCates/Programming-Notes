When creating software, we don't want to start with an idea for the finished project and then get to work on everything that this application needs to do and, several years later, finally publish the finished software. The reason we don't want to do this is that during development time, several things will happen; for example, the requirements for this application might change, new laws can make us need to do things differently, and competing software solutions might be released, to name a few.

Instead, we want to implement some core features, release them to our users, and then immediately begin the development of the next release, which will contain some more features.

We start with a vision or an idea. Then, we take some fundamental parts of this idea and implement them in what is called an iteration. At the end of the iteration, we have code that works that we can release to our users. We then begin the next iteration, implementing more features that are released as soon as this iteration is complete.


Releasing the code is called a deployment.

Deployment is the process of making sure the software is installed in the right location, that it is secured to prevent any hacker attacks, and making sure that privileges are given to the software so that it can read and write files as needed. When the code is deployed, we usually want to test it again to make sure that everything is still working the way it is intended. Deploying the code is usually done in several steps. Developers will typically have a server that's used during the development process. This is called the development server, and during development, the code can be executed and tested on this server. It will often come with a development database that, if the application we develop uses a database, is used to simulate the real data the application handles. Still, it can be modified any way the developer wants as it is detached from the real data the users see and work with.

Before the code is moved to the production server, that is, the server the application users will use to run the application, the code is usually moved to an intermediate server, often referred to as a staging server. The role of this server is to be as much like the production server as possible so that the new code can be tested alongside the code that was already released. The idea is to make sure that everything runs smoothly and that no bugs appear when the new code hits the live production server. The staging server also has a database. The data in this database is often copied from the production database to make sure that everything is a mirror of the real server. Finally, when the team is confident that everything works correctly, the code is moved to the production server. Apart from moving the code, other adjustments might be needed, such as adding things to the production database that the new software version will need, adding other applications and code libraries that are used by the new code, and so on.

We must also have a strategy for how we can undo this deployment if needed. No matter how thorough our test has been, when the code hits production and users start to use it, things that we never imagined begin surfacing. Users might behave in unpredicted ways, and there might be differences in the production environment compared to the staging environment that we overlooked. We always hope for the best, but we will need a plan for what we will do if things backfire. What we want is a way to undo all the changes and go back to what we had before the deployment as quickly as possible. This is called a rollback strategy. We can accomplish such a rollback in several ways. One of them would be to take a backup of the production database before the deployment occurs. This way, we can ensure that we have a snapshot of how all the data in the application was, before the release of the new code.

The actual code is usually deployed to the server with the help of a VCS, so rolling back the actual code to a previous version is rather simple. The steps involved in deploying code to the production environment are often automated, meaning that different tools and applications take care of all the steps.

Deployment Automation
It is often a good idea to automate as many of the deployment steps as possible. The reason is that there are usually many steps involved that need to be done in the correct order, a job ideally suited for automation. At the same time, it's something where humans often make mistakes by forgetting to do something or do something in the wrong order. Depending on the complexity of the system, we can use several tools that will help us accomplish automated deployment. Automating deployment will ensure that we have high-quality code since the automation process typically runs tests and lets the code through to the production server that passes the tests. It will also save time as the deployment steps will be performed much faster by the deployment tools than they would be if humans performed them. When the code is deployed, the work with it is not over. Deployed code must be maintained.


Code maintenance
A typical software developer will spend more time maintaining existing code than writing new exciting features. This is not very strange if we think about it.

First, the lifespan of an application is typically much longer than the time it took to develop it. This means that there are more and more software out there that are running and performing their tasks. Programs that are used will always need maintenance as users will find bugs that we must fix, new features will be added to the application as demands from users change, and old features must be updated and improved.

This means that developers spend most of their time in old code, fixing and updating it. This can be code written decades ago by someone who has left the company a long time ago, or it can be written by you just the other week.

If you think ahead to what your life as a programmer will look like, you will most likely imagine yourself writing new, exciting software that uses the latest tools and features that are out there. Still, the fact is that it is much more likely that you will be poking around in code written a long time ago, in a version of the language that was released when you were in preschool.

At times, you will have the chance to write that brand-new, cool, and shiny piece of software, but remember, if you do a good job, that code will live on and will need to be maintained by others (or yourself) in the future. That is the life of a software developer. This means that we need to ensure that the code we write is as maintainable as possible.

A skilled software developer is someone who writes highly maintainable code. This means that the code is clear, easy to understand, and easy to change, without the risk of people introducing some unwanted side effects in the application.

There is a simple rule we can follow to help us create maintainable code: the boy scout rule. The legend of the boy scout rule says: Leave the campground cleaner than you found it.

In the book Clean Code, the author, Robert C. Martin, also known as Uncle Bob, transformed this rule so that it could be applied to code. He states that if we apply this rule when we maintain our code, we should always leave our code a little cleaner and better each time we maintain it so that its quality will increase over time. We can rephrase the boy scout rule in relation to software development so that it says, Always leave the code you're editing a little better than you found it. The changes do not have to be huge. You will not have to rewrite large sections of code. If you change a variable name to something that better describes the value it is holding, or adding documentation to a piece of code where it was missing previously will increase the code's quality slightly.
