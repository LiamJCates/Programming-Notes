Course Overview

JDBC Is the most mature and heavily utilized of all the Java enterprise. APIs. If you do development in Enterprise, Mobile, Cloud or Micro Service is, you're probably going to be using JDBC.


Prerequisites
Before reading this document, you should already be familiar with the Java programming language and SQL, the standard query language for relational databases.

Technology used by the examples will be
Java 11
JDBC version 4.3.
MySQL Community Edition
MySQL Workbench



Overview and Setup

The JDBC APIs used to create, read, update and delete data in a relational database using the Java programming language. JDBC is database agnostic, which means it works the same way whether you're using MySQL, SQL server, Oracle or some other relational database. Learning JDBC is one of the most important skills for an enterprise developer, and it's a skill that has truly learned once and use everywhere. That's because, regardless of which relational database you used, you employ the same JDBC API to perform updates, inserts, deletes and queries.

Knowing how to use JDBC is an essential skill for Enterprise Java developers who want to be at the top of their game. JDBC is used for data access, with every kind of Java application being enterprise mobile, big data, Internet of things, cloud computing or Web development.

Over the past 22 years, JDBC has become the very foundation on which all other java enterprise APIs were built. In fact, JDBC is the first enterprise API ever developed for the Java platform.

Relational databases are used by the vast majority of enterprises deploying applications in the Java programming language without JDBC all the Java enterprise software would be useless. Even if you have never used JDBC directly before, which is likely in the case that you're taking this course. You have probably used it in directly every JPA Implementation, including hibernate, uses JDBC under the covers to enable fast and reliable access to relational data.




The examples we're going to develop in this document are for an example company Global Mantex. Global Mantex sells die cast cars, motorcycles and trucks to scale model enthusiasts and collectors. They have relied on monolithic solutions for last 30 years but are now preparing to re-engineer their business system using modern micro services platforms build on Java and Jakarta EE. They need you to develop components that can query and update products customers orders and other data in the relational database. These components must be self contained and decoupled abstracting crowd operations so that they could be reused by other developers who are developing micro services and Java EE applications.



Installing MySQL and Example Database

In this video, you'll be installing MySQL Community Edition, MySQL Workbench, and the example database.

Find MySQL Community edition by googling MySQL Community Server Download.
Select the download for your particular system. You'll also find a link to installation instructions for your operating system.

Please take note that when you do set up MySQL database, it's gonna prompt you for user name and password. Use the user name of Root and the password of pluralsite, and then all the examples would work without a problem. If you use a different password, you'll have to change each example because the password is hard quoted into the URL for the JDBC Connection.

You can find the MySQL workbench by googling MySQL Workbench. You also find installation instructions for that

the demo code can be found under the exercise tab in the plural site cores just download it and insipid somewhere where it's easy for you to access.

import the example database we're using.

Throughout this course, you will find the example database in the Root directory of the Example code. Find a file named Sample Database Script that SQL and open it up in a text editor. Copy all the contents of the file into an open MySQL Workbench and paste it into the editor. Now hit the execute button. Using MySQL Workbench, you should be able to see the full scheme of the database. Feel free to do some queries, but hold off on the updates or deletes so that the databases in the correct state for the tutorial the day of a schema or model for this database is fairly typical for basic retail company. There are products, product lines, purchase orders, customers and employees, along with several linked tables. This is the perfect example for our demo company, Global Mantex. For this course we're using the mice equal Connect J JDBC driver. Regardless of which development environment used, the maven palm will automatically include the SQL driver, so you don't have to worry about it.


Install Java

for the demos, I'm using openJDK 11 and if you don't have it already installed, you can do so now.

Fire up an IDE and import the example code
File structure src > main > java > com > pluralsite > corejdbc

You can see all of the examples for each video with the final package designator of m then module number and c then video clip number.

You don't have to memorize the schema because with each example, I'll provide a full package and class name that you should be looking at. As an example, opened the m2c1 file and click on the main class. As you can see, I've annotated the video with the name of the class and its package. All the examples for ontology have at least two classes, a component class and a main class. The component class is where your JDBC and Business logic resides. It's here that you'll connect to the MySQL databases and learn about JDBC APIs. The main classes, the one you want to run to see the examples in action it instantiates the component and calls the appropriate method with the parameters needed. You should feel free to change those parameters to experiment on your own. But the ones higher quoted into the main classes are the ones I'll be talking about in this course. To run an example, click on the main class and right click and then select Run main dot name as shown here. Occasionally there will be more than one main class, but you'll be provided with instructions on which one to run for each example.


Assuming everything was done, you'll see output that should tell you that the applications successfully connected to the MySQL database server. This confirms that the example, code and intelligent can run the sample database. I'm using Eclipse Ide ee in the videos, but the process of selecting example and running it is the same. There's been some problems within Tell J lately, so if you get an air like this fun or this one, it means that intelligent is not using the correct J T. K. Remember in the last video you set up J. D. K. 11. We need to make sure that that's reflected in the intelligence settings. Click on the intelligent menu item and select preferences Navigate to build execution deployment, then compiler and then Java compiler. In this window, make sure the project by co version is set to 11. If there's no module shown, click on the plus sign and select a module. If there's nothing to select than just leave it. If there is a module, make sure that the Target byte code version is set to 11 then hit Applying close. Next, right, click on the project in the Project Navigator and go to the menu item named Open Mode Settings. Make sure the language level set toe 11 and click Apply next. Go to the sdk and make sure that set to 11 as well. If not, you may need to add 11 and set it to that. Now apply your changes. Now go back to the Project Navigator. Click on the main class and then right click and select Run Maine, and you should see the following output. If you still don't see the correct output to make sure that your operating system is using J T K 11 and not J. T. K 1.8 or some other version. If you need to go back to the previous video and follow the instructions, do that now.
Using Eclipse with JDBC

eclipses one of leading I. D. E s. And I expect more than a few of you will be using it to accommodate those who want to use Eclipse. I preferred this video explaining how to set it up for the course. If you don't already have eclipse installed, you need to download and install it. You can find it by Googling Eclipse I d download. You wanna download the eclipse I d for Java developers or the Eclipse i d for Enterprise Java developers. I'm using my clips i d with the Mac OS X, but the process is the same regardless of which operating system you use. Once eclipses installed, you be ready to fire it up and run the example code. When you first open eclipse, you'll need to choose a working directory. The default is fine, and then you'll see a welcome screen. Click on the orange button on the upper right toe. Open the editor, click on Eclipse Top Level menu and select Preferences. Navigate to the Java compiler pain If you install J T K 11 from Oracle or open J. D K Select SdK 11 Click a Pie and Clothes with the J T k selected. Click on the import projects. Example. Code is set up with a maven file. You don't need to know anything about maven for this course if using a class, but you do need to import the project using maven type maven in the search box and select existing Maven project. Set the Root directory to plural site Core libraries J. B. C. Example. Code directory that you downloaded earlier. Click on Finish. You should now see the example Project in Eclipse. Most of the videos in this course have example code that you can run and play around with each videos. Example. Cold will be in a separate package. If you click on source main, job it. You'll see many packages starting with calm. Plural Site corps J T V. C. With that name space, you can see all the examples for each video with the final package designator of em for module, the Montreuil number and see for clip the clip number. You don't have to memorize the scheme because with each example, I'll provide a full package and class name you should be looking at. As an example, opened the M two C one folder and click on the main class. As you can see, I've annotated the video with the name of the class in its package. All the examples for Eclipse have at least two classes, a component class in the main class, the component classes where you're Jamie B. C. And business logic resides. It's in here that you'll connect to the bicycle database and learn about the JDBC APIs. The main class is the one you want to run to see the examples in Action It in Stan. She hates the component and calls the appropriate method with its parameters. You should feel free to change those parameters to experiment on your own. But the ones hard quoted in the main classes are the ones I'll be talking about in this course. To run an example, click on the main class and then right click and select Run, as Java application has shown here. Occasionally there will be more than one main class, but you'll be provided with instructions on which one to run for each example. Assuming that everything is done, you should see output tell you that the application successfully connected to the Mice Equal Database server. This confirms that the example code in the eclipse can access the sample database
Using Command Line with JDBC

money developers prefer to use the command line in maven when working with Java applications. This video details how to set up and run the examples for the scenario. If you do not have maven installed on your system, just Google. Install maven and follow the directions for your operating system with maven installed. Open a command line counsel and navigate to the Examples Directory Plural, Say Job Back or libraries JDBC, which you downloaded earlier in the command line. Run the M V en install. You should only need to run this once unless you make changes to the example code. Right now, all the examples work as intended. But if you want to play around with the parameters are quote in the example. You want to run the M V unclean install after making those changes and before running the example To understand how the example quotas organized. Open up a file Explorer and navigate to the example Quote directory. Most of the videos in this course have example cold. You can run and play around with each videos. Example code will be in a separate package if you navigate down to the source. Main job calm Plural site. Cor J B C folder. You'll see many folders that start with an M here. You can see all the examples for the videos and the final package designator M for module and C for clip. You don't have to memorize the schema because with each example, I'll provide a full package and class name that you should be looking at as an example. Open the M two C one folder and click on the main class. All the examples for Eclipse have at least two classes, a main class and a component class. Open the main class with the favor editor. I'm using text. May. The main class is the one that you want to run to see examples in Action It in Stan. She hates the component and calls the appropriate method and parameters needed. You should feel free to change these parameters to experiment on your own, but the ones I have higher quoted in the main classes of the ones I'll be talking about in the course. If you do make changes, make sure that you run the M V Unclean Install command before running them, or it won't see the changes in action. The component classes where your Jade, ABC and business logic resides. It's in these components that you'll connect to the mice equal database and learn about the J. B C APIs. There are two ways to run examples. You could use the command line and specify the entire package and class name has done here, but this could get pretty cumbersome after a while, so I've prepared a demo class that is much easier to use. Just run the demo. It's in the default package and specify which example you want to run. For example, to run em to see one, it would look like this. Assuming everything is done, you should see output tell you that the application successfully connected to the mice Equal Database server. This confirms that the example cold can access the sample database. I am using the Eclipse I d rather than the command line to run examples. But whenever I show source code, I'll annotate the video to show you exactly which example I'm looking at and the full package dame. So is that you can follow along when I run. Examples also annotate the video to show which class I'm running and the full command line needed to run the example. How also pop up a command line window so you can see the example run in the command line.
Connecting JDBC to the Relational Database
Using the Driver Manager and Services

Hi, My name's Richard Johnson. Hateful. Welcome to connecting JD. We see to the relational database module for the Java Core libraries J B. C. Course on plural site. In this module, you're gonna learn how to connect a J T. V C driver to the database. There are a few different ways to connect, depending on the circumstances. This module covers using the driver, manager and service is Class four name and the driver manager Data source with J A N D I Java in Jakarta E and C D. I. J B. C. Exemplifies the facade pattern in which the real workings of the specific implementation are hidden behind the standard JDBC a p. I keep in mind as you learn about JD, we see that run time. The JDBC API is always backed by a vendor specific code generally called the driver. There are several J B C classes and interfaces that are used by most JDC applications. These include the Driver Manager, which maintains a registry of drivers which are the vendors implementation of J. B. C. The connection object, which represents the actual connection to relational database the statement and prepared statement types, which encapsulate the SQL command you Want to execute and the results set, which represents the data return by your SQL command. In this demo, we're going to develop a very simple, reasonable component the product component with a single method. Try connection. As the name suggests, this method is dying to test for database connection. You will see the example finished, but I'll walk through it line by line, building up the code as we go. Just follow along when you create a J B C connection. You do so by giving J. D B C. A set of properties, which consists of a your eye identifying the specific driver needed, as well as a user name and password and other vendor specific properties. This operation is performed by the driver manager. When calling the get connection Method says we're using the my sickle database. We'll use the driver provided by MySQL, which is called Connector J. We can tell Jay to BC to use connector J driver by passing in a yurt. I specific to that driver like this. The driver documentation will tell you what this you are. I should be, but in most cases it follows the pattern of the JDBC schema, which is J. D. C. Colon, followed by the driver's name. Then the host and database name and then log in credentials. Have we want to use an Oracle database that you are? I might look like this. Or if we want to use Microsoft SQL server like thus so you can change the vendor in the database you are connected to by simply changing the u. R I of the connection call. Assuming that is that the vendors driver is registered, let's switch back to the connector J driver. Since that's the one we have available, the test of the connections valid. We simply call it is valid on the connection. Object yourself if it's connected to the database, it returns True. Otherwise, returns falls. It's important that you always close a database connection. If you don't close the database connection, your application may hold onto the database. Resource is that's not using, and that can be expensive in terms of memory, network, socket connections and threads. There are no shortage war stories about entire applications crashing in production because the developer failed to close a resource. Each relational database vendor provides their own version of the J BBC driver, but all of them must conform with the interface is an abstract classes defined by J. T. V. C at Runtime that J R E will load the vendor specific driver so that the JDBC AP I calls you make will be carried out by the underlying driver. The J. R E will look at all the registered JDBC drivers to determine which one matches the u. R I used to get the connection and one Stan, she ate that driver and pass it any other property specified in the U. R I. The question you might be asking is, how do I register the vendors driver at Runtime? The _____ will look into the jar files meta I Enough Service's directory and look for a file named java DOT SQL. That Driver, which lists that vendor specific JDBC drivers that will be available at runtime using your file, browser or command line, navigate to the plural site Java Core libraries, JDBC directory, where the demo code is located, and under that in the Target directory and find the corps JDBC JAR file. This will be president if you have chosen to file the editorial using the maven command line. If you're using intelligent or clips, you may not see this jar. Here are the instructions for forcing these ID's to generate the core JDBC Jar file in the Target Directory. Intelligent, it doesn't generate the distribution jar. Corps J to be siege are automatically to get it to generate one. Click on the View Tool Windows maven in the Maven Tools window opened the lifecycle node and double click on the install item for the Eclipse i. D. E In the Project Explorer. Find the palm dot XML file at the bottom right. Click on it and select Run as maven. Install opened the finder window again and navigate down to the Target Directory. Select the corps J B C jar file and unzip or on Archive it and look into the meta I Enough Service's directory. There you will see the Java that SQL that driver file. Open that file up in your favorite text editor and you'll see the MySQL Connector J Driver listed had we used multiple databases from different vendors. Each of them would need to be listed in this JDBC. Drivers file. When you do your maven build and generate an executed A LJR, any JDBC drivers listed as dependencies will be automatically added to the build jars. Meta Enough Service's Javad at SQL Driver file. We can test our Davis connection to MySQL. Using connection is valid method, which is implemented as follows. Let's run the example code from M three C one and see what happens. And there you go. The connection was successfully made.
Using Class.forName() with Legacy Applications

prior to deejay BBC four, which was introduced with Java SC six, there was an extra step that was required when creating a JDBC connection. The vendors driver had to be explicitly loaded prior to being use. This was done using the class for name method as shown in the demo under M three c two and tell JDBC four point. Oh, you had to do this If you want to load a specific JDBC driver when the Class four name method was executed, it would trigger the class loader toe. Look for that driver and load it in the process. A static cold black in the driver class was executed that registered the driver with the driver manager. It was clunky. And when Java Service's were introduced in Java SC six, the Class four name was dropped in favor of listing the drivers in the Java SQL Driver file under the meta I Enough Service's directory that you learned about in the previous video. So if Class four name is the only use with JDBC drivers predating 4.0, why even mention it? Because it's likely you'll encounter this out in the wild as it was the primary method of loading J. D B C drivers for two decades. In addition, you may be faced with the need to use a version of J D. B. C that predates the use of the service is in four point all, in which case you'll have to use this class for name method in your own code. Run the main file in the M three c to directory to see if this works and their ego success.
Using the JDBC DataSource

in this video will be looking at three ways of obtaining a JDBC. Connection using the JDC data source object. These include J A N D I, the Java and Jakarta E at resource annotation and CD. I add injection and notation. If you're doing development and Java E, then you will probably be using the JDBC data source object instead of the driver manager to get your connections. The dare source type was introduced in J B C 2.0 and first employed in the Java to enterprise addition, the precursor, Javi E. Six. The purpose of the data source object was to further abstract and encapsulate the process of obtaining a database connection instead of setting the J BBC driver, you are I and properties directly in the application code. They were declared and J two ee xml configuration files at runtime. The J two ee ee container would read the JDBC XML configuration file and load the drivers it declared, configuring them with the U. R I and properties defined in the configuration file. The developer would then access the data source from a context object provided by the J two ee component using J and D I. A directory service is API. If you're working with a really old J two ee ee code base, you'll probably see cold like the following the data source object and the use of J and B I Look up saw the number of problems that were apparent with the use of the driver manager class. Namely, allowed the database connection to be created without having to say anything about the vendor or the database in the application code that made the cold more portable and a little easier to look at. If you're doing Enterprise Java development using Java to Enterprise Edition or any version of Java E, you're going to encounter the use of the J and D. I. Look up or dependency injection of the JDC data source. When Javi EA six was released and included dependency injection, what spell the end of the use of the J and D I to obtain jdb see connections and replaced it with the at resource annotation using dependency injection made it very simple to access the JDBC data source object. It was simply there when it was needed. You can run this example in the i. D. E by simply running the main J E class in the same package. And when it's done, you should see this success message dependency injection of the data sources awfully used in non Javi E applications that employed the CD I. The Context and Dependency Injection Framework CD ISA Standard dependency injection framework that can be used in conjunction with or separate from Java e six and up. In some cases, such as one developing micro service is you won't be using Java, e e or Jakarta E. There at Resource is annotation and Javy E Type will not be available. In these cases, you'll use the Java Essie at inject an imitation as well as your own annotations to indicate what is to be injected. You'll also create a producer which creates the data source behind the scenes, which is then injected by the CD. I container into your component as an example. Take a look at the CD I being, which is an irritated with the type of JDBC driver and this standard Java SC inject an imitation in this case, the CD I container looks for a data source producer annotated with MySQL data sores and automatically creates a new data source and injects it into the data source field. You can run a demo of the CD I container code shown above by executing the main CD I class in the M three C three directory. For those using command line and maven, make sure you provide both the package designator and the CD I Parameter has shown here the demo is using the data source are simply that Demos, The J and E I example can't be wrong because there is no J and D I context. In addition, we could have used a real job e e server or CD I container, but that would be outside the scope of the course. Instead, I mocked the injection process for each example when using a CD I container. The use of the data source with your own custom annotations and a producer is not required, but it is considered good practice, especially when using JDBC Connection pooling, as explained later in the course. For the rest of the tutorial, we will not be using the data source and will instead continues the driver manager explicitly to get Ajay BBC connection. This is a convenience for this course, but when using Java E, be sure to use the standard at resource annotation, as described here instead of the driver manager.
Using JDBC to Query Databases
Using the Statement and ResultSet Types

Hi, My name is Richard Mountain hateful and welcome to using JDBC D queria database. Now that you know a couple different ways of connecting in your J BBC driver to the database, it's time to learn how to query a relational database. In this demo will create a SQL statement to encapsulate a SQL. Query will then execute the query, sending it to the database. Finally, we'll use the results that to navigate and read the database response. The connection object allows us to create what is called a statement object, which is simply a mechanism by which we can send secret requests to the database. The connection object creates the statement object, which in turn executes Aquarius shown below. This shouldn't hold any surprises for anyone who's worked with SQL before, but as a refresher. The statement select Asterisks from Products is a SQL, Quarry, which asked the database to return. All the records rose from the table named products. If we take a look at our rear D diagram again, we can see that the products table contains a lot of fields and columns. Each role represents a model car that Global Matics sells The columns of each roll include data such as the name, price, quantity, an inventory and so on. If we want to see the actual data that we need what is called a result set so that we can peruse the data record by record each of these three J B C types manufactured here, the connection the statement and a result set must be closed when you're finished. Using them, as shown below has stayed in the last module. Weaken greatly improve the efficiency of your application because it ensures that memory and threads allocated to manage those objects are released, freeing up more memory and threads for other tasks. Resource is that could be clothes should be closed in the reverse order that they were created. So in this case, we close the results at first, then the statement and then the connection, the opposite order in which they were created, the results that tight behaves in many ways like a Java collections it aerator. It allows you to review the contents of each record returned by the query one record at a time. The key to making this work is the primary navigation method. The results that that next method the first time you call results that that next it places the cursor or pointer at the very first role of the results that's returned by the SQL Query. The next method returns true if there is a record at the cursor and false if there is not. So if you have a query that returns eight records, the next method will return true the 1st 8 times and false the ninth and every time after that. Unlike J. P. A or most Object relational mapping APIs, J B C. Does not auto generate objects for each row. Instead, it treats all tables and rolls the same and is ignorant of the structure and total role Kant and data types in each row. It's up to you, the developer, to tell the results that what feels and data types you want to extract from each row. This is done with the wild by using get methods of various types and specifying which column you want to read from the current role. For example, I want a list the names of all the products sold by Global Mannix. So for each, royal asked for the value of the column. I want in this case product name. If you run the code now, the application goal three entire results says pretty, not one row at a time. And the next video? We'll take a close look at exception handling and how you can ring Maur information out of JDBC. Exceptions to help you hunt down problems.
Handling Exceptions in JDBC

Until this point, we've ignored the possibility of accessions. But as you no exceptions do happen when connecting to a remote resource like a database, the chances of experiencing exception are pretty good. Here's a list of all the exceptions that could be thrown when using the JDBC API. Many of them are extensions of the SQL Exception type. Some of them are simply qualifying type, showing the type of problem, for instance, the serial exception, while others both qualify and provide additional information not found in the base SQL exception, such as the batch Update exception. For the most part, we're not going to be using these types. Instead, we will use their super type, the SQL exception, which provides information unique to the JDBC programming. We could modify our products component to extract general exception data as well. A SQL exception. Specific data as follows. The Catch Black is where we are handling exceptions and extracting Maur information. In addition to the exception message, we are interested in two other data points, the air code and what is called the SQL state, as well as a complete job. A stack trace the get message method works because a SQL exception extends the Sander exception tight. We also have the get air code by calling the Get Eric owed method. The air code is vendor specific code in the form of it. End Eric holds used by MySQL not be meaningful when using Oracle or Microsoft SQL server database systems. The reverse is also true. With the air cold, you can look up the problem at the vendor site to provide more information to help you pinpoint the problem. The SQL stay is useful cross database vendors. The I S O A. N s I and the Open group standardized these values in suite of SQL standards. If you want to know the values of these, you'll probably find them in your database documentation. You can also add a stack trays, which is not unique to SQL exception but is inherited from the exception type. This could be helpful when your code is causing the problem rather than the SQL statement of the database. All we do is add the stack trace output. Of course, we still need to close Resource is the connection, the statement and the results. That and for that we need a finally clause. But because the calls to close each resource can itself generates equal exceptions, we need to handle that possibility as well. As you can see all the exception. Handling adds a lot of code to our otherwise simple component, but you need some exception handling code so that you can understand what the problem is and close up. Resource is, that could be costly if not closed. We can force R J T V C code to produce a meaningful error, Coz and SQL states by sabotaging the SQL statement used to create a SQL statement. Object. Let's change the table name to be incorrect. I'm going to add an axe the products table name and see what happens if we run the example below. We get the following. I'll put the area code and SQL state our display, but what do they mean? Well, in addition to the description in the output, you can look up the meetings on the Internet. Remember that the air codes are vendor specific, while the SQL state is an industry standard. The best place to do this for MySQL C E, is Brian Dunning's air code reference Just Google Dunning. MySQL, Eriko It's like this and there it is. It not only shows the Eriko, but in this case the corresponding SQL State Code from the antsy I s O extension document. Nice, right? Obviously, having this kind of information is going to be helpful when debugging you're J. D B C application, but the addition of the catch and finally, ______ really do add a lot of noise to the code. Let's see if we can clean it up and reduce that noise. A modification to the try catch box was added in Java seven and JDBC 4.1 try with Resource is, which takes care of automatically closing any resource that implements the auto close herbal interface and J. D. C. 4.1. The results that statement and connection and some other types not yet mentioned that need to be closed were changed to implement the auto close herbal interface. Now we don't have to worry about closing. Our resource is we still need to catch black. However, in order to catch and interrogate the exceptions that are thrown here, you see me delegating that job to another method to help keep the coat a little easier to read. That's better. But if the exception handling logic is the same across all components, that it makes sense to extract that method into either a helper class or a super tight, I've gone with the help of class. Rather than have the catch inside the component, I'm going to further clean up the code by moving the responsibility to the components caller, the main class in each example, when the components method is involved. If an exception occurs, it's passed to the main class, which uses the helper class to generate output we can read and use. The end result is component code that is far safer in terms of closing. Resource is and easier to read in terms of exception handling. From this point forward, we will be using the try with resource is to automatically close J T V C types that require it, but we will delegate the exception handling to the main class exception. Handling is important, and as you do the domino make mistakes, you'll have a chance to see exceptions printed out without having to see exception handling code and the demos themselves. This makes the demos easier to read and understand
Using the PreparedStatement and ResultSet

While a select statement works great, it's not the best mechanism for executing queries. Better type is the prepared statement using a prepared statement are simple. Query with look lifts follows when you use a statement Object queria database. The entire query ist sent over the network to the database. The database then compiles the query plan, which takes place in three steps. First, the database parses the query into a format native to the database. Second, it optimizes the query plan so it runs as efficiently as possible. Third, it executes the query To get the results, your database will need to compile a query plan every time you execute a query. If you are using a statement object that could be a few times a day or tens of thousands of times a minute. It takes the database time to compile a query plant. The drain on memory and processing power adds up quickly and will impact the performance of your database and your application. When the prepared statement is used for the first time, it goes through the same process except that the fully parse and optimize query is stored for future use, and then it executes the quarry plan. However, when the prepared statement is used again, the identify Iris sent instead of the entire query. And since the database has kept the parson optimized statement and memory, it can move directly to execution every time the prepared statement is used. This increases the throughput and improves performance. There's usually no reason to use a statement object instead of a prepared statement. So we use on Lee prepared statements from this point forward, let's run the prepared statement to see that it executes to return the same results as the statement object, and there it is the same results.
Using Input Parameters with a PreparedStatement

the prepared statement can also have parameters allowing statements be prepared but still dynamic. For example, if we stipulate in the query that it only fetch records with a by price between 50 and $100 it would look like this. The problem with this is that the parameters are hard coded. We don't want that because the desire to rage will probably change. So instead of hard quoting the values, we replace each value with a question mark. We can set the values of the question marks using the set methods on the prepared statement. Of course, this is still hard coded, so let's use variables and pass in the low and high values in the method call. And now we can plug in the variables, and we have a very flexible database query. Now let's take a look at the main application. You can see that I've already put in values for the low and high parameters. If you run the main application, you can see the results. A subset of the entire table. You can play around with us by simply changing the parameters used in the main application. The try with resource is is used differently here than it was in the last video notice that the results set has its own try with Resource is nested within the first try with Resource is this was necessary because the prepared statement set methods cannot be inside. The parameters of the tri with resource is blocked. Onley auto Close herbal declarations are allowed in those parameters. The set methods are not auto close a ble, but the prepared statements execute query method which sets the value of the auto close herbal results that is called after those centers. Nesting try with resource blocks like this is perfectly fine. Remember two things. First, the resource in the tri with resource is Klaus should not be referenced outside the claws so that everything you need to do with the results set should be done in the nested. Try with resource is clause, which is the case here. Second, the nested try blocks will close, their resource is ahead of their parents and that must be the reverse order in which they are created. So in this case, we're closing a result set in the nested claws and statement in connection objects in the parent. Try block
Accessing Multiple Columns with ResultSet

we can get data from other columns and the results up by simply using more get calls. For example, the products table declares quantity and stock field as a SQL, type of small end that maps nicely to a job. A end. Another example is the by Price field, which mass well to Java double type. We cannot put these values and make them more presentable using some text formatting. When you run the main application you're all put will look like this. As you can see, we have three columns of data, the product name, the quantity available and the price per unit. You may have noticed that the select statement I'm using doesn't specify which columns to select. It uses the asterisk as a wild card, meaning select them all. You can narrow down your results by specifying the exact columns you want to see. For example, since I'm only displaying the product name, quantity and stock, and by price, there isn't any reason to select anything else. This reduces the amount of data that you're transferring between the server and the client, which can improve performance, the results that provides a lot of functionality. Chief among them are the gift methods, the results that declares a couple dozen get methods for accessing data and columns too many to show all at once. But if you Google Java SQL results set, you immediately find the Java doc that displays all the methods and the types that they return. As shown here, you'll notice that for every get method, there are two versions. One takes a column name and one takes an index. If I were to use the indexes instead of the colonies, my cold you look as follows and the results would be the same. I personally prefer to use the column names as that makes it clear which columns I'm trying to access J. D B C. To find a loose mapping between generic SQL return types and Java types. In fact, there is no definitive one toe one mapping between the results that get methods and SQL ties, because support for the SQL data types very among vendors. For example, Microsoft SQL Server has a type called Money, which Sideways also supports but is not supported by MySQL in other databases. Another example is the bar chart database type, which most, if not all, databases support, but with very different character limitations. In MySQL of our chart can be more than 65,000 characters long and SQL Server has a limited 8000 characters, while Arco's Vire tire can't be longer than 4000 characters. If your application uses complex data types and is expected to support multiple database systems, do your homework to figure out what database types map to which results that get methods. For most developers, however, the back end database is unlikely to change in their enterprise, as such a move is a major undertaking. So as long as you know how your database maps, it's SQL types to results that get methods. You're fine JDBC. To find its own set of types called JDBC types and provides a set of table showing conversions from JDBC types, the Java types. You can find an exhaustive list of the conversions in Appendix B of the JDBC 4.3 specifications, but here's a small sample. Another thing to keep in mind is that JDBC defines its own types, some of which are similar to the standard Java types, for example, the get arraignment that returns a Java SQL. Ray, Not a job you till array list or job you to list information about this can also be found in Appendix B of the JDBC 4.3 specifications.
Additional ResultSet Navigation Methods

you've been navigating results sets like a numerator shins from start to finish. But that's not your only option. In addition to next, the results that can support several other navigation methods. In this video, I'll show you five other methods, including first and before first, to go to the beginning of the results that last and after last for the end of the results. That absolute, which takes you to a specific index in the results. That and relative, which moves you either for or backward and number of rows from your current position and previous, which allows you to move backwards through a result set. The knave component is a reporting tool allows you to print out records from the product table. It takes as input to its constructor an existing results set one that has already been created, which it uses to move for backwards into specific locations. In the results set, let's run the example and then take a closer look at each navigation method. The print Ford method uses next for navigating from the first record to the last. You've used this many times, but it serves here to illustrate how the utility works. It simply takes the results that it's been given and loops through all the results. Calling next all the other methods in the product. Knave utility used the same results set to navigate to different points in different directions. The print first method uses the first navigation method to move to the first record and then prints out the row. As you can see, the first role in the all products list is indeed 1969 Harley Davidson Ultimate Chopper. The Print Last method uses the last navigation method to move to the last record and prints that out. As you can see, the last record matches the last record in the all products list. In this case, we're using the absolute position to navigate to a specific role in the results set. And here the method takes the results set from its current position, which was that index to imprints the third record after that current location. The previous method moves, the results set reverse. I want to print the entire set from in the beginning, so I first used the after last navigation method to put the point, or just after the last record. Then when I execute the previous method, it moves it to the last record and starts printing up from the list from there. Finally, before first method not shown here, moves the cursor to just before the first record, so that when you call, the next method advances to the first record. This is useful when you've already read the results forward and want to read them again. In this module, you learn how to read data from Relational Database using J. D B C. Although you can read data using the statement type, the prepared statement is preferred because it's more performance and can help protect against SQL injection attacks. Using the try with resource is is a great way to declare and close up. Resource is like JDBC connections, prepared statements and results says, so that you don't have to write complex, try catch. Finally, logic. You should now understand that the results that is the key to perusing an accessing data and JDBC. You move from the first record to the last using a real upset or jump around using methods like before first before last, absolute relative and previous. It's important to note, however, that not all JDBC drivers support all these navigation methods. Ideally, they should, but you may find that some do not. You learned about mapping is between relational database types and Java types. How jaded. BC defines a mapping but competing relational database vendors do not have a standard, so you're likely to encounter differences. If you have to support more than one database, you can refer to the JDBC 4.3 specifications. Appendix B for more details.
Using JDBC to Update Databases
Using the Prepared Statement to Modify Data

Hi, My name is Richard Mountain Hateful. Welcome to using JDBC. To update database module for the Java core libraries, J B. C course in plural site in this module, we're going to modify data in the database using JDBC. In the prepared statements will learn howto update database records, insert new records and delete old records. A simple example of an update could be shown with order details. Imagine the customer calls and wants to change the number of units in order. Instead of buying 200 die cast models of the Titanic, the customer wants by 180. As you can see, customers have many orders. An order can have many order details. The data stored in the order detail record corresponds to a line item in a specific order. Updates are easy with prepared statement, a SQL update statement and a couple parameters. Let's take a look at our example code. The first thing to notice is that the order component has one method. The Update order Quantity method, which takes three parameters. An order number and product code as the compound key and a new quantity value thes parameters will map directly to the SQL update statement constructed here. The SQL update statement is set so that the order detail record with matching keys to the prepared statements to parameters will have its quantity ordered. The third parameter set to a new value when the prepared statement has created the values of the method. Parameters are used for the prepared statements parameters. To see the changes that this method will make to the database, open MySQL, Workbench and connect to the Classic Models database. Let's take a look at the contents of the order detail table with SQL Select Statement. Here's the order details table. As you can see, there are order numbers and product numbers, which are unique keys for this table. Let's focus on a single line for one order. Kelly's Gift Shop order 44 units of the 1938 Cadillac V 16 Presidential limousine. They want to double that unit count to 88. The customer service rep looks at the original order to get the order number of product code. First, we'll take a look at the data. I prepared a four table joint so we can see the order number you confined the query taxed in the main project rectory. Just open it, copied attacks and paste it into MySQL Workbench and execute the query as you can see results for the current UNA Count is 33 now. Runner Update Method. If you run it without any arguments, it will modify the order detail record we just mentioned. Well, it looks like the component executed the update, as expected. Let's check my Seiko workbench to be sure. Now rerun the previous query on MySQL and you'll see that the value has changed to 88. It worked.
Getting the Update Count from the PreparedStatement

parents statements execute update method will conveniently return The number of records modify the example in the previous video would have returned one because only one record was updated. But this next Emma lost two. He several records. When we look at the E. R D diagram, we can see that the employees table has a fields. The one we're interested in is reports to an employee number. Let's start with the SQL Workbench again Select all the roles in Employees Table. We're interested in finding out who reports to Anthony Bo. Anthony Bo's employee number is 11 43. So if we run a new clarity si who reports to that number, we get the following results. Okay, there are six people who report to Anthony Bo. Mr. Bull resigned his position, so the company needs to assign all of his reports to another manager until it can be replaced. This happens rather frequently at global Mantex, so you're asked to create a function in the HR component that handles the transfer. Employees from one manager to another, in this case will transfer all of Mr Bose reports to Cato Nishi, employee number 16 21 who will manage them until Mr Bowl could be replaced. The cold will look like this. The replace sales manager Method runs a SQL update in a prepared statement that takes two arguments. The first argument is the new manager, and the second argument is the current manager. When the cold execute, he returns it in value as the count, which is the number of rows impacted by the update statement. In this case, the number employees moved. If you run the demo, it will automatically move the employees from Anthony Bow to Cato Nishi. The results say that six employees have been reassigned. Now run the query again on MySQL Workbench to see that Anthony Boat no longer has six reports. Now let's see about Kato Nishi. Okay, Tony. She now has all the reports that used to belong to Anthony Bowl.
Inserting New Data with PreparedStatement

in this video, we're going to add a new employee, Roger Williams, who will become the next sales manager for North America, replacing Anthony Bo. The employees table has been modified souls that it auto increments. The employee i d. This way we can learn how to get that value back when doing an update. The use of the prepared statement to do a database insert should hold no surprises. It's similar to the previous examples were re updated the employee database. We start out by creating the prepared statement with a SQL insert. We set the values we want to question her. And then we set these values using a prepared statements, set methods You may have noticed one difference. However. We added a parameter when we used the connection to manufacture the prepared statement, the last argument statement returned. Generated keys tell us a prepared statement that we want the auto generated primary key for the employees returned. Once the sq update is called, we can get the results that from the prepared statement, which contains the generated key by calling get generated keys method the results that return we'll have one row and one calm, which is the auto generated value. The main class for this demo has input values hard coded into it so that a record with the information for Roger Williams could be inserted. To see this in action, execute the main class. You can see the new record by viewing it using the MySQL Workbench just entered this query, and there it ISS a new record. You have successfully inserted a new record using JDBC.
Deleting Records with PreparedStatement

in this video, you're gonna delete a record from the database. Deleting data and production database is not as common as doing inserts and updates. There are two reasons for this. First, all data recorded by an enterprise is important should not be removed unless it's really necessary. A general best practice instead of deleting record is to mark the record as removed or invalid, using a special calm so that the record could be ignored. Inquiries. Second, the primary key of a record is often used as a foreign key. Another records. So, for example, every order has the identity of the sales person who handled the order. If you delete the sales person's record, the foreign key in the order will be useless. In fact, databases will often be designed to prevent deletion of records where the primary he is used in other tables, which is a good thing. That said, you'll need to know how to delete records using JDBC. At some point, so covering it is a must for this demo will delete, the new manager added in the previous video, which is safe because that person never made any orders or was a sign as a manager of any employees, so the primary key for Roger Williams was never used anywhere else in the database. The Method elite employee is called with the employee number. Employee number is used as the prepared statements parameter. Looking at the main program, you can see where the component is created and delete employees method is called. If you were to run this, as is with the null values input, the statement would not delete any records just to see what happens. Let's do that now. As you can see, the message says that no was not deleted. To fix this issue, we just need to get the proper employee number. In this case, we're going to delete the record for Roger Williams if we search for all the employees, we confined him in the employee table easily. There he is, and his employee number is 17 03 Now replace the null value in the main program with Roger Williams employee number and run it again. And there you go. The record is deleted. In this module, you learn how to use the prepared statement to update, insert and delete records in the database. You also learn how to get the update count and the auto increments value for a field of a new record. This mind, you'll seem simplistic and it is. But that's because you've done so much work in a prepared statement in previous modules, you're making excellent progress. Keep it up.
Using Blobs, Clobs and CallableStatements
Using JDBC TO Store AND Read CLOB and BLOB Data

Hi, My name is Richard Matson. Hey, vel. Welcome to the using clubs, Blobs and callable statements module for the Job Corps Libraries J B. C Course in plural site. We'll start out learning how to write large pieces of data, both text and via Neri, the relational database and how to read that data once stored. Then we'll talk about call Bill statements and stored procedure calls. Store procedure calls were more common a while back, but you'll still encounter them today and may even want to use them most. But not all relational database support the storage of very large chunks of tax called clubs and large chunks of buying her data Hope blobs. An example of a club might be a legal document or a resume, while images often used as an example of a blob. It's likely that you will encounter one or the other of these data types in your work, but you probably won't work of them very frequently. Let's start with the method for storing a large chunk of text a club in the database. The cold for writing club data to the database starts out as expected, by connecting to the database and creating a prepared statement. The parameters, the prepared statement are the value of the HTML description and the specific product line that is to be changed. The product line column is just like any other string approved of type. We set the value of second prouder to be a string value passed in from the calling application. However, the next parameter to be set is the text to be written to the HTML Description Field. As you can see from the parameters, the method received an input stream reader as its second argument. To store the contents of the stream, we use the method set character stream. With that done, we simply execute the update in return. True, indicating that execution was successful. It's really not that complicated. Once you've figured out the character and quoting used by your target database and the character, including of the text you on a store. This store club method is called by the main club store application are quoted in the main method is the name of the product line we want to alter and the name of the file from which we're getting our text. If you switch to a file browser and open the file with that name. You see that it is Gutenberg text file from a 1913 book about airplanes, not HD mill, but a great piece of test data. That's over 700,000 characters, long in a file that is about 3/4 of a megabyte too large for normal tax but fine for a club type. When we run this example, it will read the tax from the file into an input stream reader and pass that reader to the method, along with a desire product line. The component will then write the file to the database. If successful, the method returns true, and then we print the appropriate message. Let's run the example and see what happens according to the output. The method execute successfully and wrote the data to the database. Plus, check it in MySQL Workbench. To be sure, if you go to the role for planes product line and look at the HTML description, you can see the Texas there. If you were to copy this tax and then put it into a text editor, you can see that the column did indeed contain the text contents of the file. Next, we'll read a club data from the database and printed out. Everything is pretty much the same as you have seen with other operations. We connect to the database, create a prepared statement that takes a parameter. We set that parameter from the method argument and then execute the query. When it comes to reading data, we use a get character stream, which reads club data into the Java Io reader type. This is then passed to the calling application. The main method here passes the product line for which we want the club data and then takes the reader to return by the method and writes it out to the screen. Let's run it and see what we get. You can see some of the contents of the file on the clips council window, but this window is limited to how many lines of text it will show. So you don't see the entire document even though it was sent to output. And there it is. You have successfully stored and red Club data from the database using JDBC The main blob store APP reads the data from an image file and sends it to the store blob method in the form of a file input stream. The image can be found in examples directory. If you open it, you can see it's an old photo of violating plane. The store blob method is very similar to the store club method, with one important difference. Instead of character stream, we used set binary stream. Let's run the main method and see what happens. It appears that the method ran successfully. If you go to my secret work bunch and rerun the query, you'll see that the image field is storing a blob, North said. The other coms have a null value because they don't have any data on their image calm. We'll verify that the blob was stored properly by running the next method in the product component. The Reed Blob Method. The read blood method is very similar to the Reed Club method. The query selects an image com from the specified product line and then executes the prepared statement and then reach the image data as a binary stream instead of a character stream that it returns to the calling applications. The calling application gets back the input stream, which it rise to a new file named Planes Image. Let's run it. And there it is. If you open this new image file and compare it to the original, you'll find that they're identical. And there you have it. You have successfully stored and read a large trunk, one megabyte of buying charity, using a process similar what you do with club data.
Using the JDBC CallableStatements

most, if not all relational databases. That support SQL also supports store procedures. A star procedure is a collection of SQL queries that can, depending on a better, include imperative statements with a store procedure. The business logic is run and maintained on the database server rather than in the client application. There are advantages related to security performance for store procedures, but they're also negatives. It's a debate that's probably raged for 20 or 30 years, and personally, I can see both sides. But the pros basically are that the database experts right the queries, rather than the programmers better at preventing injection attacks. Because all the code is on the database and it's much more secure in terms of authorization. The kinds are that it's more work for the database. The databases already stressed answering queries and doing updates, but to add business logic to it might be too much. It depends on a deviate to implement. In other words, programmers can't just put out a store procedure and expect it to be deployed. The D B A has to approve, and that can sometimes be a real walled garden. And that's not as portable a SQL and This is because there are a couple standard for store procedures, but they're really not used consistently. You could find out more by simply ghoul in why you store procedures. Whether or not you feel store procedures are good or bad, it's likely that you will encounter them in your database work, and so you need to know how to invoke them. Since stored procedures run all the business logic and SQL statements in the database, you only need to provide input parameters and process the output when working with stored procedures. Before we look at the J T B C code used to execute a store procedure, we need to create a store procedure. Every database defines its own special syntax or language for store procedures. If you're interested in learning more about story procedure language for a specific database, just Google how to write start procedures for whatever database. Let's get started by finding the store procedure in the example files. Open your file browser and go to the example File's directory. Select the file and open it in a text editor. This store procedure is written in a syntax specific to MySQL. If we had used some other brand of database, the syntax would be different. We are declaring a store procedure with the name list products for with one input parameter. The input parameter is a variable character type that is up to 100 characters. Line it, Nance the parameter prod line. Next look at the query. Here is a simple query that returns all the records were the product line matches the input parameter. Now it's time to add the store procedure to the database, copy the contents of the file and paste it into MySQL, Workbench and execute. You can see from the message at the bottom that the start procedure has been created. To make the scheme of show the store procedure, click on the refresh button. Now open the store procedure group, and you will see the list products for stored procedure you just created. Let's run it to make sure it works. Click on the lightning bolt symbol next to the store procedure name. You are presented with a dialog box in the blank fields. Enter motorcycle like this and hit the execute button. As you can see the query executed as expected, listing all the products that belong to the motorcycle product line. With that done, it's time to look at the JDBC code. At first, the code in the list products by method starts out as usual, using the driver manager to create a connection. But then it diverges from other examples. Instead of creating a statement of prepared statement, the example created a call a ble statement. The prepare call method uses a special syntax to call the store procedure specific to MySQL. It uses the name of the store procedure. This string value will be sent to the database in Parse to determine which start procedure should be executed. Once the prepare call is done, we can set the value of the input parameter, which is simply the name of the product line. Next, we call the execute method to invoke the store procedure on the data vase. Remember that the star procedure runs a simple query to return all the products in a specific product line. If we execute the cran successfully, we request the results. Set Finally, reiterate through the results that printing on all the products in the product line. If you've worked with other programming languages the concept of method printers being in out or an out will be familiar to you. If you've only worked with job, then it will be new. The stored procedure we just looked at uses what are called in parameters by N. We mean that the parameters passed into the store procedure. It's also possible to use out parameters and start procedures when our parameter is used. It's like a second return value. It's not important what the value without parameter is before the stored procedure is called. What matters is the value that comes out after the stored procedure is executed. Thean al parameters of both an in parameter that is, the values passed into the store procedure and an out parameter, meaning the star procedure can change its value. And when finished executing the primary will have a value set from inside the star procedure to demonstrate in out parameters and by default on out parameter, I've prepared a second store procedure, which you'll find in the Examples directory. Open that file now, and we'll discuss how the inn out parameters declared, using MySQL Storm procedure language. Remember that other databases will use their own syntax for store procedures. The purpose of the store procedure is, as the name suggests, to update an email address for employees. Thean Parameter is the employee number, and the out parameter is the email address. We're using a nowt parameter for email address because we not only want to change the email address, but by convention, we want the old email address back. This is Dunn is a kind of reassurance that the old email was changed within the body of the store procedure. Re execute two SQL statements. The first gets the current value of the email address and puts it into a temporary variable. The second updates the email address with the new value past end. Finally, we set thean out parameter value to the old email address so that it could be passed back to the caller, which in this case is our Java code. Copy the store procedure and paste it into the mice Equal work bench and then execute it. You can see the start procedure was added to the database before we run the example. Let's see what the email address is for our employees. Currently, it's D. Murphy at classic models dot com, Miss Murphy, the CEO of the company, has requested that her email I just on record be changed. Just Diane at classic model cars dot com. Now let's write the J B C code to update the emails. The code shown here is similar to the last example where the connection is used to create a culpable statement, passing in the name of the store procedure and placeholders for the parameters. Remember that the store procedure of the first parameter is an in parameter of employee number, and the second is an in out parameter. For the new and old email address, the first parameter is set in the same way the in primer was set in the last example. We just call the set method with the parameter position. The second in all parameter has to be treated differently. We have to tell the JDC driver what type of data base value were expecting to come out of the call so you would use the register out parameter for any out are in our parameter. In this case, we're telling JDBC that we expect of our chart type as the return tight the possible values that can be returned will lie with the J V C data types. We learned about module for in this case, a strength. When you use the SAT methods like set in, you are telling the J BBC driver in advance that the parameters of type int this type is set before the store procedure is executed. The register al parameter is necessary so that J. D B C driver can communicate to the database, type the value it wants back in advance before the store procedure is executed, the next to command set string for new email and execute our typical for call statements and hold no surprises. The final line before closing Resource is is necessary to get back. The return value registered for earlier noticed that I had to use the same parameter in next to as I did in the original query to see this in action, let's run the example and see what happens Now Take a look at the results. The email was changed from Dumb free to Diane. Just as expected, you can verify this by checking with MySQL Workbench. Here is the result of a simple query, and the email corresponds to the email we use in this module. You learn how to read and write large bodies of tax clubs and large bodies of binary data blobs to the database using prepared statements and streams. The process isn't complicated. With the exception of getting your character, including match between your incoming data and the data type of the column, you want to store it in. You also learned that you can execute store procedures using the JDC callable statement and that callable statements support in parameters, out parameters and in out parameters. There has always been a debate about the use of stored procedures. Advocates say that they reduced network traffic and maintain a higher level. Security detractors say that they put in additional strain on the database and that the business logic really should stay in the application. I think the truth lies somewhere in between, and an application might use a combination of both
Using Connection Pooling, Transactions, and RowSets
JDBC Connection Pools

Hi, My name is Richard Monsoon Havel. Welcome to the using connection Pooling transactions and rosettes module for the Java core libraries. JDBC course I'm plural site. We'll start the module with JDBC. Connection. Pulling. It includes an example of how to utilize a connection pool if you don't have Java or Jakarta Hee Hee hee to manage connections for you. Next we'll talk about and work with transactions, which allow you to group several separate JDBC operations together so that those operations either succeed or fail together, which is good for data integrity. We'll end the course by talking about JDBC rosettes and how they're serialized and save to file past between components or sent or the network. Throughout this course, you've been creating JD Receipt connections directly using the driver manager you learn in Module three about alternatives to using the driver manager, including Class four name J A. N D. I and JDBC. Data source injection. In this video, I'm gonna introduce you to 1/5 alternative JDC connection. Pooling the process of creating a new JDBC connection can be expensive in terms of the time it takes to make the connection, and the resource is used. Every thread in an application must create a new connection requiring memory in the sockets. This costs quickly adds up, even if you're only operating on a single thread. There is also a cost to closing the connections with JDBC Connection, pooling your re using existing connections rather than creating new ones every time you need to interact with the database. A JDBC Connection pool keeps alive a certain number of J. D B C connections in a cash in memory so that you need not create a new JDBC connection every time you need one. When you request a new connection, the pool tape one from its cash rather than create a new one as soon as you call connection close on a pool JDBC connection is returned to the cash. Rather than disconnecting, this cashing mechanism allows lots of concurrent functions to use JDC connections without the cost associated with opening and closing new connections. With JDC pooling, new connections are only created of all the connections and the cash are unused and another connection is needed. JDBC is frequently used from within a container system such as Java, E E or Jakarta E and access via J and E i. O R Data source injection. In those cases, the application server almost always provides a JDC connection pooling. But if you're running the application independent of a Java or Jakarta eee application server, you'll need to set up connection pooling. You don't need to write a connection. Pull yourself. In fact, doing so is rarely done. You can use one of the few that are already available. The most popular. These are Hickory or Hickory CP Apache DBCP and see three peel. In this video, I'll show you how to set up the Hickory CP Connection pool and how to use it in a standalone driver application. Each connection pooling system will have its own configuration in API, but we can hide differences between them using a facade more about that in a bit. Taking a quick look at the Palm File, I get the Hickory CP Library from Maven using this dependency. Let's start at the beginning in the static main method of the main class when the application has started, It creates an instance of the connection pool Ah, custom class that I created for the Hickory CP Connection pool. You notice it doesn't maintain a reference to the instance. I'll explain why, in a minute after printing some headers, theat click ation creates five new threads, each labeled with main underscore, followed by a single digit. The identifier correlates to the order that the threat was created. The threads are started as soon as they're created by the other Luke. The application will be running five main instances each in its own thread. The main instance does its work in the run method, which is called when the threat has started, Run method loops three times, creating new instances of the order component and calling the tri connection method. Every time the tri connection is invoked, it will need a database connection so there will be five main instances, each in their own thread, requesting database connections and executing queries three times. That's a total of 15 connection requests in just a few seconds. When the tri connection method is called, the order component requests a new connection from the connection pool and then executes a prepared statement that does a simple select of all the records in the order details table. You'll notice that the connection pool has a static block when the first instance is created in the main method of the main class. The class is loaded and a static black will execute. It creates and configures the Hickory CP Connection and then assigns it to a static variable. The Connection Pool Singleton class encapsulates the Hickory CP Connection pool and delegating to it the job of getting connections. Okay, let's run this application. The output might be a bit confusing at first, but really, it's not that complicated. Let's take a closer look. Remember, every time you run this, the output will be slightly different. So what you see on your I D. E or in the command line will not match what I have here. There are two columns, the name of the main instance requesting a J B. C connection and the unique I D. For each connection, each role represents the main innocents requesting a data be connection and executing queries. If you examine the output carefully, you'll see that the hickory CP is pulling five instances, which it uses for 15 Davies Connection requests. Now take a look at just the Rose were the connection identified by the letter C F is listed. It's used by three different main instances. Maine to one and three at different times. You can also look at it from the perspective of the main instance using different connections. Main three requests a connection three times the first time it uses connection to a and the second and third time it uses CF. If you ran a longer test with Maur instances, you would see even more variety in the combination of Maine Instances and Connections. Use. The bottom line is that the connection pulling is really beneficial if you're working with a multi threaded application that doesn't have connection pooling already most, if not all, job in Jakarta. EEEE application servers come with connection pooling built in so you don't have to set up applications running those servers. Next, we'll talk about Janey. BC transactions
JDBC Transactions

Although working with transactions could be pretty simple, it can also be really complicated. Fortunately, most developers will only need to worry about simple applications. Global Mantex needs a component that concreteness ooh! Orders with line items. Line items are stored in the order details table. If you look at the E. R D diagram again, you can see that order Details Table Where line items are kept is a separate table from the orders table, where the information about customers, shipping preference and some other details are cut. There is a one too many relationship between orders and order detail records, where every order must have at least one order detail record to ensure that every order has an order. Details record. We need to first insert a record and T orders table and then insert a record into the order details table. You can't have an order without at least one line item. A company business rule. We can't do both inserts in the same SQL statement and SQL only select statements conspire and multiple tables, inserts updates and deletes can only modify one table at a time. Let's develop a component that could create an order and an order line item while maintaining data integrity. The first you blind should hold no surprises as you have done an insert before. When the insert returns. The generated key for the order record is requested because we'll need that to create the order details record in the next black we do the order details insert. Ideally, we want both inserts to succeed so that we have a consistent data base. On the surface, this looks right, but there's a problem if the insert into the orders table succeeds. But the inserts into the order details fail. We end up with an order with no order details. That's against company policy. So we need to use the transaction management to make sure that if the insert into the order details table fails, the insert into the order stable will also fail. Either they both succeed or they both fail together. To do that, we need to put the two inserts into the same transaction, which, it turns out, is pretty easy to do. When you commit an update, you make the update permanent in the database. Normally, JDC commits the changes as soon as the update is finished automatically, but We don't want that first insert to be permanent unless the insert to the order details also works. So we tell the JDC driver not to automatically commit the insert by setting auto. Commit to false because we set the auto commit to falls. The connection will not commit the insert automatically. We have to call the connection commit method, which we will only do if both the order and the order details inserts complete successfully. If something goes wrong, then we have to call the Connection Rollback method, which tells J B C toe undo any changes made in the last set of operations. Generally, you want to call the rollback method if the operation throws an exception or some other air occurs. Like if the order insert doesn't return an order number or if the count from updates to order details doesn't equal one. You may have noticed that when we look at the order a C class for auto commit that we have an invalid table name product code. Underscore acts. I've done this to show what happens when using auto commit if the insert to the order succeeds, but the insert to your details fails, run this application now and look at the results, the invalid table name through an exception. So the insert into the order details table failed. But if you look up all the orders for customer one or three, you could see that the new order record was indeed inserted. If you use the auto generated order number to look up the order details, you will see that there are no matching records. We have an order with no order detail records, which breaks the business rule. Now let's turn to our example with the manual commit the order component. Underscore M. C. Let's create the same problem we have with the last example adding underscore acts to the product code column name. I'll run it and see what happens. Okay, we have our exception. If the transaction worked as expected, we should not be able to find a new order for this customer. Let's see what's in the database, and there you go. A new order was not created when the insert to the order details table failed. Let's see if the insert works without a failure. First we fix the column name in the order details table, and then we run the application. The new order was created, which you can tell because the order number was printed. Let's see if we can find the matching order. Detail record. There it is. Both insert succeeded together.
JDBC RowSets

the Rosa interface is an extension of the results said that adds to important features. First is compliant with the job of beings idiom, and second, it supports both connected and disconnected data. The fact that is compliant with the job means idiom means that it is Tula ble by which I mean it could be incorporated into any tool that depends on the standard Java beans getters and Sutter's, such as an idea, the or an application for a mark like CD I until the row set was introduced, the results. That and his driver were soon to be tethered or connected to the database for as long as the results. That was in use only when the clothes method was called, with the results that be disconnected. Could serving resource is like memory threads and network sockets. After closing the results that you would need to execute a statement again to get a new results set. Arrgh set, however, can cash the data and then disconnect from the database. The data would remain in memory, and the row set could navigate through the rows and columns of the results as if it were still connected. This allows you to free up resource is used to keep the results set in the database connected. Just as importantly, it releases any relax on the database tables. So is that other clients can access data without having a new problems. There are few types of rosettes, including the Jade Embassy Row set, which is simply a rapper. For a result set the J D BC rose that remains connected it to the database and cannot be cashed or used outside the context of the connection and statement types that created it. The cash Rossetti is, as the name suggests, a result set that has been cashed in memory. It is a disconnected ro set, so after it's executed, it keeps the results in memory but releases its connection to the database. Saving resource is Akash roast that can be serialized using Java serialization and saved a disk or sent across a network connection. This makes for a powerful and portable data object that could be useful and try and reduce client resource usage or share data among applications. The remaining types are all extensions of the cash rosette, meaning that they are disconnected when in use the Web. Rossetti extends the cash ro set and differs a one important way. In addition to being serialized using Java serialization, format it congenital rate an XML document with the Web rosette data or read properly constructed XML to create a Web ro set. The filter rosette is another cash ro set, but this roast that allows you to search the results using filters you can federal data you don't want without having to execute a new query to the database. Finally, the join Rose set is, as the name suggests, a rosette that conjoined data from two other results sets or rose sets. By joint, I mean link the data and one rose set to another. By using a shared key in this video, we're going to take a closer look at the cash ROCSAT, as that is, the one that's used most frequently and is the foundation of most of the other row set types. Akash Rosette has several advantages and some disadvantages. The first advantage is that it's less taxing on the database. If the query used to produce it is called frequently, instead of re issuing the query to the database over and over again, the application can use Thean memory cache rosette. Another advantage of cash roadside is that could be serialized. That means the roast that can be written, the disk and then d serialize and used again, so it need not remain in memory all the time. Another advantage of serialization is that the cash rose set can be shared across the network with other Java applications, as the payload of some type of Web service is protocol. Like http. Finally, if the cash RO set represents a query that never changes like the list of products, for example, it could be much faster than using a result set or jdb. See Rosa, which need to communicate with a remote database. The disadvantages need to be considered as well. The results of a query can be very large, and in those cases, a result set can fetch the data is needed. Akash Ro set will need to fetch all the data at once, so Akash Ro set may not be the best choice if the results are very large, as it would require a lot of memory in the Java application. In addition, the cash rose that can contain stale data. The data in the database can change, and you'll never see those changes after you get a cash ro set because it only has the data that was available at the time it was created. For these reasons, cash rose sets tend to be a good choice when you have data that rarely changes, such as products, list and data that's not too large. To demonstrate the use of the cash. Rosette will create one. Save it the disk and then D C Air lies and use it again. There are a number of methods for creating cash rosettes, but in this case, we're going to use the RO set factory to get the default cash rosette to get the factory called the Rose set provider class, from which we can manufacture the cash Rossetti. Once the roast that is created, we configure in a way similar to the way we do the driver manager. You can see in this case that we're using exactly the same you are Ellas. We used in all the earlier examples with You are all set. We can now set the query parameters we need to set the query parameter value on the SQL Cory, which has done exactly the same ways it would be with a prepared statement. We just call the appropriate set method in this case set string. Now we can execute the query and work with the results. Remember that the cash rose that is an extension of the results set so we can use all the same navigation and get myth is that we have used throughout this course with the same limitations, capabilities and exceptions. The cash Rossetti is disconnected assumes it's created as a disconnected job of being. We can work with it like we could. Any other being in this case will pass the cash ROCSAT back to the calling client. Here's the call to the order component, and, as you can see it returns. Akash Ro set will take that cash Rossetti and write it toe a file in the Java serialization format with a file handle and input stream. We can read the serialize cash rosette from disk and use it as if it's never serialized in the first place. Let's run it and see what happens. As you can see. Even though we wrote the cash roll set to disk, we were able to de serialize it and use it without having to reconnect to the database. In this last module, you learn about three more advanced jdb. See features, connection pooling transactions and rosettes. You're very likely to encounter situations where connection pooling is used, so having a solid understanding of that is important. But in most cases, the application server you're using will provide this automatically so you won't need to explicitly code for it. You should have a good understanding of how transactions buying two or more J to BC queries together so that they all succeed or fail together. And finally, J B C Row sets, especially the cash roll set, can be very useful for passing data around or persisting it to a file as it reduces the work your databases. It's best to do, but it should be used only in situations where you're working with a fairly small number of records. Relational databases are used by the vast majority of enterprises deploying applications in the Java programming language, and Java is the most popular programming language and used today. So jobs interface to relational databases that J. D. B, C. A. P. I is extremely important with the completion of this course you should be able to take on most if not all, J B C development projects. You know how to connect the databases, how to query and update databases using JDBC prepared statements and some more advanced features like working with clubs and blobs, stored procedures, connection pooling transactions and disconnected rosettes. I hope you've learned a lot and that you feel prepared for developing J B C applications. If you forget a detail, please come back and review this course. It should remain a resource you can revisit at any time. I'm Richard Monsen hateful, and I'm honored to be your instructor for this plural site course. Java Core Libraries JDBC. Good luck in your future JDBC. Development efforts.
